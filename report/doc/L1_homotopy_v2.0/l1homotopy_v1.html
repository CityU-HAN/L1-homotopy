<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of l1homotopy_v1</title>
  <meta name="keywords" content="l1homotopy_v1">
  <meta name="description" content="l1homotopy_v1.m">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html L1_homotopy_v2.0 -->
<h1>l1homotopy_v1
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>l1homotopy_v1.m</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function out = l1homotopy_v1(A, y, opts) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> l1homotopy_v1.m

 A general program that solves homotopy for
   a weighted LASSO/BPDN problem with or without a warm-start vector
   
   Some examples for dynamic updating include
   sequential measurements
   time-varying signal
   iterative reweighting
   measurement replacement
   dictionary learning
   Kalman-type filtering
   Streaming signal recovery 

   or any other problem that can be written in the following form:

 minimize_x  \Sum [1-epsilon]w_old + epsilon w_new]|x_i| + 1/2*||Ax-(1-epsilon)yh-epsilon y||_2^2 + (1-epsilon)u'x,

 where solution is updating by changing epsilon from 0 toward 1.
   yh = A*xh_old, 
   u = -w.*sign(xh_old) (where w can be the old or the new weights)

 Optimality conditions:

 A'(Ax-yh)+u + epsilon(A'(yh-y)-u) = -(w_old + epsilon(w_new-w_old))z    on Gamma
 |A'(Ax-yh)+u + epsilon(A'(yh-y)-u)| &lt; w_old + epsilon(w_new-w_old)    off Gamma

   
 Inputs:
  A -- M x N measurement matrix
  y -- measurements

  opts - input structure

   xh_old  -- old signal estimate
   gamma   -- support of xh_old

   (LHS terms)
   pk_old  -- A'(A*xh_old-yh)+u
   Atdyu   -- A'(yh-y)-u

   (RHS terms)
   W_old  -- w_old
   W_new  -- w_new

   AtAgx and iAtAgx (i.e., A(:,gamma)'*A(:,gamma) and its inverse)
   or QR/Cholesky factors

   delx_mode -- mode for rank-1 update ('mil', 'chol', or 'qr')
   nonneg  -- add nonneg constraint on the solution? (default = 0)
   maxiter -- maximum number of homotopy iterations
   Te      -- maximum support size allowed
   record  -- record iteration history
   x_orig  -- origianl signal for error history
   debias  -- debias the solution at the end
   early_terminate -- terminate early if the support is identified
                   (useful only in high SNR settings)
   verbose -- print output after every verbose steps
   plots   -- plot the solution at every iteration after verbose steps

 Outputs:
 out - output structure
   x_out - output for BPDN
   gamma - support of the solution
   iter - number of homotopy iterations taken by the solver
   time - time taken by the solver
   error_table - error table with iteration record
   iAtA on Gamma, or QR/Cholesky factors

 Written by: Salman Asif, Georgia Tech
 Email: sasif@gatech.edu

-------------------------------------------+
 Copyright (c) 2012.  M. Salman Asif
-------------------------------------------+</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../L1_homotopy_v2.0/utils/compute_delta.html" class="code" title="function out = compute_delta(in)">compute_delta</a>	</li><li><a href="../L1_homotopy_v2.0/utils/mvprod.html" class="code" title="">mvprod</a>	function lhs = mvprod(A,rhs,Gamma,flag)</li><li><a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>	script to ubpdate delx</li><li><a href="../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>	script to update support</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="demo_BPDN.html" class="code" title="">demo_BPDN</a>	demo_BPDN</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% l1homotopy_v1.m</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% A general program that solves homotopy for</span>
0004 <span class="comment">%   a weighted LASSO/BPDN problem with or without a warm-start vector</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%   Some examples for dynamic updating include</span>
0007 <span class="comment">%   sequential measurements</span>
0008 <span class="comment">%   time-varying signal</span>
0009 <span class="comment">%   iterative reweighting</span>
0010 <span class="comment">%   measurement replacement</span>
0011 <span class="comment">%   dictionary learning</span>
0012 <span class="comment">%   Kalman-type filtering</span>
0013 <span class="comment">%   Streaming signal recovery</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   or any other problem that can be written in the following form:</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% minimize_x  \Sum [1-epsilon]w_old + epsilon w_new]|x_i| + 1/2*||Ax-(1-epsilon)yh-epsilon y||_2^2 + (1-epsilon)u'x,</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% where solution is updating by changing epsilon from 0 toward 1.</span>
0020 <span class="comment">%   yh = A*xh_old,</span>
0021 <span class="comment">%   u = -w.*sign(xh_old) (where w can be the old or the new weights)</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% Optimality conditions:</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% A'(Ax-yh)+u + epsilon(A'(yh-y)-u) = -(w_old + epsilon(w_new-w_old))z    on Gamma</span>
0026 <span class="comment">% |A'(Ax-yh)+u + epsilon(A'(yh-y)-u)| &lt; w_old + epsilon(w_new-w_old)    off Gamma</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% Inputs:</span>
0030 <span class="comment">%  A -- M x N measurement matrix</span>
0031 <span class="comment">%  y -- measurements</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%  opts - input structure</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%   xh_old  -- old signal estimate</span>
0036 <span class="comment">%   gamma   -- support of xh_old</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%   (LHS terms)</span>
0039 <span class="comment">%   pk_old  -- A'(A*xh_old-yh)+u</span>
0040 <span class="comment">%   Atdyu   -- A'(yh-y)-u</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%   (RHS terms)</span>
0043 <span class="comment">%   W_old  -- w_old</span>
0044 <span class="comment">%   W_new  -- w_new</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%   AtAgx and iAtAgx (i.e., A(:,gamma)'*A(:,gamma) and its inverse)</span>
0047 <span class="comment">%   or QR/Cholesky factors</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%   delx_mode -- mode for rank-1 update ('mil', 'chol', or 'qr')</span>
0050 <span class="comment">%   nonneg  -- add nonneg constraint on the solution? (default = 0)</span>
0051 <span class="comment">%   maxiter -- maximum number of homotopy iterations</span>
0052 <span class="comment">%   Te      -- maximum support size allowed</span>
0053 <span class="comment">%   record  -- record iteration history</span>
0054 <span class="comment">%   x_orig  -- origianl signal for error history</span>
0055 <span class="comment">%   debias  -- debias the solution at the end</span>
0056 <span class="comment">%   early_terminate -- terminate early if the support is identified</span>
0057 <span class="comment">%                   (useful only in high SNR settings)</span>
0058 <span class="comment">%   verbose -- print output after every verbose steps</span>
0059 <span class="comment">%   plots   -- plot the solution at every iteration after verbose steps</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% Outputs:</span>
0062 <span class="comment">% out - output structure</span>
0063 <span class="comment">%   x_out - output for BPDN</span>
0064 <span class="comment">%   gamma - support of the solution</span>
0065 <span class="comment">%   iter - number of homotopy iterations taken by the solver</span>
0066 <span class="comment">%   time - time taken by the solver</span>
0067 <span class="comment">%   error_table - error table with iteration record</span>
0068 <span class="comment">%   iAtA on Gamma, or QR/Cholesky factors</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0071 <span class="comment">% Email: sasif@gatech.edu</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%-------------------------------------------+</span>
0074 <span class="comment">% Copyright (c) 2012.  M. Salman Asif</span>
0075 <span class="comment">%-------------------------------------------+</span>
0076 
0077 <a name="_sub0" href="#_subfunctions" class="code">function out = l1homotopy_v1(A, y, opts)</a>
0078 
0079 N = size(A,2);
0080 M = size(A,1);
0081 
0082 <span class="comment">% Use prior, related information if provided</span>
0083 <span class="comment">% old solution</span>
0084 <span class="keyword">if</span> isfield(opts,<span class="string">'xh_old'</span>); xh_old = opts.xh_old; <span class="keyword">else</span> xh_old = zeros(N,1); <span class="keyword">end</span>
0085 <span class="comment">% old solution constraints</span>
0086 <span class="keyword">if</span> isfield(opts,<span class="string">'pk_old'</span>); pk_old = opts.pk_old; <span class="keyword">else</span> pk_old = -A'*y; <span class="keyword">end</span>
0087 <span class="comment">% old solution support</span>
0088 <span class="keyword">if</span> isfield(opts,<span class="string">'gamma'</span>); gamma_xh = opts.gamma; <span class="keyword">else</span> gamma_xh = []; <span class="keyword">end</span>
0089 <span class="keyword">if</span> isempty(gamma_xh); [tau_old gamma_xh] = max(abs(pk_old)); <span class="keyword">end</span>
0090 <span class="comment">% dummy variable (..)</span>
0091 <span class="keyword">if</span> isfield(opts,<span class="string">'Atdyu'</span>); Atdyu = opts.Atdyu; <span class="keyword">else</span> Atdyu = 0; <span class="keyword">end</span>
0092 <span class="comment">% new regularization parameters</span>
0093 <span class="keyword">if</span> isfield(opts,<span class="string">'W_new'</span>); W_new = opts.W_new; <span class="keyword">else</span> W_new = opts.tau; <span class="keyword">end</span>
0094 <span class="comment">% old regularization parameters</span>
0095 <span class="keyword">if</span> isfield(opts,<span class="string">'W_old'</span>); W_old = opts.W_old; <span class="keyword">else</span> W_old = tau_old; <span class="keyword">end</span>
0096 <span class="comment">% no initial solution</span>
0097 <span class="keyword">if</span> norm(xh_old) == 0; pk_old = -A'*y; Atdyu = 0; [tau_old gamma_xh] = max(abs(pk_old)); W_old = tau_old; <span class="keyword">end</span>
0098 <span class="comment">% input is a zero vector</span>
0099 <span class="keyword">if</span> norm(y) == 0; 
0100     out = opts;
0101     out.x_out = zeros(N,1);
0102     out.gamma = []; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0103     out.iter = 0;
0104     out.time = 0;
0105     disp(<span class="string">'input is a zero vector'</span>);
0106     <span class="keyword">return</span>;
0107 <span class="keyword">end</span>
0108 <span class="comment">% output is a zero vector</span>
0109 <span class="keyword">if</span> nnz(abs(A'*y) &lt; W_new) == N
0110     out = opts;
0111     out.x_out = zeros(N,1);
0112     out.gamma = []; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0113     out.iter = 0;
0114     out.time = 0;
0115     disp(<span class="string">'output is a zero vector'</span>);
0116     <span class="keyword">return</span>;
0117 <span class="keyword">end</span>
0118 
0119 <span class="comment">% Make vectors out of scalar regularization parameters..</span>
0120 W_old = ones(N,1).*W_old; W_new = ones(N,1).*W_new;
0121 
0122 <span class="comment">% maximum iterations</span>
0123 <span class="keyword">if</span> isfield(opts,<span class="string">'maxiter'</span>); maxiter = opts.maxiter; <span class="keyword">else</span> maxiter = 2*N; <span class="keyword">end</span>
0124 <span class="comment">% non-negativity constraint</span>
0125 <span class="keyword">if</span> isfield(opts,<span class="string">'nonneg'</span>); nonneg = opts.nonneg; <span class="keyword">else</span> nonneg = 0; <span class="keyword">end</span>
0126 <span class="comment">% maximum support size</span>
0127 <span class="keyword">if</span> isfield(opts,<span class="string">'Te'</span>); Te = opts.Te; <span class="keyword">else</span> Te = inf; <span class="keyword">end</span>
0128 <span class="comment">% record error/history</span>
0129 <span class="keyword">if</span> isfield(opts,<span class="string">'record'</span>); err_record = opts.record; <span class="keyword">else</span> err_record = 0; <span class="keyword">end</span>
0130 <span class="keyword">if</span> err_record; err_fun = opts.err_fun; <span class="keyword">end</span> 
0131 <span class="comment">% debiasing step at the end (solve LS on the support)</span>
0132 <span class="keyword">if</span> isfield(opts,<span class="string">'debias'</span>); debias = opts.debias; <span class="keyword">else</span> debias = 0; <span class="keyword">end</span>
0133 <span class="comment">% early terminate if residual of restricted LS falls below certain</span>
0134 <span class="comment">% threshold</span>
0135 <span class="keyword">if</span> isfield(opts,<span class="string">'early_terminate'</span>); early_terminate = opts.early_terminate; <span class="keyword">else</span> early_terminate = 0; <span class="keyword">end</span>
0136 <span class="comment">% print output</span>
0137 <span class="keyword">if</span> isfield(opts,<span class="string">'verbose'</span>); verbose = opts.verbose; <span class="keyword">else</span> verbose = 0; <span class="keyword">end</span>
0138 <span class="comment">% debug plots</span>
0139 <span class="keyword">if</span> isfield(opts,<span class="string">'plots'</span>); plots = opts.plots; <span class="keyword">else</span> plots = 0; <span class="keyword">end</span>
0140 
0141 <span class="comment">%% GO</span>
0142 t0 = cputime;
0143 
0144 <span class="comment">%% Initial step</span>
0145 epsilon = 0;
0146 Wk = (1-epsilon)*W_old + epsilon*W_new;
0147 dW = W_new-W_old;
0148 
0149 temp_gamma = zeros(N,1);
0150 temp_gamma(gamma_xh) = gamma_xh;
0151 gamma_xc = find([1:N]' ~= temp_gamma);
0152 
0153 z_x = zeros(N,1);
0154 z_x(gamma_xh) = -sign(pk_old(gamma_xh));
0155 pk_old(gamma_xh) = sign(pk_old(gamma_xh)).*W_old(gamma_xh);
0156 pk = pk_old;
0157 dk = 0*pk;
0158 xk_1 = xh_old;
0159 
0160 <span class="comment">% Initial step setup</span>
0161 idelta = gamma_xh(1); flag = 1;    
0162 
0163 <span class="comment">% initialize delx</span>
0164 in_delx = [];
0165 delx_mode = opts.delx_mode;
0166 rhs = -dW.*z_x-Atdyu;
0167 
0168 <span class="keyword">if</span> norm(xh_old)==0 &amp;&amp; length(gamma_xh) == 1    
0169     update_mode = <span class="string">'init0'</span>;
0170 <span class="keyword">else</span>    
0171     update_mode = <span class="string">'init1'</span>;
0172 <span class="keyword">end</span>
0173 <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0174 
0175 <span class="comment">%% loop parameters</span>
0176 done = 0;
0177 iter = 0;
0178 itr_history = [];
0179 error_table = [];
0180 <span class="keyword">if</span> err_record
0181     error_table = [epsilon err_fun(xk_1) length(gamma_xh)];
0182 <span class="keyword">end</span>
0183 
0184 <span class="keyword">while</span> iter &lt; maxiter
0185     iter = iter+1;
0186     <span class="comment">% warning('off','MATLAB:divideByZero')</span>
0187     
0188     <span class="comment">%% Homotopy</span>
0189     x_k = xk_1;
0190     
0191     <span class="comment">% Update direction</span>
0192     delx_vec = zeros(N,1);
0193     delx_vec(gamma_xh) = delx;
0194     
0195     <span class="keyword">if</span> ~isempty(idelta) &amp;&amp; (sign(delx_vec(idelta)) == sign(pk_old(idelta)) &amp;&amp; abs(x_k(idelta)) == 0)
0196         delta = 0; flag = 0;
0197     <span class="keyword">else</span>
0198         pk = pk_old;
0199         <span class="comment">% dk = AtA*delx_vec;</span>
0200         <span class="comment">% dk_temp = A*delx_vec;</span>
0201         dk_temp = <a href="../L1_homotopy_v2.0/utils/mvprod.html" class="code" title="">mvprod</a>(A,delx_vec,gamma_xh,0);
0202         dk = A'*dk_temp+Atdyu;
0203         
0204         <span class="comment">%%%--- compute step size</span>
0205         in = [];
0206         
0207         <span class="comment">% Setting shrinkage_flag to zero shrinks new active constraint towards the</span>
0208         <span class="comment">% final value instantly if doing so doesn't disturb the active set</span>
0209         in.shrinkage_flag = 2; <span class="comment">% determines how to select the stepsize/support</span>
0210         in.nonneg = nonneg; <span class="comment">% imposes non-negativity constraint on the solution</span>
0211         in.pk = pk; in.dk = dk;
0212         in.ak = Wk; in.bk = dW;
0213         in.gamma = gamma_xh; in.gamma_c = gamma_xc;
0214         in.delx_vec = delx_vec; in.x = xk_1; 
0215         out = <a href="../L1_homotopy_v2.0/utils/compute_delta.html" class="code" title="function out = compute_delta(in)">compute_delta</a>(in);
0216         delta = out.delta; idelta = out.idelta;
0217         flag = out.flag;
0218     <span class="keyword">end</span>
0219     e0 = epsilon;
0220     epsilon = e0 + delta;
0221     
0222     <span class="keyword">if</span> epsilon &gt; 1
0223         delta_end = 1-e0;
0224         xk_1 = x_k + delta_end*delx_vec;
0225         pk_old = pk + delta_end*dk;
0226         Wk = W_new;
0227         pk_old(gamma_xh) = sign(pk_old(gamma_xh)).*Wk(gamma_xh);
0228         <span class="keyword">break</span>;
0229     <span class="keyword">end</span>
0230     
0231     xk_1 = x_k + delta*delx_vec;
0232     gamma_old = gamma_xh;
0233     
0234     itr_history = [itr_history; idelta delta flag];
0235     
0236     <span class="comment">% update support</span>
0237     <a href="../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>;
0238 
0239     pk_old = pk+delta*dk;
0240     Wk_old = Wk;
0241     Wk = (1-epsilon)*W_old + epsilon*W_new;
0242     pk_old([gamma_xh; idelta]) = sign(pk_old([gamma_xh; idelta])).*Wk([gamma_xh; idelta]);
0243     
0244     <span class="comment">% update delx</span>
0245     z_x = -sign(pk_old);
0246     rhs = -dW.*z_x-Atdyu;
0247     update_mode = <span class="string">'update'</span>;
0248     <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0249     
0250     <span class="comment">%     AtAgx = (A(:,gamma_xh)'*A(:,gamma_xh));</span>
0251     <span class="comment">%     delx2 = AtAgx\rhs(gamma_xh); % -AtAgx\(dW(gamma_xh).*z_x);</span>
0252     <span class="comment">%     figure(112); plot([delx delx2]);</span>
0253     <span class="comment">%     if norm(delx-delx2) &gt; 1e-5</span>
0254     <span class="comment">%         stp = 1;</span>
0255     <span class="comment">%     end</span>
0256     
0257     
0258     <span class="comment">% Check convergence criterion (this can be useful)...</span>
0259     <span class="keyword">if</span> early_terminate
0260         <span class="keyword">if</span> length(gamma_xh) &lt; M/2
0261             xhat = zeros(N,1);
0262             <span class="comment">% xhat(gamma_xh) = AtAgx\(A(:,gamma_xh)'*y);</span>
0263             <span class="keyword">switch</span> delx_mode
0264                 <span class="keyword">case</span> <span class="string">'mil'</span>
0265                     xhat(gamma_xh) = iAtA*(A(:,gamma_xh)'*y);
0266                 <span class="keyword">case</span> {<span class="string">'qr'</span>,<span class="string">'chol'</span>}
0267                     xhat(gamma_xh) = R\(R'\(A(:,gamma_xh)'*y));
0268             <span class="keyword">end</span>
0269             <span class="keyword">if</span> norm(y-A*xhat) &lt; tau
0270                 xk_1 = xhat;
0271                 <span class="keyword">break</span>;
0272             <span class="keyword">end</span>
0273         <span class="keyword">end</span>
0274     <span class="keyword">end</span>
0275     
0276     
0277     <span class="keyword">if</span> err_record        
0278         error_table = [error_table; epsilon err_fun(xk_1) length(gamma_xh)];
0279     <span class="keyword">end</span>
0280     
0281     <span class="comment">%% debug</span>
0282     constr_violation = nnz((abs(pk_old(gamma_xc))-Wk(gamma_xc))&gt;1e-10);
0283     sign_violation = nnz((sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh)))&gt;1);
0284     <span class="keyword">if</span> constr_violation
0285         chk = gamma_xc((abs(pk_old(gamma_xc))-Wk(gamma_xc))&gt;1e-10);
0286         stp = 1;
0287         fprintf(<span class="string">'problem... with constraint violation -- %s \n'</span>, mfilename);
0288         fprintf(<span class="string">'Refactorize the matrix... recompute delx \n'</span>);
0289         <span class="comment">% some times it comes here due to bad conditioning of AtAgx.</span>
0290         update_mode = <span class="string">'init0'</span>;
0291         <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0292     <span class="keyword">end</span>
0293     <span class="keyword">if</span> sign_violation&gt;=1
0294         chk = gamma_xh(sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh))&gt;1);
0295         stp = 1;
0296         fprintf(<span class="string">'problem... sign mismatch -- %s \n'</span>,mfilename);
0297         fprintf(<span class="string">'Refactorize the matrix... recompute delx \n'</span>);
0298         update_mode = <span class="string">'init0'</span>;
0299         <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0300     <span class="keyword">end</span>
0301     
0302     <span class="comment">%% print and plot</span>
0303     <span class="keyword">if</span> mod(iter-1,verbose) == 0 &amp;&amp; verbose
0304         fprintf([<span class="string">'iter = %d, delta = %3.4g, idelta = %d, flag = %d.\n'</span>], iter, delta, idelta, flag);
0305     <span class="keyword">end</span>
0306     <span class="keyword">if</span> mod(iter-1,plots) == 0 &amp;&amp; plots
0307         fig1 = figure(1234);
0308         subplot(2,1,1)
0309         hold off
0310         plot(pk,<span class="string">'.r'</span>, <span class="string">'MarkerSize'</span>,14);
0311         hold on;
0312         plot(pk_old, <span class="string">'LineWidth'</span>,1);
0313         
0314         <span class="keyword">if</span> flag == 1
0315             plot(idelta, pk_old(idelta),<span class="string">'or'</span>,<span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0316             text(idelta, pk_old(idelta)*1.1, [<span class="string">'Incoming \gamma = '</span>,num2str(idelta)],<span class="string">'FontSize'</span>,14);
0317         <span class="keyword">else</span>
0318             plot(idelta, pk_old(idelta),<span class="string">'ok'</span>,<span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0319             text(idelta, pk_old(idelta)*1.1, [<span class="string">'Outgoing \gamma = '</span>,num2str(idelta)],<span class="string">'FontSize'</span>,14);
0320         <span class="keyword">end</span>
0321         set(gca,<span class="string">'FontSize'</span>,16, <span class="string">'XLim'</span>,[1 N] );
0322         title(sprintf(<span class="string">'BPDN shrinkage constraints: N = %d, M = %d'</span>, N, M));
0323         plot(1:N, Wk,<span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0324         plot(1:N, -Wk, <span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0325         plot(1:N, Wk_old,<span class="string">'--m'</span>,<span class="string">'MarkerSize'</span>,12);
0326         plot(1:N, -Wk_old, <span class="string">'--m'</span>,<span class="string">'MarkerSize'</span>,12);
0327         
0328         figure(fig1);
0329         subplot(2,1,2)
0330         hold off
0331         plot(x_k,<span class="string">'.r'</span>,<span class="string">'MarkerSize'</span>,14); hold on;
0332         plot(xk_1,<span class="string">'LineWidth'</span>,1);
0333         <span class="keyword">if</span> flag == 0
0334             plot(idelta, 0,<span class="string">'ok'</span>, <span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0335         <span class="keyword">else</span>
0336             plot(idelta, 0,<span class="string">'or'</span>, <span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0337         <span class="keyword">end</span>
0338         set(gca,<span class="string">'FontSize'</span>,16,<span class="string">'XLim'</span>,[1 N]);
0339         title([<span class="string">'Solution estimate at \epsilon = '</span>,num2str(epsilon), <span class="string">', iter. = '</span>, num2str(iter)]);
0340         
0341         <span class="keyword">if</span> iter == 1 &amp;&amp; verbose
0342             disp(<span class="string">'  '</span>);
0343             disp(<span class="string">'Every frame in the figure corresponds to a critical point on the homotopy path.'</span>)
0344             disp(<span class="string">'Circle represents an incoming element, star represents an outgoing element.'</span>);
0345             disp(<span class="string">' '</span>);
0346             disp(<span class="string">'Put pause somewhere in the code to see this. '</span>);
0347             disp(<span class="string">'For now press some key to continue...'</span>);
0348             pause
0349         <span class="keyword">end</span>
0350     <span class="keyword">end</span>
0351     
0352 <span class="keyword">end</span>
0353 
0354 <span class="comment">%% debiasing step?</span>
0355 <span class="keyword">if</span> debias
0356     x_out = zeros(N,1);
0357     <span class="keyword">switch</span> delx_mode
0358         <span class="keyword">case</span> <span class="string">'mil'</span>
0359             x_out(gamma_xh) = iAtA*(A(:,gamma_xh)'*y);
0360         <span class="keyword">case</span> {<span class="string">'qr'</span>,<span class="string">'chol'</span>}
0361             x_out(gamma_xh) = R\(R'\(A(:,gamma_xh)'*y));
0362     <span class="keyword">end</span>
0363 <span class="keyword">else</span>
0364     x_out = xk_1;
0365 <span class="keyword">end</span>
0366 
0367 <span class="comment">%</span>
0368 <span class="keyword">if</span> err_record
0369     error_table = [error_table; epsilon err_fun(x_out) length(gamma_xh)];
0370 <span class="keyword">end</span>
0371 total_iter = iter;
0372 total_time = cputime-t0;
0373 
0374 <span class="comment">%% Output the results</span>
0375 out = opts;
0376 out.x_out = x_out;
0377 out.gamma = gamma_xh; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0378 out.iter = total_iter;
0379 out.time = total_time;
0380 out.error_table = error_table;
0381 out.pk = pk_old;
0382 <span class="keyword">switch</span> delx_mode
0383     <span class="keyword">case</span> <span class="string">'mil'</span>
0384         out.iAtA = iAtA;
0385     <span class="keyword">case</span> <span class="string">'qr'</span>
0386         out.Q = Q;
0387         out.R = R;
0388     <span class="keyword">case</span> <span class="string">'chol'</span>
0389         out.R = R;
0390     <span class="keyword">case</span> <span class="string">'qrM'</span>
0391         out.Q0 = Q0;
0392         out.R0 = R0;
0393 <span class="keyword">end</span>
0394</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of l1homotopy</title>
  <meta name="keywords" content="l1homotopy">
  <meta name="description" content="l1homotopy.m">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html L1_homotopy_v2.0 -->
<h1>l1homotopy
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>l1homotopy.m</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function out = l1homotopy(A, y, opts) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> l1homotopy.m

 A general program that solves homotopy for
   a weighted LASSO/BPDN problem with or without a warm-start vector
   
   Some examples for dynamic updating include
   sequential measurements
   time-varying signal
   iterative reweighting
   measurement replacement
   dictionary learning
   Kalman-type filtering
   Streaming signal recovery 

   or any other problem that can be written in the following form:

 minimize_x  \|W x\|_1 + 1/2*\|Ax-y\|_2^2 + (1-epsilon)u'x,

   u is defined as u = -W*sign(xh_old)-A'*(A*xh_old-y) 
   and xh_old is an arbitrary warm-start vector 
   (zero vector if no warm-start is available). 

   The homotopy is solved by changing epsilon from 0 to 1. 
   

 Optimality conditions:

  A'(Ax-y)+u - epsilon(u)  = - W z    on Gamma
 |A'(Ax-y)+u - epsilon(u)| &lt;   W      off Gamma

   
 Inputs:
  A -- M x N measurement matrix
  y -- measurements

  opts - input structure

   xh_old  -- old signal estimate (if warm-start is not provided, then xh_old is set to zero)
   gamma   -- support of xh_old

   pk_old  -- A'(A*xh_old-y)+u
   u       -- -W*sign(xh_old)-A'(A*xh_old-y)
   W       -- weights for the L1 term... 

   AtAgx and iAtAgx (i.e., A(:,gamma)'*A(:,gamma) and its inverse)
   or QR/Cholesky factors

   delx_mode -- mode for rank-1 update ('mil', 'chol', or 'qr')
   nonneg  -- add nonneg constraint on the solution? (default = 0)
   maxiter -- maximum number of homotopy iterations
   Te      -- maximum support size allowed
   record  -- record iteration history
   x_orig  -- origianl signal for error history
   debias  -- debias the solution at the end
   early_terminate -- terminate early if the support is identified
                   (useful only in high SNR settings)
   verbose -- print output after every verbose steps
   plots   -- plot the solution at every iteration after verbose steps

 Outputs:
 out -- output structure
   x_out -- output for BPDN
   gamma -- support of the solution
   iter -- number of homotopy iterations taken by the solver
   time -- time taken by the solver
   error_table -- error table with iteration record
   iAtA on Gamma, or QR/Cholesky factors

 Written by: Salman Asif, Georgia Tech
 Email: sasif@gatech.edu
 Web: http://users.ece.gatech.edu/~sasif/

 References: 
 1. Sparse recovery of streaming signals using L1-homotopy, 
       by M. Salman Asif and Justin Romberg 
 2. Dynamic compressive sensing: Sparse recovery of streaming signals and video, 
       by M. Salman Asif (Ph.D. thesis) 

-------------------------------------------+
 Copyright (c) 2013.  M. Salman Asif
-------------------------------------------+</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../L1_homotopy_v2.0/utils/compute_delta_v2.html" class="code" title="function out = compute_delta_v2(in)">compute_delta_v2</a>	</li><li><a href="../L1_homotopy_v2.0/utils/mvprod.html" class="code" title="">mvprod</a>	function lhs = mvprod(A,rhs,Gamma,flag)</li><li><a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>	script to ubpdate delx</li><li><a href="../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>	script to update support</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="demo_BPDN.html" class="code" title="">demo_BPDN</a>	demo_BPDN</li><li><a href="demo_KalmanRWT.html" class="code" title="">demo_KalmanRWT</a>	demo_KalmanRWT</li><li><a href="demo_dynamicRWT.html" class="code" title="">demo_dynamicRWT</a>	demo_dynamicRWT</li><li><a href="demo_dynamicSeq.html" class="code" title="">demo_dynamicSeq</a>	demo_dynamicSeq</li><li><a href="demo_dynamicX.html" class="code" title="">demo_dynamicX</a>	demo_dynamicX</li><li><a href="demo_posBPDN.html" class="code" title="">demo_posBPDN</a>	demo_posBPDN</li><li><a href="demo_replaceDict.html" class="code" title="">demo_replaceDict</a>	demo_replaceDict</li><li><a href="demo_rwtL1.html" class="code" title="">demo_rwtL1</a>	demo_rwtL1</li><li><a href="demo_streaming.html" class="code" title="">demo_streaming</a>	demo_streaming</li><li><a href="demo_streamingDWT.html" class="code" title="">demo_streamingDWT</a>	demo_streamingDWT</li><li><a href="demo_streamingLOT.html" class="code" title="">demo_streamingLOT</a>	demo_streamingLOT</li><li><a href="readme.html" class="code" title="">readme</a>	----------L1 Homotopy Package-------------+</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% l1homotopy.m</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% A general program that solves homotopy for</span>
0004 <span class="comment">%   a weighted LASSO/BPDN problem with or without a warm-start vector</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%   Some examples for dynamic updating include</span>
0007 <span class="comment">%   sequential measurements</span>
0008 <span class="comment">%   time-varying signal</span>
0009 <span class="comment">%   iterative reweighting</span>
0010 <span class="comment">%   measurement replacement</span>
0011 <span class="comment">%   dictionary learning</span>
0012 <span class="comment">%   Kalman-type filtering</span>
0013 <span class="comment">%   Streaming signal recovery</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   or any other problem that can be written in the following form:</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% minimize_x  \|W x\|_1 + 1/2*\|Ax-y\|_2^2 + (1-epsilon)u'x,</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%   u is defined as u = -W*sign(xh_old)-A'*(A*xh_old-y)</span>
0020 <span class="comment">%   and xh_old is an arbitrary warm-start vector</span>
0021 <span class="comment">%   (zero vector if no warm-start is available).</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%   The homotopy is solved by changing epsilon from 0 to 1.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Optimality conditions:</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%  A'(Ax-y)+u - epsilon(u)  = - W z    on Gamma</span>
0029 <span class="comment">% |A'(Ax-y)+u - epsilon(u)| &lt;   W      off Gamma</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Inputs:</span>
0033 <span class="comment">%  A -- M x N measurement matrix</span>
0034 <span class="comment">%  y -- measurements</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%  opts - input structure</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%   xh_old  -- old signal estimate (if warm-start is not provided, then xh_old is set to zero)</span>
0039 <span class="comment">%   gamma   -- support of xh_old</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   pk_old  -- A'(A*xh_old-y)+u</span>
0042 <span class="comment">%   u       -- -W*sign(xh_old)-A'(A*xh_old-y)</span>
0043 <span class="comment">%   W       -- weights for the L1 term...</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%   AtAgx and iAtAgx (i.e., A(:,gamma)'*A(:,gamma) and its inverse)</span>
0046 <span class="comment">%   or QR/Cholesky factors</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%   delx_mode -- mode for rank-1 update ('mil', 'chol', or 'qr')</span>
0049 <span class="comment">%   nonneg  -- add nonneg constraint on the solution? (default = 0)</span>
0050 <span class="comment">%   maxiter -- maximum number of homotopy iterations</span>
0051 <span class="comment">%   Te      -- maximum support size allowed</span>
0052 <span class="comment">%   record  -- record iteration history</span>
0053 <span class="comment">%   x_orig  -- origianl signal for error history</span>
0054 <span class="comment">%   debias  -- debias the solution at the end</span>
0055 <span class="comment">%   early_terminate -- terminate early if the support is identified</span>
0056 <span class="comment">%                   (useful only in high SNR settings)</span>
0057 <span class="comment">%   verbose -- print output after every verbose steps</span>
0058 <span class="comment">%   plots   -- plot the solution at every iteration after verbose steps</span>
0059 <span class="comment">%</span>
0060 <span class="comment">% Outputs:</span>
0061 <span class="comment">% out -- output structure</span>
0062 <span class="comment">%   x_out -- output for BPDN</span>
0063 <span class="comment">%   gamma -- support of the solution</span>
0064 <span class="comment">%   iter -- number of homotopy iterations taken by the solver</span>
0065 <span class="comment">%   time -- time taken by the solver</span>
0066 <span class="comment">%   error_table -- error table with iteration record</span>
0067 <span class="comment">%   iAtA on Gamma, or QR/Cholesky factors</span>
0068 <span class="comment">%</span>
0069 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0070 <span class="comment">% Email: sasif@gatech.edu</span>
0071 <span class="comment">% Web: http://users.ece.gatech.edu/~sasif/</span>
0072 <span class="comment">%</span>
0073 <span class="comment">% References:</span>
0074 <span class="comment">% 1. Sparse recovery of streaming signals using L1-homotopy,</span>
0075 <span class="comment">%       by M. Salman Asif and Justin Romberg</span>
0076 <span class="comment">% 2. Dynamic compressive sensing: Sparse recovery of streaming signals and video,</span>
0077 <span class="comment">%       by M. Salman Asif (Ph.D. thesis)</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%-------------------------------------------+</span>
0080 <span class="comment">% Copyright (c) 2013.  M. Salman Asif</span>
0081 <span class="comment">%-------------------------------------------+</span>
0082 
0083 <span class="comment">% Change history</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% 05-29-13 -- name changed from l1homotopy_v2 to l1homotopy</span>
0086 
0087 <a name="_sub0" href="#_subfunctions" class="code">function out = l1homotopy(A, y, opts)</a>
0088 
0089 N = size(A,2);
0090 M = size(A,1);
0091 
0092 <span class="comment">% Use prior, related information if provided</span>
0093 <span class="comment">% Weights or regularization parameter...</span>
0094 <span class="keyword">if</span> isfield(opts,<span class="string">'W'</span>); W = opts.W; <span class="keyword">else</span> W = opts.tau; <span class="keyword">end</span>
0095 <span class="keyword">if</span> isfield(opts,<span class="string">'xh_old'</span>); 
0096     <span class="comment">% old solution</span>
0097     xh_old = opts.xh_old; 
0098     <span class="comment">% old solution constraints</span>
0099     pk_old = opts.pk_old;
0100     <span class="comment">% old solution support</span>
0101     gamma_xh = opts.gamma;
0102     <span class="comment">% dummy variable (..)</span>
0103     u = opts.u;
0104 <span class="keyword">else</span>
0105     xh_old = zeros(N,1); 
0106 <span class="keyword">end</span>
0107 
0108 <span class="comment">% no initial solution</span>
0109 <span class="keyword">if</span> norm(xh_old) == 0;     
0110     pk_old = -A'*y;
0111     [tau_old gamma_xh] = max(abs(pk_old));
0112     z_x = zeros(N,1);
0113     z_x(gamma_xh) = -sign(pk_old(gamma_xh));
0114     u = -W.*z_x-pk_old;
0115     pk_old = pk_old+u;
0116 <span class="keyword">end</span>
0117 
0118 <span class="comment">% input is a zero vector</span>
0119 <span class="keyword">if</span> norm(y) == 0; 
0120     out = opts;
0121     out.x_out = zeros(N,1);
0122     out.gamma = []; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0123     out.iter = 0;
0124     out.time = 0;
0125     disp(<span class="string">'input is a zero vector'</span>);
0126     <span class="keyword">return</span>;
0127 <span class="keyword">end</span>
0128 <span class="comment">% output is a zero vector</span>
0129 <span class="keyword">if</span> nnz(abs(A'*y) &lt; W) == N
0130     out = opts;
0131     out.x_out = zeros(N,1);
0132     out.gamma = []; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0133     out.iter = 0;
0134     out.time = 0;
0135     disp(<span class="string">'output is a zero vector'</span>);
0136     <span class="keyword">return</span>;
0137 <span class="keyword">end</span>
0138 
0139 <span class="comment">% Make vectors out of scalar regularization parameters..</span>
0140 W = ones(N,1).*W;
0141 
0142 <span class="comment">% maximum iterations</span>
0143 <span class="keyword">if</span> isfield(opts,<span class="string">'maxiter'</span>); maxiter = opts.maxiter; <span class="keyword">else</span> maxiter = 2*N; <span class="keyword">end</span>
0144 <span class="comment">% non-negativity constraint</span>
0145 <span class="keyword">if</span> isfield(opts,<span class="string">'nonneg'</span>); nonneg = opts.nonneg; <span class="keyword">else</span> nonneg = 0; <span class="keyword">end</span>
0146 <span class="comment">% maximum support size</span>
0147 <span class="keyword">if</span> isfield(opts,<span class="string">'Te'</span>); Te = opts.Te; <span class="keyword">else</span> Te = inf; <span class="keyword">end</span>
0148 <span class="comment">% record error/history</span>
0149 <span class="keyword">if</span> isfield(opts,<span class="string">'record'</span>); err_record = opts.record; <span class="keyword">else</span> err_record = 0; <span class="keyword">end</span>
0150 <span class="keyword">if</span> err_record; err_fun = opts.err_fun; <span class="keyword">end</span> 
0151 <span class="comment">% debiasing step at the end (solve LS on the support)</span>
0152 <span class="keyword">if</span> isfield(opts,<span class="string">'debias'</span>); debias = opts.debias; <span class="keyword">else</span> debias = 0; <span class="keyword">end</span>
0153 <span class="comment">% early terminate if residual of restricted LS falls below certain</span>
0154 <span class="comment">% threshold</span>
0155 <span class="keyword">if</span> isfield(opts,<span class="string">'early_terminate'</span>); early_terminate = opts.early_terminate; <span class="keyword">else</span> early_terminate = 0; <span class="keyword">end</span>
0156 <span class="comment">% print output</span>
0157 <span class="keyword">if</span> isfield(opts,<span class="string">'verbose'</span>); verbose = opts.verbose; <span class="keyword">else</span> verbose = 0; <span class="keyword">end</span>
0158 <span class="comment">% debug plots</span>
0159 <span class="keyword">if</span> isfield(opts,<span class="string">'plots'</span>); plots = opts.plots; <span class="keyword">else</span> plots = 0; <span class="keyword">end</span>
0160 
0161 <span class="comment">%% GO</span>
0162 t0 = cputime;
0163 
0164 <span class="comment">%% Initial step</span>
0165 epsilon = 0; 
0166 
0167 temp_gamma = zeros(N,1);
0168 temp_gamma(gamma_xh) = gamma_xh;
0169 gamma_xc = find([1:N]' ~= temp_gamma);
0170 
0171 z_x = zeros(N,1);
0172 z_x(gamma_xh) = -sign(pk_old(gamma_xh));
0173 pk_old(gamma_xh) = sign(pk_old(gamma_xh)).*W(gamma_xh);
0174 pk = pk_old;
0175 dk = 0*pk;
0176 xk_1 = xh_old;
0177 
0178 <span class="comment">% Initial step setup</span>
0179 idelta = gamma_xh(1); flag = 1;    
0180 
0181 <span class="comment">% initialize delx</span>
0182 in_delx = [];
0183 delx_mode = opts.delx_mode;
0184 rhs = u;
0185 
0186 <span class="keyword">if</span> norm(xh_old)==0 &amp;&amp; length(gamma_xh) == 1    
0187     update_mode = <span class="string">'init0'</span>;
0188 <span class="keyword">else</span>    
0189     update_mode = <span class="string">'init1'</span>;
0190 <span class="keyword">end</span>
0191 <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0192 
0193 <span class="comment">%% loop parameters</span>
0194 done = 0;
0195 iter = 0;
0196 itr_history = [];
0197 error_table = [];
0198 <span class="keyword">if</span> err_record
0199     error_table = [epsilon err_fun(xk_1) length(gamma_xh)];
0200 <span class="keyword">end</span>
0201 
0202 <span class="keyword">while</span> iter &lt; maxiter
0203     iter = iter+1;
0204     <span class="comment">% warning('off','MATLAB:divideByZero')</span>
0205     
0206     <span class="comment">%% Homotopy</span>
0207     x_k = xk_1;
0208     
0209     <span class="comment">% Update direction</span>
0210     delx_vec = zeros(N,1);
0211     delx_vec(gamma_xh) = delx;
0212     
0213     <span class="keyword">if</span> ~isempty(idelta) &amp;&amp; (sign(delx_vec(idelta)) == sign(pk_old(idelta)) &amp;&amp; abs(x_k(idelta)) == 0)
0214         delta = 0; flag = 0;
0215     <span class="keyword">else</span>
0216         pk = pk_old;
0217         <span class="comment">% dk = AtA*delx_vec;</span>
0218         <span class="comment">% dk_temp = A*delx_vec;</span>
0219         dk_temp = <a href="../L1_homotopy_v2.0/utils/mvprod.html" class="code" title="">mvprod</a>(A,delx_vec,gamma_xh,0);
0220         dk = A'*dk_temp-u;
0221         
0222         <span class="comment">%%%--- compute step size</span>
0223         in = [];
0224         
0225         <span class="comment">% Setting shrinkage_flag to zero shrinks new active constraint towards the</span>
0226         <span class="comment">% final value instantly if doing so doesn't disturb the active set</span>
0227         in.shrinkage_flag = 2; <span class="comment">% determines how to select the stepsize/support</span>
0228         in.nonneg = nonneg; <span class="comment">% imposes non-negativity constraint on the solution</span>
0229         in.pk = pk; in.dk = dk;
0230         in.ak = W; 
0231         in.gamma = gamma_xh; in.gamma_c = gamma_xc;
0232         in.delx_vec = delx_vec; in.x = xk_1; 
0233         out = <a href="../L1_homotopy_v2.0/utils/compute_delta_v2.html" class="code" title="function out = compute_delta_v2(in)">compute_delta_v2</a>(in);
0234         delta = out.delta; idelta = out.idelta;
0235         flag = out.flag;
0236     <span class="keyword">end</span>
0237     e0 = epsilon;
0238     epsilon = e0 + delta;
0239     
0240     <span class="keyword">if</span> epsilon &gt; 1
0241         delta_end = 1-e0;
0242         xk_1 = x_k + delta_end*delx_vec;
0243         pk_old = pk + delta_end*dk;
0244         pk_old(gamma_xh) = sign(pk_old(gamma_xh)).*W(gamma_xh);
0245         <span class="keyword">break</span>;
0246     <span class="keyword">end</span>
0247     
0248     xk_1 = x_k + delta*delx_vec;
0249     gamma_old = gamma_xh;
0250     
0251     itr_history = [itr_history; idelta delta flag];
0252     
0253     <span class="comment">% update support</span>
0254     <a href="../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>;
0255 
0256     pk_old = pk+delta*dk;  
0257     pk_old([gamma_xh; idelta]) = sign(pk_old([gamma_xh; idelta])).*W([gamma_xh; idelta]);
0258     
0259     <span class="comment">% update delx</span>
0260     z_x = -sign(pk_old);
0261     rhs = u;
0262     update_mode = <span class="string">'update'</span>;
0263     <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0264     
0265     <span class="comment">%     AtAgx = (A(:,gamma_xh)'*A(:,gamma_xh));</span>
0266     <span class="comment">%     delx2 = AtAgx\rhs(gamma_xh); % -AtAgx\(dW(gamma_xh).*z_x);</span>
0267     <span class="comment">%     figure(112); plot([delx delx2]);</span>
0268     <span class="comment">%     if norm(delx-delx2) &gt; 1e-5</span>
0269     <span class="comment">%         stp = 1;</span>
0270     <span class="comment">%     end</span>
0271      
0272     <span class="comment">% Check convergence criterion (this can be useful)...</span>
0273     <span class="keyword">if</span> early_terminate
0274         <span class="keyword">if</span> length(gamma_xh) &lt; M/2
0275             xhat = zeros(N,1);
0276             <span class="comment">% xhat(gamma_xh) = AtAgx\(A(:,gamma_xh)'*y);</span>
0277             <span class="keyword">switch</span> delx_mode
0278                 <span class="keyword">case</span> <span class="string">'mil'</span>
0279                     xhat(gamma_xh) = iAtA*(A(:,gamma_xh)'*y);
0280                 <span class="keyword">case</span> {<span class="string">'qr'</span>,<span class="string">'chol'</span>}
0281                     xhat(gamma_xh) = R\(R'\(A(:,gamma_xh)'*y));
0282             <span class="keyword">end</span>
0283             <span class="keyword">if</span> norm(y-A*xhat) &lt; tau
0284                 xk_1 = xhat;
0285                 <span class="keyword">break</span>;
0286             <span class="keyword">end</span>
0287         <span class="keyword">end</span>
0288     <span class="keyword">end</span>
0289      
0290     <span class="keyword">if</span> err_record        
0291         error_table = [error_table; epsilon err_fun(xk_1) length(gamma_xh)];
0292     <span class="keyword">end</span>
0293     
0294     <span class="comment">%% debug</span>
0295     constr_violation = nnz((abs(pk_old(gamma_xc))-W(gamma_xc))&gt;1e-10);
0296     sign_violation = nnz((sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh)))&gt;1);
0297     <span class="keyword">if</span> constr_violation &amp;&amp; nonneg == 0
0298         chk = gamma_xc((abs(pk_old(gamma_xc))-W(gamma_xc))&gt;1e-10);
0299         stp = 1;
0300         fprintf(<span class="string">'problem... with constraint violation -- %s \n'</span>, mfilename);
0301         fprintf(<span class="string">'Refactorize the matrix... recompute delx (consider using qr delx_update instead of mil) \n'</span>);
0302         <span class="comment">% some times it comes here due to bad conditioning of AtAgx.</span>
0303         update_mode = <span class="string">'init0'</span>;
0304         <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0305     <span class="keyword">end</span>
0306     <span class="keyword">if</span> sign_violation&gt;=1 &amp;&amp; nonneg == 0
0307         chk = gamma_xh(sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh))&gt;1);
0308         stp = 1;
0309         fprintf(<span class="string">'problem... sign mismatch -- %s \n'</span>,mfilename);
0310         fprintf(<span class="string">'Refactorize the matrix... recompute delx (consider using qr delx_update instead of mil)\n'</span>);
0311         update_mode = <span class="string">'init0'</span>;
0312         <a href="../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0313     <span class="keyword">end</span>
0314     
0315     <span class="comment">%% print and plot</span>
0316     <span class="keyword">if</span> mod(iter-1,verbose) == 0 &amp;&amp; verbose
0317         fprintf([<span class="string">'iter = %d, delta = %3.4g, idelta = %d, flag = %d.\n'</span>], iter, delta, idelta, flag);
0318     <span class="keyword">end</span>
0319     <span class="keyword">if</span> mod(iter-1,plots) == 0 &amp;&amp; plots
0320         fig1 = figure(1234);
0321         subplot(2,1,1)
0322         hold off
0323         plot(pk,<span class="string">'.r'</span>, <span class="string">'MarkerSize'</span>,14);
0324         hold on;
0325         plot(pk_old, <span class="string">'LineWidth'</span>,1);
0326         
0327         <span class="keyword">if</span> flag == 1
0328             plot(idelta, pk_old(idelta),<span class="string">'or'</span>,<span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0329             text(idelta, pk_old(idelta)*1.1, [<span class="string">'Incoming \gamma = '</span>,num2str(idelta)],<span class="string">'FontSize'</span>,14);
0330         <span class="keyword">else</span>
0331             plot(idelta, pk_old(idelta),<span class="string">'ok'</span>,<span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0332             text(idelta, pk_old(idelta)*1.1, [<span class="string">'Outgoing \gamma = '</span>,num2str(idelta)],<span class="string">'FontSize'</span>,14);
0333         <span class="keyword">end</span>
0334         set(gca,<span class="string">'FontSize'</span>,16, <span class="string">'XLim'</span>,[1 N] );
0335         title(sprintf(<span class="string">'BPDN shrinkage constraints: N = %d, M = %d'</span>, N, M));
0336         plot(1:N, W,<span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0337         plot(1:N, -W, <span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12); 
0338         
0339         figure(fig1);
0340         subplot(2,1,2)
0341         hold off
0342         plot(x_k,<span class="string">'.r'</span>,<span class="string">'MarkerSize'</span>,14); hold on;
0343         plot(xk_1,<span class="string">'LineWidth'</span>,1);
0344         <span class="keyword">if</span> flag == 0
0345             plot(idelta, 0,<span class="string">'ok'</span>, <span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0346         <span class="keyword">else</span>
0347             plot(idelta, 0,<span class="string">'or'</span>, <span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0348         <span class="keyword">end</span>
0349         set(gca,<span class="string">'FontSize'</span>,16,<span class="string">'XLim'</span>,[1 N]);
0350         title([<span class="string">'Solution estimate at \epsilon = '</span>,num2str(epsilon), <span class="string">', iter. = '</span>, num2str(iter)]);
0351         
0352         <span class="keyword">if</span> iter == 1 &amp;&amp; verbose
0353             disp(<span class="string">'  '</span>);
0354             disp(<span class="string">'Every frame in the figure corresponds to a critical point on the homotopy path.'</span>)
0355             disp(<span class="string">'Circle represents an incoming element, star represents an outgoing element.'</span>);
0356             disp(<span class="string">' '</span>);
0357             disp(<span class="string">'Put pause somewhere in the code to see this. '</span>);
0358             disp(<span class="string">'For now press some key to continue...'</span>);
0359             pause
0360         <span class="keyword">end</span>
0361     <span class="keyword">end</span>
0362     
0363 <span class="keyword">end</span>
0364 
0365 <span class="comment">%% debiasing step?</span>
0366 <span class="keyword">if</span> debias
0367     x_out = zeros(N,1);
0368     <span class="keyword">switch</span> delx_mode
0369         <span class="keyword">case</span> <span class="string">'mil'</span>
0370             x_out(gamma_xh) = iAtA*(A(:,gamma_xh)'*y);
0371         <span class="keyword">case</span> {<span class="string">'qr'</span>,<span class="string">'chol'</span>}
0372             x_out(gamma_xh) = R\(R'\(A(:,gamma_xh)'*y));
0373     <span class="keyword">end</span>
0374 <span class="keyword">else</span>
0375     x_out = xk_1;
0376 <span class="keyword">end</span>
0377 
0378 <span class="comment">%</span>
0379 <span class="keyword">if</span> err_record
0380     error_table = [error_table; epsilon err_fun(x_out) length(gamma_xh)];
0381 <span class="keyword">end</span>
0382 total_iter = iter;
0383 total_time = cputime-t0;
0384 
0385 <span class="comment">%% Output the results</span>
0386 out = opts;
0387 out.x_out = x_out;
0388 out.gamma = gamma_xh; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0389 out.iter = total_iter;
0390 out.time = total_time;
0391 out.error_table = error_table;
0392 out.pk = pk_old;
0393 <span class="keyword">switch</span> delx_mode
0394     <span class="keyword">case</span> <span class="string">'mil'</span>
0395         out.iAtA = iAtA;
0396     <span class="keyword">case</span> <span class="string">'qr'</span>
0397         out.Q = Q;
0398         out.R = R;
0399     <span class="keyword">case</span> <span class="string">'chol'</span>
0400         out.R = R;
0401     <span class="keyword">case</span> <span class="string">'qrM'</span>
0402         out.Q0 = Q0;
0403         out.R0 = R0;
0404 <span class="keyword">end</span>
0405</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Simulation_DynamicSeq_REC</title>
  <meta name="keywords" content="Simulation_DynamicSeq_REC">
  <meta name="description" content="Simulation to test the performance of REC">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html l1decoding -->
<h1>Simulation_DynamicSeq_REC
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Simulation to test the performance of REC</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Simulation to test the performance of REC</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../L1_homotopy_v2.0/Pursuits_Homotopy/BPDN_homotopy_function.html" class="code" title="function out = BPDN_homotopy_function(A, y, in)">BPDN_homotopy_function</a>	BPDN_homotopy_function.m</li><li><a href="DynamicSeq_REC_function.html" class="code" title="function [cp_h gamma_h iter th] = REC_homotopy_function(P, s, iPgP, cp_old, gamma_h, gamma_n, pk, tau, M, m_u, maxiter);">DynamicSeq_REC_function</a>	DynamicSeq_REC_function.m</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Simulation to test the performance of REC</span>
0002 
0003 clear
0004 close all
0005 
0006 <span class="comment">% % load fixed random states</span>
0007 <span class="comment">% load RandomStates</span>
0008 <span class="comment">% rand('state', s_rand);</span>
0009 <span class="comment">% randn('state', s_randn);</span>
0010 
0011 sim_runs = 10;
0012 additional_elements = 100;
0013 
0014 <span class="comment">% No. of new measurements added at a time</span>
0015 m_u = 10;
0016 inner_iterations = additional_elements/m_u;
0017 
0018 stack_time = zeros(sim_runs*inner_iterations,2);
0019 stack_iter = zeros(sim_runs*inner_iterations,5);
0020 
0021 
0022 <span class="keyword">for</span> outer_iter = 1:sim_runs
0023     <span class="comment">% % source length</span>
0024     N = 150;
0025     <span class="comment">% codeword length</span>
0026     M = 2*N;
0027     M_st = M;
0028     
0029     <span class="comment">% number of perturbations</span>
0030     max_sparse_errors = .2; <span class="comment">% e.g., 20% of M</span>
0031     T = round(max_sparse_errors*M_st);
0032     
0033     T = round(N/2.5);
0034     
0035     <span class="comment">% coding matrix</span>
0036     Orth_mat = randn(M,M);
0037     A = randn(M,N)/sqrt(N);
0038     A = orth(A);
0039 
0040     <span class="comment">% Annihilating projection matrix</span>
0041     AtA = A'*A;
0042     iAtA = inv(AtA);
0043     AiAtA = A*iAtA;
0044     AiAtAAt = AiAtA*A';
0045     Q = eye(M)-AiAtAAt;
0046 
0047     <span class="comment">% source word</span>
0048     x = (randn(N,1));
0049 
0050     <span class="comment">% channel: perturb T randomly chosen entries</span>
0051     q = randperm(M);
0052     
0053     <span class="comment">% Introduce sparse errors</span>
0054     e = zeros(M,1);
0055     <span class="comment">% e(q(1:T)) = randsrc(T,1); % Arbitrary sparse errors</span>
0056     e(q(1:T)) = -A(q(1:T),:)*x; <span class="comment">% Erasures!</span>
0057 
0058     <span class="comment">% Small noise</span>
0059     x0 = randn(N,1);
0060     Ax0 = A*x0;
0061     sigma = median(abs(Ax0))/20; <span class="comment">% control the power in small noise</span>
0062     q_y = randn(M,1)*sigma;
0063 
0064     <span class="comment">% Received codeword</span>
0065     y = A*x+e+q_y;
0066 
0067     <span class="comment">% Regularization parameter</span>
0068     tau = 0.01;<span class="comment">%*max(abs(Q*y)); % l1_ls</span>
0069 <span class="comment">%     if sigma&gt;0</span>
0070 <span class="comment">%         tau = sigma * sqrt(log(N)*2); % BPDN</span>
0071 <span class="comment">%         % tau = max(abs(Q'*q_y)); % ideal ???</span>
0072 <span class="comment">%     end</span>
0073 
0074     <span class="comment">% Data recovery</span>
0075     Qy = Q*y;
0076     [ep, gamma_e, ep_iter, t1] =  <a href="../../L1_homotopy_v2.0/Pursuits_Homotopy/BPDN_homotopy_function.html" class="code" title="function out = BPDN_homotopy_function(A, y, in)">BPDN_homotopy_function</a>(Q, Qy, tau, 4*M);
0077     <span class="comment">% xp = inv(A'*A)*A'*(y-ep);</span>
0078     xp = AiAtA'*(y-ep);
0079 
0080     tolA_h = tau*sum(abs(ep))+1/2*(norm(Q*(ep-y)))^2;
0081 
0082     <span class="keyword">for</span> inn_iter = 1:inner_iterations
0083         [outer_iter inn_iter]
0084         <span class="keyword">if</span> inn_iter &gt; 1
0085 <span class="comment">%             % Update the parameters from the previous run of inner iterations</span>
0086 <span class="comment">%             AtA = AtA_n;</span>
0087 <span class="comment">%             iAtA = iAtA_n;</span>
0088 <span class="comment">%             AiAtA = AiAtA_n;</span>
0089 <span class="comment">%             AiAtAAt = AiAtAAt_n;</span>
0090 <span class="comment">%             Q = Q_n;</span>
0091 <span class="comment">%             y = y_n;</span>
0092 <span class="comment">%             A = A_n;</span>
0093 <span class="comment">%             q_y = q_y_n;</span>
0094 <span class="comment">%             e = e_n;</span>
0095 <span class="comment">%             xp = xp_n;</span>
0096 <span class="comment">%             ep = ep_n;</span>
0097 <span class="comment">%             M = M_n;</span>
0098 <span class="comment">%             gamma_e = gamma_e_n;</span>
0099 <span class="comment">%             e_BB_mono = e_BB_mono_n;</span>
0100             <span class="comment">% Update the parameters for next run of inner iterations</span>
0101             AtA = FtF;
0102             iAtA = iFtF;
0103             AiAtA = FiFtF;
0104             AiAtAAt = FiFtFFt;
0105             Q = P;
0106             y = s;
0107             A = F;
0108             q_y = q_yw;
0109             e = c;
0110             xp = xp_h;
0111             ep = cp_h;
0112             M = M+m_u;
0113             gamma_e = gamma_h;
0114         <span class="keyword">end</span>
0115         
0116         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0117         <span class="comment">% Setup for adding m_u new observations %</span>
0118         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0119 
0120         <span class="comment">% No. of new observations</span>
0121         <span class="comment">% m_u =10;</span>
0122 
0123         b = randn(m_u,N)/sqrt(N); <span class="comment">% new rows in coding matrix</span>
0124         max_sparse_errors_new = max_sparse_errors;
0125         max_sparse_errors_new = .2;
0126         T_new = round((m_u*max_sparse_errors_new)*(rand&gt;=.5)+rand*.5); <span class="comment">% new gross/sparse errors</span>
0127         d = zeros(m_u,1);
0128         q_new = randperm(m_u);
0129         
0130         <span class="comment">% Introduce gross errors in the new elements of the codeowrd</span>
0131         <span class="comment">% d(q_new(1:T_new)) = randsrc(T_new,1); % Arbitrary sparse errors</span>
0132         d(q_new(1:T_new)) = -b(q_new(1:T_new),:)*x; <span class="comment">% Erasures!</span>
0133 
0134         <span class="comment">% small noise in the new measurements</span>
0135         q_w = randn(m_u,1)*sigma;
0136 
0137         w = b*x+d+q_w;
0138         F = [A; b];
0139         s = [y;w];
0140         c = [e; d];
0141         q_yw = [q_y; q_w];
0142 
0143 
0144         iAtAbt = iAtA*b';
0145         biAtAbt = b*iAtAbt;
0146         S_biAtAbt = inv(eye(m_u)+biAtAbt);
0147         AiAtAbt = AiAtA*b';
0148         iAtAbt_S = (iAtAbt*S_biAtAbt);
0149         AiAtAbt_S = A*iAtAbt_S;
0150 
0151         FtF = AtA+b'*b; <span class="comment">%F'*F;</span>
0152         iFtF = iAtA - iAtAbt_S*iAtAbt'; <span class="comment">% inv(FtF);</span>
0153         FiFtF = [AiAtA - AiAtAbt_S*iAtAbt'; iAtAbt'-biAtAbt*S_biAtAbt*iAtAbt']; <span class="comment">% F*iFtF;</span>
0154         FiFtFFt = [AiAtAAt - AiAtAbt_S*AiAtAbt' AiAtAbt-AiAtAbt_S*biAtAbt; AiAtAbt'-biAtAbt*AiAtAbt_S' biAtAbt-biAtAbt*S_biAtAbt*biAtAbt]; <span class="comment">%FiFtF*F';</span>
0155         P = eye(M+m_u)-FiFtFFt;
0156 
0157         dp = w-b*xp;
0158         z_d = sign(dp);
0159         cp_h = [ep; dp];
0160         gamma_n = M+find(abs(dp)&gt;2*eps);
0161         gamma_n_old = gamma_n;
0162         gamma_h = [gamma_e; gamma_n];
0163         epsilon = 0;
0164         e0 = 0;
0165 
0166         QgQ = Q(gamma_e,gamma_e);
0167         PgP = P(gamma_h,gamma_h);
0168         uQ = AiAtAbt_S(gamma_e,:);
0169         vQ = AiAtAbt(gamma_e,:);
0170         QgQ_update = QgQ + uQ*vQ';
0171         PgP_update = [[QgQ_update; P(gamma_n,gamma_e)] P(gamma_h,gamma_n)];
0172         PgP = PgP_update;
0173 
0174         iQgQ = inv(QgQ);
0175         iQgQ_update = iQgQ - (iQgQ*uQ)*(inv(eye(m_u)+vQ'*iQgQ*uQ))*(vQ'*iQgQ);
0176 
0177         P11 = QgQ_update;
0178         P12 = P(gamma_e,gamma_n);
0179         P21 = P12';
0180         P22 = P(gamma_n,gamma_n);
0181         S_P = inv(P22-P21*iQgQ_update*P12);
0182         iP11_P12 = iQgQ_update*P12;
0183         iPgP_update = [iQgQ_update+(iP11_P12*S_P)*iP11_P12' -iP11_P12*S_P; -S_P*iP11_P12' S_P];
0184         iPgP = iPgP_update;
0185 
0186         pk_old = P*(cp_h-s);
0187         [cp_h gamma_h cp_h_iter th] = <a href="DynamicSeq_REC_function.html" class="code" title="function [cp_h gamma_h iter th] = REC_homotopy_function(P, s, iPgP, cp_old, gamma_h, gamma_n, pk, tau, M, m_u, maxiter);">DynamicSeq_REC_function</a>(P, s, iPgP, cp_h, gamma_h, gamma_n, pk_old, tau, M, m_u, 4*M);
0188         xp_h = FiFtF'*(s-cp_h);
0189 
0190         <span class="comment">% % Check the solution using homotopy from scratch.</span>
0191         [cp2, gamma_c2, cp2_iter, t2] = <a href="../../L1_homotopy_v2.0/Pursuits_Homotopy/BPDN_homotopy_function.html" class="code" title="function out = BPDN_homotopy_function(A, y, in)">BPDN_homotopy_function</a>(P, P*s, tau, 4*M);
0192         
0193         stack_time((outer_iter-1)*inner_iterations+inn_iter,:) = [t2 th];
0194         stack_iter((outer_iter-1)*inner_iterations+inn_iter,:) = [cp2_iter cp_h_iter T_new norm(x-xp_h)/norm(x) norm(cp_h-cp2)];
0195 <span class="comment">%         iter_count = (outer_iter-1)*inner_iterations+inn_iter</span>
0196     <span class="keyword">end</span>
0197 <span class="keyword">end</span>
0198 
0199 [<span class="string">'BPDN      REC'</span>]
0200 Average_time = mean(stack_time,1)
0201 Average_iterations = mean(stack_iter(:,1:2))</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
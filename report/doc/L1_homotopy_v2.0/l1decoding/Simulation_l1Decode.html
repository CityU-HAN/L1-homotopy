<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Simulation_l1Decode</title>
  <meta name="keywords" content="Simulation_l1Decode">
  <meta name="description" content="Test out l1 decoding with homotopy update scheme">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html l1decoding -->
<h1>Simulation_l1Decode
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Test out l1 decoding with homotopy update scheme</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Test out l1 decoding with homotopy update scheme

 Created by Salman Asif @ Georgia Tech</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Test out l1 decoding with homotopy update scheme</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Created by Salman Asif @ Georgia Tech</span>
0004 
0005 close all
0006 clear
0007 
0008 randn(<span class="string">'state'</span>,0);
0009 rand(<span class="string">'state'</span>,0);
0010 
0011 <span class="comment">% source length</span>
0012 N = 128;
0013 
0014 <span class="comment">% Number of errors introduced at random</span>
0015 T_list = [10 20 30 40 50];
0016 P_list = [1 2 4 8];
0017 
0018 Stack_meas = [];
0019 Stack_iter = [];
0020 
0021 no_exp = 20; <span class="comment">% number of simulations</span>
0022 
0023 <span class="keyword">for</span> P = P_list
0024     <span class="comment">% Number of new elements added at a time</span>
0025     No_new_element = P;
0026     
0027     table_iter = zeros(no_exp, length(T_list));
0028     table_error = zeros(no_exp, length(T_list));
0029     
0030     fprintf(<span class="string">'N = %d, P = %d, sim_count = %d...\n'</span>,N,No_new_element,no_exp);
0031     
0032     <span class="keyword">for</span> iT = 1:length(T_list)
0033         <span class="keyword">for</span> inn_iter = 1:no_exp
0034             
0035             <span class="comment">% Maximum allowed length of message</span>
0036             M = 20*N;
0037             
0038             <span class="comment">% number of perturbations</span>
0039             T = T_list(iT); <span class="comment">%round(.3*N);</span>
0040             
0041             <span class="comment">% coding matrix</span>
0042             Orth_mat = randn(M,M);
0043             <span class="comment">% Orth_mat = randsrc(M,M);</span>
0044             <span class="comment">% [Orth_mat R_mat] = qr(Orth_mat,0);</span>
0045             G_mat = Orth_mat(:,1:N);
0046             
0047             <span class="comment">% Homotopy setup</span>
0048             m_st = N;   <span class="comment">% number of measurements to start with</span>
0049             A = G_mat(1:m_st,:);
0050             B_stack = G_mat(m_st+1:<span class="keyword">end</span>,:);
0051             
0052             <span class="comment">% source word</span>
0053             x = randn(N,1);
0054             
0055             <span class="comment">% channel: perturb T randomly chosen entries</span>
0056             q = randperm(m_st-1);
0057             c = zeros(m_st,1);
0058             c(q(1:T)) = randn(T,1);
0059             
0060             y = A*x-c;
0061             
0062             <span class="comment">% Introduce sparse errors</span>
0063             err_loc = (rand(M-N,1)&gt;1);
0064             err_new = err_loc.*randn(M-N,1);
0065             w_vec = B_stack*x+err_new;
0066             
0067             <span class="comment">% initial estimate of x</span>
0068             <span class="comment">% l1_min or direct inversion depending on n_st</span>
0069             iA = inv(A);
0070             x0 = iA*y;
0071             e0 = A*x0-y;
0072             lambda_0 = zeros(m_st,1);
0073             
0074             A_old = A;
0075             y_old = y;
0076             x_old = x0;
0077             c_old = e0;
0078             lambda_old = lambda_0;
0079             
0080             m_u = No_new_element;
0081             gamma_old = []; <span class="comment">%find(A*x0-y) or find(abs(lambda_0)==1);</span>
0082             m_old = m_st;
0083             all_done = 0;
0084             cond_list = [];
0085             cond_iter = 1;
0086             gamma_kc_new = [1:N]';
0087             iGg_new = iA';
0088             
0089             iter_total = 0;
0090             iter_in = 0;
0091             <span class="keyword">for</span> iter_mat = 1:m_u:M-m_st
0092                 m_new = m_old + m_u;
0093                 x_k = x_old;
0094                 lambda_k = lambda_old;
0095                 gamma_k = gamma_old;
0096                 <span class="comment">%     gamma_kc = gamma_kc_old;</span>
0097                 
0098                 B = B_stack(iter_mat:iter_mat+m_u-1,:);
0099                 G = [A_old' B'];
0100                 w = w_vec(iter_mat:iter_mat+m_u-1);
0101                 q = [y_old; w];
0102                 
0103                 c_old = [c_old; B*x_k-w];
0104                 
0105                 <span class="keyword">if</span> abs(abs(B*x_k-w))&gt;=10*eps
0106                     nu = sign(B*x_k-w);
0107                     i_nu = [m_new-m_u+1:m_new]';
0108                     gammak_new = [gamma_k; i_nu];
0109                 <span class="keyword">else</span>
0110                     stp = 1;
0111                 <span class="keyword">end</span>
0112                 
0113                 lambda_old = [lambda_k; nu]; <span class="comment">% xi_old</span>
0114                 
0115                 done = 0;
0116                 epsilon_old = 0;
0117                 iter_in = 0;
0118                 <span class="keyword">while</span> ~done
0119                     iter_in = iter_in+1;
0120                     <span class="comment">% [iter_mat iter_in]</span>
0121                     
0122                     gamma_k = gammak_new;
0123                     x_k = x_old;
0124                     c_k = c_old;
0125                     lambda_k = lambda_old; <span class="comment">% xi_k</span>
0126                     
0127                     gamma_kc = gamma_kc_new;
0128                     
0129                     <span class="comment">% INVERSE UPDATE</span>
0130                     <span class="comment">%iGg = inv(G(:,gamma_kc));</span>
0131                     iGg = iGg_new;
0132                     del_lambda = -iGg*(G(:,i_nu)*sign(lambda_k(i_nu))); <span class="comment">% del_xi</span>
0133                     
0134                     del_lambda_vec = zeros(m_new,1); <span class="comment">% del_xi_vec</span>
0135                     del_lambda_vec(gamma_kc) = del_lambda;
0136                     
0137                     <span class="comment">% find incoming elements in support of error vector</span>
0138                     constr1 = (1-lambda_k(gamma_kc))./del_lambda_vec(gamma_kc);
0139                     constr1_pos = constr1(constr1&gt;2*eps);
0140                     delta1 = min(constr1_pos);
0141                     idelta1 = gamma_kc(find(constr1==delta1));
0142                     
0143                     constr2 = -(1+lambda_k(gamma_kc))./del_lambda_vec(gamma_kc);
0144                     constr2_pos = constr2(constr2&gt;2*eps);
0145                     delta2 = min(constr2_pos);
0146                     idelta2 = gamma_kc(find(constr2==delta2));
0147                     
0148                     <span class="keyword">if</span> delta1&gt;delta2
0149                         delta = delta2;
0150                         idelta = idelta2;
0151                     <span class="keyword">else</span>
0152                         delta = delta1;
0153                         idelta = idelta1;
0154                     <span class="keyword">end</span>
0155                     
0156                     <span class="keyword">if</span> epsilon_old+delta &lt;=1
0157                         lambdak_1 = lambda_k + delta*del_lambda_vec;
0158                         lambdak_1(idelta) = sign(lambdak_1(idelta));
0159                         gammak_temp = [gamma_k; idelta];
0160                         
0161                         <span class="comment">% outgoing element from the support of</span>
0162                         uz_vec = zeros(N,1);
0163                         idelta_gamma_kc = find(idelta==gamma_kc);
0164                         uz_vec(idelta_gamma_kc) = sign(lambdak_1(idelta));
0165                         delx = iGg'*uz_vec;
0166                         
0167                         delc= G'*delx;
0168                         constr3 = -(c_k(gamma_k)./delc(gamma_k));
0169                         constr3_pos = constr3(constr3&gt;2*eps);
0170                         delta3 = min(constr3_pos);
0171                         idelta3 = gamma_k(find(constr3==delta3));
0172                         xk_1 = x_k + delta3*delx;
0173                         ck_1 = c_k + delta3*delc;
0174                         ck_1(idelta3) = 0;
0175                         
0176                         out_lambda = idelta3;
0177                         
0178                         <span class="keyword">if</span> [m_new-N~=length(find(abs(G'*xk_1-q)&gt;=1e5*eps))]
0179                             gamma_final = setdiff(gammak_temp,find(abs(G'*xk_1-q)&lt;=100*eps));
0180                             x_old = xk_1;
0181                             c_old = ck_1;
0182                             lambda_old = lambdak_1;
0183                             stp = 1; <span class="comment">%% WHAT TO DO NOW ???</span>
0184                             all_done = 1;
0185                             iter_total = iter_total+iter_in; 
0186                             <span class="keyword">break</span>; <span class="keyword">break</span>; <span class="keyword">break</span>;
0187                         <span class="keyword">end</span> 
0188                         gammak_new = setdiff(gammak_temp,idelta3);
0189                         gamma_kc_new = gamma_kc;
0190                         gamma_kc_new(idelta_gamma_kc) = idelta3;
0191                         
0192                         <span class="comment">% UPDATE INVERSE OF G(gamma_kc)</span>
0193                         <span class="comment">% Gg = Gg + (g_new - g_old)'*1_idelta_gamma_kc;</span>
0194                         diff_G_in_out = G(:,idelta3)-G(:,idelta);
0195                         iGg_new = iGg - (iGg*diff_G_in_out/(1+iGg(idelta_gamma_kc,:)*diff_G_in_out))*(iGg(idelta_gamma_kc,:));
0196                         
0197                         x_old = xk_1;
0198                         c_old = ck_1;
0199                         lambda_old = lambdak_1;
0200                         gamma_old = gammak_new;
0201                         
0202                         <span class="keyword">if</span> length(find(idelta3 == i_nu))
0203                             lambda_old(idelta3) = (epsilon_old+delta)*lambdak_1(idelta3);
0204                             i_nu = setdiff(i_nu,idelta3);
0205                             <span class="keyword">if</span> isempty(i_nu)
0206                                 epsilon = 1;
0207                             <span class="keyword">else</span>
0208                                 epsilon = delta + epsilon_old;
0209                             <span class="keyword">end</span>
0210                         <span class="keyword">else</span>
0211                             epsilon = delta + epsilon_old;
0212                         <span class="keyword">end</span>
0213                         
0214                         <span class="keyword">if</span> epsilon &gt;=1
0215                             done = 1;
0216                             
0217                             A_old = G';
0218                             y_old = q;
0219                             m_old = m_new;
0220                             iter_total = iter_total+iter_in;
0221                         <span class="keyword">end</span>
0222                         epsilon_old = epsilon;
0223                         
0224                     <span class="keyword">else</span>
0225                         new_delta = 1-epsilon_old;
0226                         lambdak_1 = lambda_k + new_delta*del_lambda_vec;
0227                         lambda_old = [lambdak_1];
0228                         gamma_old = gammak_new;
0229                         
0230                         iter_total = iter_total+iter_in;
0231                         done = 1;
0232                         
0233                         A_old = G';
0234                         y_old = q;
0235                         m_old = m_new;
0236                     <span class="keyword">end</span>
0237                 <span class="keyword">end</span>
0238                 <span class="comment">% Current</span>
0239                 <span class="comment">% disp(['No. of errors = ',num2str(T_list(iT)), ', Simulation run = ', num2str(inn_iter),', Homotopy iterations = ', num2str(iter_total), ', No. of measurements = ',num2str(iter_mat+m_u-1+m_st),', Error in recovery = ',num2str(norm(x-xk_1))]);</span>
0240                 
0241                 <span class="keyword">if</span> all_done == 1
0242                     <span class="keyword">break</span>;
0243                 <span class="keyword">end</span>
0244             <span class="keyword">end</span>
0245             <span class="comment">% Total number of homotopy iterations.</span>
0246             table_iterT(inn_iter,iT) = iter_total;
0247             <span class="comment">% Total number of measurements required for perfect recovery!</span>
0248             table_meas(inn_iter,iT) = iter_mat+m_u-1+m_st;
0249         <span class="keyword">end</span>
0250     <span class="keyword">end</span>
0251     <span class="comment">% With few measurements smaller number of steps taken to update per</span>
0252     <span class="comment">% measuremnt and as we approach final solution number of steps per</span>
0253     <span class="comment">% measurement increase slightly.</span>
0254     disp(<span class="string">'Final results'</span>);
0255     Error_count = [T_list] <span class="comment">% Total number of sparse errors</span>
0256     Total_measurements = mean(table_meas,1) <span class="comment">% Total number of measurements required for perfect recovery!</span>
0257     Total_iterations = mean(table_iterT,1)  <span class="comment">% Total number of homotopy iterations.</span>
0258     Average_iterations = Total_iterations./(Total_measurements-N) <span class="comment">% Avg homotopy iterations per new measurement</span>
0259     
0260     Stack_meas = [Stack_meas; Total_measurements];
0261     Stack_iter = [Stack_iter; Total_iterations];    
0262 <span class="keyword">end</span>
0263 
0264 <span class="comment">%%</span>
0265 plot_results = 1;
0266 <span class="keyword">if</span> plot_results
0267 exp_name = <span class="string">'l1decoding_N64_Exp20'</span>;
0268 exp_name = <span class="string">'l1decoding_N128_Exp20'</span>;
0269 
0270 load(exp_name);
0271 
0272 addpath ../
0273 addpath ../utils/utils_fig 
0274 
0275 <span class="comment">% figure setup</span>
0276 marker = {<span class="string">'bx'</span>,<span class="string">'r+'</span>,<span class="string">'k*'</span>,<span class="string">'gd'</span>};
0277 linewidth = 1.5;
0278 
0279 
0280 axis_prop = {};
0281 axis_prop{1,4} = <span class="string">'FontSize'</span>; axis_prop{2,4} = 14;
0282 axis_prop{1,5} = <span class="string">'FontWeight'</span>; axis_prop{2,5} = <span class="string">'normal'</span>;
0283 axis_prop{1,8} = <span class="string">'XGrid'</span>; axis_prop{2,8} = <span class="string">'on'</span>;
0284 axis_prop{1,9} = <span class="string">'GridLineStyle'</span>; axis_prop{2,9} = <span class="string">'--'</span>;
0285 
0286 ydata = Stack_iter./(Stack_meas-N); 
0287 figure(1)
0288 clf; hold on;
0289 set(gca,<span class="string">'FontSize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>);
0290 plot(T_list, ydata(1,:),<span class="string">'-bx'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0291 plot(T_list, ydata(2,:),<span class="string">'-.r+'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0292 plot(T_list, ydata(3,:),<span class="string">':k*'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0293 plot(T_list, ydata(4,:),<span class="string">'--md'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0294 xlabel(<span class="string">'Number of errors'</span>);
0295 ylabel(<span class="string">'Number of homotopy iterations'</span>);
0296 <span class="comment">% title('Average number of homotopy per measurement');</span>
0297 legend(<span class="string">'P=1'</span>,<span class="string">'P=2'</span>,<span class="string">'P=4'</span>,<span class="string">'P=8'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
0298 axis tight;
0299 
0300 img_name = sprintf(<span class="string">'%s-AvgIter'</span>,exp_name);
0301 set(gcf, <span class="string">'Color'</span>, <span class="string">'w'</span>);
0302 set(gcf,<span class="string">'Position'</span>,[300 0 500 600]);
0303 
0304 eval(sprintf(<span class="string">'export_fig %s.png'</span>,img_name));
0305 eval(sprintf(<span class="string">'export_fig %s.pdf'</span>,img_name));
0306 
0307 ydata = Stack_iter; 
0308 figure(2)
0309 clf; hold on;
0310 set(gca,<span class="string">'FontSize'</span>,14,<span class="string">'FontWeight'</span>,<span class="string">'normal'</span>);
0311 plot(T_list, ydata(1,:),<span class="string">'-bx'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0312 plot(T_list, ydata(2,:),<span class="string">'-.r+'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0313 plot(T_list, ydata(3,:),<span class="string">':k*'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0314 plot(T_list, ydata(4,:),<span class="string">'--md'</span>, <span class="string">'LineWidth'</span>,1.5,<span class="string">'MarkerSize'</span>,10);
0315 xlabel(<span class="string">'Number of errors'</span>);
0316 ylabel(<span class="string">'Number of homotopy iterations'</span>);
0317 <span class="comment">% title('Total number of homotopy iteration');</span>
0318 legend(<span class="string">'P=1'</span>,<span class="string">'P=2'</span>,<span class="string">'P=4'</span>,<span class="string">'P=8'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>);
0319 axis tight;
0320 
0321 img_name = sprintf(<span class="string">'%s-TotalIter'</span>,exp_name);
0322 set(gcf, <span class="string">'Color'</span>, <span class="string">'w'</span>);
0323 set(gcf,<span class="string">'Position'</span>,[300 0 500 600]);
0324 
0325 eval(sprintf(<span class="string">'export_fig %s.png'</span>,img_name));
0326 eval(sprintf(<span class="string">'export_fig %s.pdf'</span>,img_name));
0327 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of NESTA_adpW</title>
  <meta name="keywords" content="NESTA_adpW">
  <meta name="description" content="[xk,niter,residuals,outputData] =NESTA(A,At,b,muf,delta,opts)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html solvers -->
<h1>NESTA_adpW
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>[xk,niter,residuals,outputData] =NESTA(A,At,b,muf,delta,opts)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [xk,niter,residuals,outputData,opts] =NESTA_adpW(A,At,b,muf,delta,opts) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> [xk,niter,residuals,outputData] =NESTA(A,At,b,muf,delta,opts)

 Solves a L1 minimization problem under a quadratic constraint using the
 Nesterov algorithm, with continuation:

     min_x || U x ||_1 s.t. ||y - Ax||_2 &lt;= delta
 
 Continuation is performed by sequentially applying Nesterov's algorithm
 with a decreasing sequence of values of  mu0 &gt;= mu &gt;= muf

 The primal prox-function is also adapted by accounting for a first guess
 xplug that also tends towards x_muf 

 The observation matrix A is a projector

 Inputs:   A and At - measurement matrix and adjoint (either a matrix, in which
               case At is unused, or function handles).  m x n dimensions.
           b   - Observed data, a m x 1 array
           muf - The desired value of mu at the last continuation step.
               A smaller mu leads to higher accuracy.
           delta - l2 error bound.  This enforces how close the variable
               must fit the observations b, i.e. || y - Ax ||_2 &lt;= delta
               If delta = 0, enforces y = Ax
               Common heuristic: delta = sqrt(m + 2*sqrt(2*m))*sigma;
               where sigma=std(noise).
           opts -
               This is a structure that contains additional options,
               some of which are optional.
               The fieldnames are case insensitive.  Below
               are the possible fieldnames:
               
               opts.xplug - the first guess for the primal prox-function, and
                 also the initial point for xk.  By default, xplug = At(b)
               opts.U and opts.Ut - Analysis/Synthesis operators
                 (either matrices of function handles).
               opts.normU - if opts.U is provided, this should be norm(U)
                   otherwise it will have to be calculated (potentially
                   expensive)
               opts.MaxIntIter - number of continuation steps.
                 default is 5
               opts.maxiter - max number of iterations in an inner loop.
                 default is 10,000
               opts.TolVar - tolerance for the stopping criteria
               opts.stopTest - which stopping criteria to apply
                   opts.stopTest == 1 : stop when the relative
                       change in the objective function is less than
                       TolVar
                   opts.stopTest == 2 : stop with the l_infinity norm
                       of difference in the xk variable is less
                       than TolVar
               opts.TypeMin - if this is 'L1' (default), then
                   minimizes a smoothed version of the l_1 norm.
                   If this is 'tv', then minimizes a smoothed
                   version of the total-variation norm.
                   The string is case insensitive.
               opts.Verbose - if this is 0 or false, then very
                   little output is displayed.  If this is 1 or true,
                   then output every iteration is displayed.
                   If this is a number p greater than 1, then
                   output is displayed every pth iteration.
               opts.fid - if this is 1 (default), the display is
                   the usual Matlab screen.  If this is the file-id
                   of a file opened with fopen, then the display
                   will be redirected to this file.
               opts.errFcn - if this is a function handle,
                   then the program will evaluate opts.errFcn(xk)
                   at every iteration and display the result.
                   ex.  opts.errFcn = @(x) norm( x - x_true )
               opts.outFcn - if this is a function handle, 
                   then then program will evaluate opts.outFcn(xk)
                   at every iteration and save the results in outputData.
                   If the result is a vector (as opposed to a scalar),
                   it should be a row vector and not a column vector.
                   ex. opts.outFcn = @(x) [norm( x - xtrue, 'inf' ),...
                                           norm( x - xtrue) / norm(xtrue)]
               opts.AAtinv - this is an experimental new option.  AAtinv
                   is the inverse of AA^*.  This allows the use of a 
                   matrix A which is not a projection, but only
                   for the noiseless (i.e. delta = 0) case.
               opts.USV - another experimental option.  This supercedes
                   the AAtinv option, so it is recommended that you
                   do not define AAtinv.  This allows the use of a matrix
                   A which is not a projection, and works for the
                   noisy ( i.e. delta &gt; 0 ) case.
                   opts.USV should contain three fields: 
                   opts.USV.U  is the U from [U,S,V] = svd(A)
                   likewise, opts.USV.S and opts.USV.V are S and V
                   from svd(A).  S may be a matrix or a vector.

  Outputs:
           xk  - estimate of the solution x
           niter - number of iterations
           residuals - first column is the residual at every step,
               second column is the value of f_mu at every step
           outputData - a matrix, where each row r is the output
               from opts.outFcn, if supplied.
           opts - the structure containing the options that were used    

 Written by: Jerome Bobin, Caltech
 Email: bobin@acm.caltech.edu
 Created: February 2009
 Modified (version 1.0): May 2009, Jerome Bobin and Stephen Becker, Caltech
 Modified (version 1.1): Nov 2009, Stephen Becker, Caltech

 NESTA Version 1.1
   See also Core_Nesterov</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="Core_Nesterov_adpW.html" class="code" title="function [xk,niter,residuals,outputData,opts] = Core_Nesterov(A,At,b,mu,delta,opts)">Core_Nesterov_adpW</a>	[xk,niter,residuals,outputData,opts] =Core_Nesterov(A,At,b,mu,delta,opts)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function printf(varargin), fprintf(fid,varargin{:}); end</a></li><li><a href="#_sub2" class="code">function [var,userSet] = setOpts(field,default,mn,mx)</a></li><li><a href="#_sub3" class="code">function th=ValMUTv(x)</a></li><li><a href="#_sub4" class="code">function [e,cnt] = my_normest(S,St,n,tol, maxiter)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [xk,niter,residuals,outputData,opts] =NESTA_adpW(A,At,b,muf,delta,opts)</a>
0002 <span class="comment">% [xk,niter,residuals,outputData] =NESTA(A,At,b,muf,delta,opts)</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Solves a L1 minimization problem under a quadratic constraint using the</span>
0005 <span class="comment">% Nesterov algorithm, with continuation:</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%     min_x || U x ||_1 s.t. ||y - Ax||_2 &lt;= delta</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Continuation is performed by sequentially applying Nesterov's algorithm</span>
0010 <span class="comment">% with a decreasing sequence of values of  mu0 &gt;= mu &gt;= muf</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% The primal prox-function is also adapted by accounting for a first guess</span>
0013 <span class="comment">% xplug that also tends towards x_muf</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% The observation matrix A is a projector</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Inputs:   A and At - measurement matrix and adjoint (either a matrix, in which</span>
0018 <span class="comment">%               case At is unused, or function handles).  m x n dimensions.</span>
0019 <span class="comment">%           b   - Observed data, a m x 1 array</span>
0020 <span class="comment">%           muf - The desired value of mu at the last continuation step.</span>
0021 <span class="comment">%               A smaller mu leads to higher accuracy.</span>
0022 <span class="comment">%           delta - l2 error bound.  This enforces how close the variable</span>
0023 <span class="comment">%               must fit the observations b, i.e. || y - Ax ||_2 &lt;= delta</span>
0024 <span class="comment">%               If delta = 0, enforces y = Ax</span>
0025 <span class="comment">%               Common heuristic: delta = sqrt(m + 2*sqrt(2*m))*sigma;</span>
0026 <span class="comment">%               where sigma=std(noise).</span>
0027 <span class="comment">%           opts -</span>
0028 <span class="comment">%               This is a structure that contains additional options,</span>
0029 <span class="comment">%               some of which are optional.</span>
0030 <span class="comment">%               The fieldnames are case insensitive.  Below</span>
0031 <span class="comment">%               are the possible fieldnames:</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%               opts.xplug - the first guess for the primal prox-function, and</span>
0034 <span class="comment">%                 also the initial point for xk.  By default, xplug = At(b)</span>
0035 <span class="comment">%               opts.U and opts.Ut - Analysis/Synthesis operators</span>
0036 <span class="comment">%                 (either matrices of function handles).</span>
0037 <span class="comment">%               opts.normU - if opts.U is provided, this should be norm(U)</span>
0038 <span class="comment">%                   otherwise it will have to be calculated (potentially</span>
0039 <span class="comment">%                   expensive)</span>
0040 <span class="comment">%               opts.MaxIntIter - number of continuation steps.</span>
0041 <span class="comment">%                 default is 5</span>
0042 <span class="comment">%               opts.maxiter - max number of iterations in an inner loop.</span>
0043 <span class="comment">%                 default is 10,000</span>
0044 <span class="comment">%               opts.TolVar - tolerance for the stopping criteria</span>
0045 <span class="comment">%               opts.stopTest - which stopping criteria to apply</span>
0046 <span class="comment">%                   opts.stopTest == 1 : stop when the relative</span>
0047 <span class="comment">%                       change in the objective function is less than</span>
0048 <span class="comment">%                       TolVar</span>
0049 <span class="comment">%                   opts.stopTest == 2 : stop with the l_infinity norm</span>
0050 <span class="comment">%                       of difference in the xk variable is less</span>
0051 <span class="comment">%                       than TolVar</span>
0052 <span class="comment">%               opts.TypeMin - if this is 'L1' (default), then</span>
0053 <span class="comment">%                   minimizes a smoothed version of the l_1 norm.</span>
0054 <span class="comment">%                   If this is 'tv', then minimizes a smoothed</span>
0055 <span class="comment">%                   version of the total-variation norm.</span>
0056 <span class="comment">%                   The string is case insensitive.</span>
0057 <span class="comment">%               opts.Verbose - if this is 0 or false, then very</span>
0058 <span class="comment">%                   little output is displayed.  If this is 1 or true,</span>
0059 <span class="comment">%                   then output every iteration is displayed.</span>
0060 <span class="comment">%                   If this is a number p greater than 1, then</span>
0061 <span class="comment">%                   output is displayed every pth iteration.</span>
0062 <span class="comment">%               opts.fid - if this is 1 (default), the display is</span>
0063 <span class="comment">%                   the usual Matlab screen.  If this is the file-id</span>
0064 <span class="comment">%                   of a file opened with fopen, then the display</span>
0065 <span class="comment">%                   will be redirected to this file.</span>
0066 <span class="comment">%               opts.errFcn - if this is a function handle,</span>
0067 <span class="comment">%                   then the program will evaluate opts.errFcn(xk)</span>
0068 <span class="comment">%                   at every iteration and display the result.</span>
0069 <span class="comment">%                   ex.  opts.errFcn = @(x) norm( x - x_true )</span>
0070 <span class="comment">%               opts.outFcn - if this is a function handle,</span>
0071 <span class="comment">%                   then then program will evaluate opts.outFcn(xk)</span>
0072 <span class="comment">%                   at every iteration and save the results in outputData.</span>
0073 <span class="comment">%                   If the result is a vector (as opposed to a scalar),</span>
0074 <span class="comment">%                   it should be a row vector and not a column vector.</span>
0075 <span class="comment">%                   ex. opts.outFcn = @(x) [norm( x - xtrue, 'inf' ),...</span>
0076 <span class="comment">%                                           norm( x - xtrue) / norm(xtrue)]</span>
0077 <span class="comment">%               opts.AAtinv - this is an experimental new option.  AAtinv</span>
0078 <span class="comment">%                   is the inverse of AA^*.  This allows the use of a</span>
0079 <span class="comment">%                   matrix A which is not a projection, but only</span>
0080 <span class="comment">%                   for the noiseless (i.e. delta = 0) case.</span>
0081 <span class="comment">%               opts.USV - another experimental option.  This supercedes</span>
0082 <span class="comment">%                   the AAtinv option, so it is recommended that you</span>
0083 <span class="comment">%                   do not define AAtinv.  This allows the use of a matrix</span>
0084 <span class="comment">%                   A which is not a projection, and works for the</span>
0085 <span class="comment">%                   noisy ( i.e. delta &gt; 0 ) case.</span>
0086 <span class="comment">%                   opts.USV should contain three fields:</span>
0087 <span class="comment">%                   opts.USV.U  is the U from [U,S,V] = svd(A)</span>
0088 <span class="comment">%                   likewise, opts.USV.S and opts.USV.V are S and V</span>
0089 <span class="comment">%                   from svd(A).  S may be a matrix or a vector.</span>
0090 <span class="comment">%</span>
0091 <span class="comment">%  Outputs:</span>
0092 <span class="comment">%           xk  - estimate of the solution x</span>
0093 <span class="comment">%           niter - number of iterations</span>
0094 <span class="comment">%           residuals - first column is the residual at every step,</span>
0095 <span class="comment">%               second column is the value of f_mu at every step</span>
0096 <span class="comment">%           outputData - a matrix, where each row r is the output</span>
0097 <span class="comment">%               from opts.outFcn, if supplied.</span>
0098 <span class="comment">%           opts - the structure containing the options that were used</span>
0099 <span class="comment">%</span>
0100 <span class="comment">% Written by: Jerome Bobin, Caltech</span>
0101 <span class="comment">% Email: bobin@acm.caltech.edu</span>
0102 <span class="comment">% Created: February 2009</span>
0103 <span class="comment">% Modified (version 1.0): May 2009, Jerome Bobin and Stephen Becker, Caltech</span>
0104 <span class="comment">% Modified (version 1.1): Nov 2009, Stephen Becker, Caltech</span>
0105 <span class="comment">%</span>
0106 <span class="comment">% NESTA Version 1.1</span>
0107 <span class="comment">%   See also Core_Nesterov</span>
0108 
0109 
0110 <span class="keyword">if</span> nargin &lt; 6, opts = []; <span class="keyword">end</span>
0111 <span class="keyword">if</span> isempty(opts) &amp;&amp; isnumeric(opts), opts = struct; <span class="keyword">end</span>
0112 
0113 <span class="comment">%---- Set defaults</span>
0114 fid = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'fid'</span>,1);
0115 Verbose = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'Verbose'</span>,true);
0116 <a name="_sub1" href="#_subfunctions" class="code">function printf(varargin), fprintf(fid,varargin{:}); end</a>
0117 MaxIntIter = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'MaxIntIter'</span>,5,1);
0118 TypeMin = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'TypeMin'</span>,<span class="string">'L1'</span>);
0119 TolVar = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'tolvar'</span>,1e-5);
0120 [U,U_userSet] = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'U'</span>, @(x) x );
0121 <span class="keyword">if</span> ~isa(U,<span class="string">'function_handle'</span>)
0122     Ut = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'Ut'</span>,[]);
0123 <span class="keyword">else</span>
0124     Ut = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'Ut'</span>, @(x) x );
0125 <span class="keyword">end</span>
0126 xplug = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'xplug'</span>,[]);
0127 normU = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'normU'</span>,[]);  <span class="comment">% so we can tell if it's been set</span>
0128 
0129 residuals = []; outputData = [];
0130 AAtinv = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'AAtinv'</span>,[]);
0131 USV = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'USV'</span>,[]);
0132 <span class="keyword">if</span> ~isempty(USV)
0133     <span class="keyword">if</span> isstruct(USV)
0134         Q = USV.U;  <span class="comment">% we can't use &quot;U&quot; as the variable name</span>
0135                     <span class="comment">% since &quot;U&quot; already refers to the analysis operator</span>
0136         S = USV.S;
0137         <span class="keyword">if</span> isvector(S), s = S; <span class="comment">%S = diag(s);</span>
0138         <span class="keyword">else</span> s = diag(S); <span class="keyword">end</span>
0139         <span class="comment">%V = USV.V;</span>
0140     <span class="keyword">else</span>
0141         error(<span class="string">'opts.USV must be a structure'</span>);
0142     <span class="keyword">end</span>
0143 <span class="keyword">end</span>
0144 
0145 <span class="comment">% -- We can handle non-projections IF a (fast) routine for computing</span>
0146 <span class="comment">%    the psuedo-inverse is available.</span>
0147 <span class="comment">%    We can handle a nonzero delta, but we need the full SVD</span>
0148 <span class="keyword">if</span> isempty(AAtinv) &amp;&amp; isempty(USV)
0149     <span class="comment">% Check if A is a partial isometry, i.e. if AA' = I</span>
0150     z = randn(size(b));
0151     <span class="keyword">if</span> isa(A,<span class="string">'function_handle'</span>), AAtz = A(At(z));
0152     <span class="keyword">else</span> AAtz = A*(A'*z); <span class="keyword">end</span>
0153     <span class="keyword">if</span> norm( AAtz - z )/norm(z) &gt; 1e-8
0154 <span class="comment">%        error('Measurement matrix A must be a partial isometry: AA''=I');</span>
0155     <span class="keyword">end</span>
0156 <span class="keyword">end</span>
0157 
0158 <span class="comment">% -- Find a initial guess if not already provided.</span>
0159 <span class="comment">%   Use least-squares solution: x_ref = A'*inv(A*A')*b</span>
0160 <span class="comment">% If A is a projection, the least squares solution is trivial</span>
0161 <span class="keyword">if</span> isempty(xplug) || norm(xplug) &lt; 1e-12
0162     <span class="keyword">if</span> ~isempty(USV) &amp;&amp; isempty(AAtinv)
0163         AAtinv = Q*diag( s.^(-2) )*Q';
0164     <span class="keyword">end</span>
0165     <span class="keyword">if</span> ~isempty(AAtinv)
0166         <span class="keyword">if</span> delta &gt; 0 &amp;&amp; isempty(USV)
0167             error(<span class="string">'delta must be zero for non-projections'</span>);
0168         <span class="keyword">end</span>
0169         <span class="keyword">if</span> isa(AAtinv,<span class="string">'function_handle'</span>)
0170             x_ref = AAtinv(b);
0171         <span class="keyword">else</span>
0172             x_ref = AAtinv * b;
0173         <span class="keyword">end</span>
0174     <span class="keyword">else</span>
0175         x_ref = b;
0176     <span class="keyword">end</span>
0177     
0178     <span class="keyword">if</span> isa(A,<span class="string">'function_handle'</span>)
0179         x_ref=At(x_ref);
0180     <span class="keyword">else</span>
0181         x_ref = A'*x_ref;
0182     <span class="keyword">end</span>
0183 
0184     <span class="keyword">if</span> isempty(xplug)
0185         xplug = x_ref;
0186     <span class="keyword">end</span>
0187     <span class="comment">% x_ref itself is used to calculate mu_0</span>
0188     <span class="comment">%   in the case that xplug has very small norm</span>
0189 <span class="keyword">else</span>
0190     x_ref = xplug;
0191 <span class="keyword">end</span>
0192 
0193 <span class="comment">% use x_ref, not xplug, to find mu_0</span>
0194 <span class="keyword">if</span> isa(U,<span class="string">'function_handle'</span>)
0195     Ux_ref = U(x_ref);
0196 <span class="keyword">else</span>
0197     Ux_ref = U*x_ref;
0198 <span class="keyword">end</span>
0199 <span class="keyword">switch</span> lower(TypeMin)
0200     <span class="keyword">case</span> <span class="string">'l1'</span>
0201         mu0 = 0.9*max(abs(Ux_ref));
0202     <span class="keyword">case</span> <span class="string">'tv'</span>
0203         mu0 = <a href="#_sub3" class="code" title="subfunction th=ValMUTv(x)">ValMUTv</a>(Ux_ref);
0204 <span class="keyword">end</span>
0205 
0206 <span class="comment">% -- If U was set by the user and normU not supplied, then calcuate norm(U)</span>
0207 <span class="keyword">if</span> U_userSet &amp;&amp; isempty(normU)
0208     <span class="comment">% simple case: U*U' = I or U'*U = I, in which case norm(U) = 1</span>
0209     z = randn(size(xplug));
0210     <span class="keyword">if</span> isa(U,<span class="string">'function_handle'</span>), UtUz = Ut(U(z)); <span class="keyword">else</span> UtUz = U'*(U*z); <span class="keyword">end</span>
0211     <span class="keyword">if</span> norm( UtUz - z )/norm(z) &lt; 1e-8
0212         normU = 1;
0213     <span class="keyword">else</span>
0214         z = randn(size(Ux_ref));
0215         <span class="keyword">if</span> isa(U,<span class="string">'function_handle'</span>)
0216             UUtz = U(Ut(z)); 
0217         <span class="keyword">else</span>
0218             UUtz = U*(U'*z);
0219         <span class="keyword">end</span>
0220         <span class="keyword">if</span> norm( UUtz - z )/norm(z) &lt; 1e-8
0221             normU = 1;
0222         <span class="keyword">end</span>
0223     <span class="keyword">end</span>
0224     
0225     <span class="keyword">if</span> isempty(normU)
0226         <span class="comment">% have to actually calculate the norm</span>
0227         <span class="keyword">if</span> isa(U,<span class="string">'function_handle'</span>)
0228             [normU,cnt] = <a href="#_sub4" class="code" title="subfunction [e,cnt] = my_normest(S,St,n,tol, maxiter)">my_normest</a>(U,Ut,length(xplug),1e-3,30);
0229             <span class="keyword">if</span> cnt == 30, <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Warning: norm(U) may be inaccurate\n'</span>); <span class="keyword">end</span>
0230         <span class="keyword">else</span>
0231             [mU,nU] = size(U);
0232             <span class="keyword">if</span> mU &lt; nU, UU = U*U'; <span class="keyword">else</span> UU = U'*U; <span class="keyword">end</span> 
0233             <span class="comment">% last resort is to call MATLAB's &quot;norm&quot;, which is slow</span>
0234             <span class="keyword">if</span> norm( UU - diag(diag(UU)),<span class="string">'fro'</span>) &lt; 100*eps
0235                 <span class="comment">% this means the matrix is diagonal, so norm is easy:</span>
0236                 normU = sqrt( max(abs(diag(UU))) );
0237             <span class="keyword">elseif</span> issparse(UU)
0238                 normU = sqrt( normest(UU) );
0239             <span class="keyword">else</span>
0240                 <span class="keyword">if</span> min(size(U)) &gt; 2000
0241                     <span class="comment">% norm(randn(2000)) takes about 5 seconds on my PC</span>
0242                     <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Warning: calculation of norm(U) may be slow\n'</span>);
0243                 <span class="keyword">end</span>
0244                 normU = sqrt( norm(UU) );
0245             <span class="keyword">end</span>
0246         <span class="keyword">end</span>
0247     <span class="keyword">end</span>
0248     opts.normU = normU;
0249 <span class="keyword">end</span>
0250         
0251 
0252 niter = 0;
0253 Gamma = (muf/mu0)^(1/MaxIntIter);
0254 mu = mu0;
0255 Gammat= (TolVar/0.1)^(1/MaxIntIter);
0256 TolVar = 0.1;
0257  
0258 <span class="keyword">for</span> nl=1:MaxIntIter
0259     
0260     mu = mu*Gamma;
0261     TolVar=TolVar*Gammat;    opts.TolVar = TolVar;
0262     opts.xplug = xplug;
0263     <span class="keyword">if</span> Verbose, <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'\tBeginning %s Minimization; mu = %g\n'</span>,opts.TypeMin,mu); <span class="keyword">end</span>
0264     [xk,niter_int,res,out,optsOut] = <a href="Core_Nesterov_adpW.html" class="code" title="function [xk,niter,residuals,outputData,opts] = Core_Nesterov(A,At,b,mu,delta,opts)">Core_Nesterov_adpW</a>(<span class="keyword">...</span>
0265         A,At,b,mu,delta,opts);
0266         
0267     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0268     <span class="comment">% Adaptive weights selection [sasif] %</span>
0269     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0270     gamma = find(xk);
0271     ewt_b = 2*length(b)*(norm(xk,2)/norm(xk,1))^2;
0272     W_new = ones(length(xk),1);
0273     W_new(gamma) = min([W_new(gamma) 1./abs(xk(gamma))/ewt_b],[],2);
0274     
0275     opts.U = spdiags(W_new,0,length(xk),length(xk));
0276     opts.Ut = opts.U;
0277     opts.normU = max(W_new);
0278     
0279     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0280     
0281     xplug = xk;
0282     niter = niter_int + niter;
0283     
0284     residuals = [residuals; res];
0285     outputData = [outputData; out];
0286 
0287 <span class="keyword">end</span>
0288 opts = optsOut;
0289 
0290 
0291 <span class="comment">%---- internal routine for setting defaults</span>
0292 <a name="_sub2" href="#_subfunctions" class="code">function [var,userSet] = setOpts(field,default,mn,mx)</a>
0293     var = default;
0294     <span class="comment">% has the option already been set?</span>
0295     <span class="keyword">if</span> ~isfield(opts,field) 
0296         <span class="comment">% see if there is a capitalization problem:</span>
0297         names = fieldnames(opts);
0298         <span class="keyword">for</span> i = 1:length(names)
0299             <span class="keyword">if</span> strcmpi(names{i},field)
0300                 opts.(field) = opts.(names{i});
0301                 opts = rmfield(opts,names{i});
0302                 <span class="keyword">break</span>;
0303             <span class="keyword">end</span>
0304         <span class="keyword">end</span>
0305     <span class="keyword">end</span>
0306     <span class="keyword">if</span> isfield(opts,field) &amp;&amp; ~isempty(opts.(field))
0307         var = opts.(field);  <span class="comment">% override the default</span>
0308         userSet = true;
0309     <span class="keyword">else</span>
0310         userSet = false;
0311     <span class="keyword">end</span>
0312     <span class="comment">% perform error checking, if desired</span>
0313     <span class="keyword">if</span> nargin &gt;= 3 &amp;&amp; ~isempty(mn)
0314         <span class="keyword">if</span> var &lt; mn
0315             <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Variable %s is %f, should be at least %f\n'</span>,<span class="keyword">...</span>
0316                 field,var,mn); error(<span class="string">'variable out-of-bounds'</span>);
0317         <span class="keyword">end</span>
0318     <span class="keyword">end</span>
0319     <span class="keyword">if</span> nargin &gt;= 4 &amp;&amp; ~isempty(mx)
0320         <span class="keyword">if</span> var &gt; mx
0321             <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Variable %s is %f, should be at least %f\n'</span>,<span class="keyword">...</span>
0322                 field,var,mn); error(<span class="string">'variable out-of-bounds'</span>);
0323         <span class="keyword">end</span>
0324     <span class="keyword">end</span>
0325     opts.(field) = var;
0326 <span class="keyword">end</span>
0327 
0328 
0329 
0330 
0331 <span class="comment">%---- internal routine for setting mu0 in the tv minimization case</span>
0332 <a name="_sub3" href="#_subfunctions" class="code">function th=ValMUTv(x)</a>
0333     
0334     <span class="keyword">global</span> T_frames ROW COL
0335     <span class="keyword">if</span> isempty(T_frames)
0336         T_frames = 1;
0337         N = length(x)/T_frames; n = floor(sqrt(N));
0338         ROW = n; COL = n;
0339     <span class="keyword">end</span>
0340     N = ROW*COL;
0341     Dv = spdiags(repmat([reshape([-ones(ROW-1,COL); zeros(1,COL)],N,1) <span class="keyword">...</span>
0342         reshape([zeros(1,COL); ones(ROW-1,COL)],N,1)], T_frames,1), [0 1], T_frames*N, T_frames*N);
0343     Dh = spdiags(repmat([reshape([-ones(ROW,COL-1) zeros(ROW,1)],N,1) <span class="keyword">...</span>
0344         reshape([zeros(ROW,1) ones(ROW,COL-1)],N,1)],T_frames,1), [0 ROW], T_frames*N, T_frames*N);
0345     D = sparse([Dh;Dv]);
0346 
0347     <span class="comment">%     Dv = spdiags([reshape([-ones(n-1,n); zeros(1,n)],N,1) ...</span>
0348     <span class="comment">%         reshape([zeros(1,n); ones(n-1,n)],N,1)], [0 1], N, N);</span>
0349     <span class="comment">%     Dh = spdiags([reshape([-ones(n,n-1) zeros(n,1)],N,1) ...</span>
0350     <span class="comment">%         reshape([zeros(n,1) ones(n,n-1)],N,1)], [0 n], N, N);</span>
0351     <span class="comment">%     D = sparse([Dh;Dv]);</span>
0352     
0353     Dhx = Dh*x;
0354     Dvx = Dv*x;
0355     
0356     sk = sqrt(abs(Dhx).^2 + abs(Dvx).^2);
0357     th = max(sk);
0358 
0359 <span class="keyword">end</span>
0360 
0361 <span class="keyword">end</span> <span class="comment">%-- end of NESTA function</span>
0362 
0363 <span class="comment">%%%%%%%%%%%% POWER METHOD TO ESTIMATE NORM %%%%%%%%%%%%%%%</span>
0364 <span class="comment">% Copied from MATLAB's &quot;normest&quot; function, but allows function handles, not just sparse matrices</span>
0365 <a name="_sub4" href="#_subfunctions" class="code">function [e,cnt] = my_normest(S,St,n,tol, maxiter)</a>
0366 <span class="comment">%MY_NORMEST Estimate the matrix 2-norm via power method.</span>
0367     <span class="keyword">if</span> nargin &lt; 4, tol = 1.e-6; <span class="keyword">end</span>
0368     <span class="keyword">if</span> nargin &lt; 5, maxiter = 20; <span class="keyword">end</span>
0369     <span class="keyword">if</span> isempty(St)
0370         St = S;  <span class="comment">% we assume the matrix is symmetric;</span>
0371     <span class="keyword">end</span>
0372     x = ones(n,1);
0373     cnt = 0;
0374     e = norm(x);
0375     <span class="keyword">if</span> e == 0, <span class="keyword">return</span>, <span class="keyword">end</span>
0376     x = x/e;
0377     e0 = 0;
0378     <span class="keyword">while</span> abs(e-e0) &gt; tol*e &amp;&amp; cnt &lt; maxiter
0379        e0 = e;
0380        Sx = S(x);
0381        <span class="keyword">if</span> nnz(Sx) == 0
0382           Sx = rand(size(Sx));
0383        <span class="keyword">end</span>
0384        e = norm(Sx);
0385        x = St(Sx);
0386        x = x/norm(x);
0387        cnt = cnt+1;
0388     <span class="keyword">end</span>
0389 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
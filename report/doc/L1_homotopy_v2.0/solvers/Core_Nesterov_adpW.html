<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Core_Nesterov_adpW</title>
  <meta name="keywords" content="Core_Nesterov_adpW">
  <meta name="description" content="[xk,niter,residuals,outputData,opts] =Core_Nesterov(A,At,b,mu,delta,opts)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html solvers -->
<h1>Core_Nesterov_adpW
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>[xk,niter,residuals,outputData,opts] =Core_Nesterov(A,At,b,mu,delta,opts)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [xk,niter,residuals,outputData,opts] = Core_Nesterov(A,At,b,mu,delta,opts) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> [xk,niter,residuals,outputData,opts] =Core_Nesterov(A,At,b,mu,delta,opts)

 Solves a L1 minimization problem under a quadratic constraint using the
 Nesterov algorithm, without continuation:

     min_x || U x ||_1 s.t. ||y - Ax||_2 &lt;= delta
 
 If continuation is desired, see the function NESTA.m

 The primal prox-function is also adapted by accounting for a first guess
 xplug that also tends towards x_muf 

 The observation matrix A is a projector

 Inputs:   A and At - measurement matrix and adjoint (either a matrix, in which
               case At is unused, or function handles).  m x n dimensions.
           b   - Observed data, a m x 1 array
           muf - The desired value of mu at the last continuation step.
               A smaller mu leads to higher accuracy.
           delta - l2 error bound.  This enforces how close the variable
               must fit the observations b, i.e. || y - Ax ||_2 &lt;= delta
               If delta = 0, enforces y = Ax
               Common heuristic: delta = sqrt(m + 2*sqrt(2*m))*sigma;
               where sigma=std(noise).
           opts -
               This is a structure that contains additional options,
               some of which are optional.
               The fieldnames are case insensitive.  Below
               are the possible fieldnames:
               
               opts.xplug - the first guess for the primal prox-function, and
                 also the initial point for xk.  By default, xplug = At(b)
               opts.U and opts.Ut - Analysis/Synthesis operators
                 (either matrices of function handles).
               opts.normU - if opts.U is provided, this should be norm(U)
               opts.maxiter - max number of iterations in an inner loop.
                 default is 10,000
               opts.TolVar - tolerance for the stopping criteria
               opts.stopTest - which stopping criteria to apply
                   opts.stopTest == 1 : stop when the relative
                       change in the objective function is less than
                       TolVar
                   opts.stopTest == 2 : stop with the l_infinity norm
                       of difference in the xk variable is less
                       than TolVar
               opts.TypeMin - if this is 'L1' (default), then
                   minimizes a smoothed version of the l_1 norm.
                   If this is 'tv', then minimizes a smoothed
                   version of the total-variation norm.
                   The string is case insensitive.
               opts.Verbose - if this is 0 or false, then very
                   little output is displayed.  If this is 1 or true,
                   then output every iteration is displayed.
                   If this is a number p greater than 1, then
                   output is displayed every pth iteration.
               opts.fid - if this is 1 (default), the display is
                   the usual Matlab screen.  If this is the file-id
                   of a file opened with fopen, then the display
                   will be redirected to this file.
               opts.errFcn - if this is a function handle,
                   then the program will evaluate opts.errFcn(xk)
                   at every iteration and display the result.
                   ex.  opts.errFcn = @(x) norm( x - x_true )
               opts.outFcn - if this is a function handle, 
                   then then program will evaluate opts.outFcn(xk)
                   at every iteration and save the results in outputData.
                   If the result is a vector (as opposed to a scalar),
                   it should be a row vector and not a column vector.
                   ex. opts.outFcn = @(x) [norm( x - xtrue, 'inf' ),...
                                           norm( x - xtrue) / norm(xtrue)]
               opts.AAtinv - this is an experimental new option.  AAtinv
                   is the inverse of AA^*.  This allows the use of a 
                   matrix A which is not a projection, but only
                   for the noiseless (i.e. delta = 0) case.
                   If the SVD of A is U*S*V', then AAtinv = U*(S^{-2})*U'.
               opts.USV - another experimental option.  This supercedes
                   the AAtinv option, so it is recommended that you
                   do not define AAtinv.  This allows the use of a matrix
                   A which is not a projection, and works for the
                   noisy ( i.e. delta &gt; 0 ) case.
                   opts.USV should contain three fields: 
                   opts.USV.U  is the U from [U,S,V] = svd(A)
                   likewise, opts.USV.S and opts.USV.V are S and V
                   from svd(A).  S may be a matrix or a vector.
  Outputs:
           xk  - estimate of the solution x
           niter - number of iterations
           residuals - first column is the residual at every step,
               second column is the value of f_mu at every step
           outputData - a matrix, where each row r is the output
               from opts.outFcn, if supplied.
           opts - the structure containing the options that were used      

 Written by: Jerome Bobin, Caltech
 Email: bobin@acm.caltech.edu
 Created: February 2009
 Modified: May 2009, Jerome Bobin and Stephen Becker, Caltech
 Modified: Nov 2009, Stephen Becker

 NESTA Version 1.1
   See also NESTA</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="NESTA_adpW.html" class="code" title="function [xk,niter,residuals,outputData,opts] =NESTA_adpW(A,At,b,muf,delta,opts)">NESTA_adpW</a>	[xk,niter,residuals,outputData] =NESTA(A,At,b,muf,delta,opts)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function printf(varargin), fprintf(fid,varargin{:}); end</a></li><li><a href="#_sub2" class="code">function [var,userSet] = setOpts(field,default,mn,mx)</a></li><li><a href="#_sub3" class="code">function [df,fx,val,uk, U, Ut, normU] = Perform_L1_Constraint(xk,mu,U,Ut,M)</a></li><li><a href="#_sub4" class="code">function [df,fx] = Perform_TV_Constraint(xk,mu,Dv,Dh,D,U,Ut)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [xk,niter,residuals,outputData,opts] = Core_Nesterov(</a><span class="keyword">...</span>
0002     A,At,b,mu,delta,opts)
0003 <span class="comment">% [xk,niter,residuals,outputData,opts] =Core_Nesterov(A,At,b,mu,delta,opts)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Solves a L1 minimization problem under a quadratic constraint using the</span>
0006 <span class="comment">% Nesterov algorithm, without continuation:</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%     min_x || U x ||_1 s.t. ||y - Ax||_2 &lt;= delta</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% If continuation is desired, see the function NESTA.m</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% The primal prox-function is also adapted by accounting for a first guess</span>
0013 <span class="comment">% xplug that also tends towards x_muf</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% The observation matrix A is a projector</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Inputs:   A and At - measurement matrix and adjoint (either a matrix, in which</span>
0018 <span class="comment">%               case At is unused, or function handles).  m x n dimensions.</span>
0019 <span class="comment">%           b   - Observed data, a m x 1 array</span>
0020 <span class="comment">%           muf - The desired value of mu at the last continuation step.</span>
0021 <span class="comment">%               A smaller mu leads to higher accuracy.</span>
0022 <span class="comment">%           delta - l2 error bound.  This enforces how close the variable</span>
0023 <span class="comment">%               must fit the observations b, i.e. || y - Ax ||_2 &lt;= delta</span>
0024 <span class="comment">%               If delta = 0, enforces y = Ax</span>
0025 <span class="comment">%               Common heuristic: delta = sqrt(m + 2*sqrt(2*m))*sigma;</span>
0026 <span class="comment">%               where sigma=std(noise).</span>
0027 <span class="comment">%           opts -</span>
0028 <span class="comment">%               This is a structure that contains additional options,</span>
0029 <span class="comment">%               some of which are optional.</span>
0030 <span class="comment">%               The fieldnames are case insensitive.  Below</span>
0031 <span class="comment">%               are the possible fieldnames:</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%               opts.xplug - the first guess for the primal prox-function, and</span>
0034 <span class="comment">%                 also the initial point for xk.  By default, xplug = At(b)</span>
0035 <span class="comment">%               opts.U and opts.Ut - Analysis/Synthesis operators</span>
0036 <span class="comment">%                 (either matrices of function handles).</span>
0037 <span class="comment">%               opts.normU - if opts.U is provided, this should be norm(U)</span>
0038 <span class="comment">%               opts.maxiter - max number of iterations in an inner loop.</span>
0039 <span class="comment">%                 default is 10,000</span>
0040 <span class="comment">%               opts.TolVar - tolerance for the stopping criteria</span>
0041 <span class="comment">%               opts.stopTest - which stopping criteria to apply</span>
0042 <span class="comment">%                   opts.stopTest == 1 : stop when the relative</span>
0043 <span class="comment">%                       change in the objective function is less than</span>
0044 <span class="comment">%                       TolVar</span>
0045 <span class="comment">%                   opts.stopTest == 2 : stop with the l_infinity norm</span>
0046 <span class="comment">%                       of difference in the xk variable is less</span>
0047 <span class="comment">%                       than TolVar</span>
0048 <span class="comment">%               opts.TypeMin - if this is 'L1' (default), then</span>
0049 <span class="comment">%                   minimizes a smoothed version of the l_1 norm.</span>
0050 <span class="comment">%                   If this is 'tv', then minimizes a smoothed</span>
0051 <span class="comment">%                   version of the total-variation norm.</span>
0052 <span class="comment">%                   The string is case insensitive.</span>
0053 <span class="comment">%               opts.Verbose - if this is 0 or false, then very</span>
0054 <span class="comment">%                   little output is displayed.  If this is 1 or true,</span>
0055 <span class="comment">%                   then output every iteration is displayed.</span>
0056 <span class="comment">%                   If this is a number p greater than 1, then</span>
0057 <span class="comment">%                   output is displayed every pth iteration.</span>
0058 <span class="comment">%               opts.fid - if this is 1 (default), the display is</span>
0059 <span class="comment">%                   the usual Matlab screen.  If this is the file-id</span>
0060 <span class="comment">%                   of a file opened with fopen, then the display</span>
0061 <span class="comment">%                   will be redirected to this file.</span>
0062 <span class="comment">%               opts.errFcn - if this is a function handle,</span>
0063 <span class="comment">%                   then the program will evaluate opts.errFcn(xk)</span>
0064 <span class="comment">%                   at every iteration and display the result.</span>
0065 <span class="comment">%                   ex.  opts.errFcn = @(x) norm( x - x_true )</span>
0066 <span class="comment">%               opts.outFcn - if this is a function handle,</span>
0067 <span class="comment">%                   then then program will evaluate opts.outFcn(xk)</span>
0068 <span class="comment">%                   at every iteration and save the results in outputData.</span>
0069 <span class="comment">%                   If the result is a vector (as opposed to a scalar),</span>
0070 <span class="comment">%                   it should be a row vector and not a column vector.</span>
0071 <span class="comment">%                   ex. opts.outFcn = @(x) [norm( x - xtrue, 'inf' ),...</span>
0072 <span class="comment">%                                           norm( x - xtrue) / norm(xtrue)]</span>
0073 <span class="comment">%               opts.AAtinv - this is an experimental new option.  AAtinv</span>
0074 <span class="comment">%                   is the inverse of AA^*.  This allows the use of a</span>
0075 <span class="comment">%                   matrix A which is not a projection, but only</span>
0076 <span class="comment">%                   for the noiseless (i.e. delta = 0) case.</span>
0077 <span class="comment">%                   If the SVD of A is U*S*V', then AAtinv = U*(S^{-2})*U'.</span>
0078 <span class="comment">%               opts.USV - another experimental option.  This supercedes</span>
0079 <span class="comment">%                   the AAtinv option, so it is recommended that you</span>
0080 <span class="comment">%                   do not define AAtinv.  This allows the use of a matrix</span>
0081 <span class="comment">%                   A which is not a projection, and works for the</span>
0082 <span class="comment">%                   noisy ( i.e. delta &gt; 0 ) case.</span>
0083 <span class="comment">%                   opts.USV should contain three fields:</span>
0084 <span class="comment">%                   opts.USV.U  is the U from [U,S,V] = svd(A)</span>
0085 <span class="comment">%                   likewise, opts.USV.S and opts.USV.V are S and V</span>
0086 <span class="comment">%                   from svd(A).  S may be a matrix or a vector.</span>
0087 <span class="comment">%  Outputs:</span>
0088 <span class="comment">%           xk  - estimate of the solution x</span>
0089 <span class="comment">%           niter - number of iterations</span>
0090 <span class="comment">%           residuals - first column is the residual at every step,</span>
0091 <span class="comment">%               second column is the value of f_mu at every step</span>
0092 <span class="comment">%           outputData - a matrix, where each row r is the output</span>
0093 <span class="comment">%               from opts.outFcn, if supplied.</span>
0094 <span class="comment">%           opts - the structure containing the options that were used</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% Written by: Jerome Bobin, Caltech</span>
0097 <span class="comment">% Email: bobin@acm.caltech.edu</span>
0098 <span class="comment">% Created: February 2009</span>
0099 <span class="comment">% Modified: May 2009, Jerome Bobin and Stephen Becker, Caltech</span>
0100 <span class="comment">% Modified: Nov 2009, Stephen Becker</span>
0101 <span class="comment">%</span>
0102 <span class="comment">% NESTA Version 1.1</span>
0103 <span class="comment">%   See also NESTA</span>
0104 
0105 <span class="comment">%---- Set defaults</span>
0106 <span class="comment">% opts = [];</span>
0107 fid = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'fid'</span>,1);
0108 <a name="_sub1" href="#_subfunctions" class="code">function printf(varargin), fprintf(fid,varargin{:}); end</a>
0109 maxiter = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'maxiter'</span>,10000,0);
0110 TolVar = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'TolVar'</span>,1e-5);
0111 TypeMin = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'TypeMin'</span>,<span class="string">'L1'</span>);
0112 Verbose = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'Verbose'</span>,true);
0113 errFcn = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'errFcn'</span>,[]);
0114 outFcn = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'outFcn'</span>,[]);
0115 stopTest = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'stopTest'</span>,1,1,2);
0116 U = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'U'</span>, @(x) x );
0117 <span class="keyword">if</span> ~isa(U,<span class="string">'function_handle'</span>)
0118     Ut = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'Ut'</span>,[]);
0119 <span class="keyword">else</span>
0120     Ut = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'Ut'</span>, @(x) x );
0121 <span class="keyword">end</span>
0122 xplug = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'xplug'</span>,[]);
0123 normU = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'normU'</span>,1);
0124 
0125 <span class="keyword">if</span> delta &lt; 0, error(<span class="string">'delta must be greater or equal to zero'</span>); <span class="keyword">end</span>
0126 
0127 <span class="keyword">if</span> isa(A,<span class="string">'function_handle'</span>)
0128     Atfun = At;
0129     Afun = A;
0130 <span class="keyword">else</span>
0131     Atfun = @(x) A'*x;
0132     Afun = @(x) A*x;
0133 <span class="keyword">end</span>
0134 Atb = Atfun(b);
0135 
0136 AAtinv = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'AAtinv'</span>,[]);
0137 USV = <a href="#_sub2" class="code" title="subfunction [var,userSet] = setOpts(field,default,mn,mx)">setOpts</a>(<span class="string">'USV'</span>,[]);
0138 <span class="keyword">if</span> ~isempty(USV)
0139     <span class="keyword">if</span> isstruct(USV)
0140         Q = USV.U;  <span class="comment">% we can't use &quot;U&quot; as the variable name</span>
0141                     <span class="comment">% since &quot;U&quot; already refers to the analysis operator</span>
0142         S = USV.S;
0143         <span class="keyword">if</span> isvector(S), s = S; S = diag(s);
0144         <span class="keyword">else</span> s = diag(S); <span class="keyword">end</span>
0145         V = USV.V;
0146     <span class="keyword">else</span>
0147         error(<span class="string">'opts.USV must be a structure'</span>);
0148     <span class="keyword">end</span>
0149     <span class="keyword">if</span> isempty(AAtinv)
0150         AAtinv = Q*diag( s.^(-2) )*Q';
0151     <span class="keyword">end</span>
0152 <span class="keyword">end</span>
0153 <span class="comment">% --- for A not a projection (experimental)</span>
0154 <span class="keyword">if</span> ~isempty(AAtinv)
0155     <span class="keyword">if</span> isa(AAtinv,<span class="string">'function_handle'</span>)
0156         AAtinv_fun = AAtinv;
0157     <span class="keyword">else</span>
0158         AAtinv_fun = @(x) AAtinv * x;
0159     <span class="keyword">end</span>
0160     
0161     AtAAtb = Atfun( AAtinv_fun(b) );
0162 
0163 <span class="keyword">else</span>
0164     <span class="comment">% We assume it's a projection</span>
0165     AtAAtb = Atb;
0166     AAtinv_fun = @(x) x;
0167 <span class="keyword">end</span>
0168 
0169 <span class="keyword">if</span> isempty(xplug)
0170     xplug = AtAAtb; 
0171 <span class="keyword">end</span>
0172 
0173 <span class="comment">%---- Initialization</span>
0174 N = length(xplug);
0175 wk = zeros(N,1); 
0176 xk = xplug;
0177 
0178 
0179 <span class="comment">%---- Init Variables</span>
0180 Ak= 0;
0181 Lmu = normU/mu;
0182 yk = xk;
0183 zk = xk;
0184 fmean = realmin/10;
0185 OK = 0;
0186 
0187 <span class="comment">%---- Computing Atb</span>
0188 Atb = Atfun(b);
0189 Axk = Afun(xk);<span class="comment">% only needed if you want to see the residuals</span>
0190 <span class="comment">% Axplug = Axk;</span>
0191 
0192 
0193 <span class="comment">%---- TV Minimization</span>
0194 <span class="keyword">if</span> strcmpi(TypeMin,<span class="string">'TV'</span>)
0195     Lmu = 8*Lmu;
0196     <span class="keyword">global</span> T_frames ROW COL
0197     <span class="keyword">if</span> isempty(T_frames)
0198         T_frames = 1;
0199         N = length(xplug); n = floor(sqrt(N));
0200         ROW = n; COL = n; 
0201     <span class="keyword">end</span>
0202     
0203     <span class="comment">%     Dv = spdiags(repmat([reshape([-ones(n-1,n); zeros(1,n)],N,1) ...</span>
0204     <span class="comment">%         reshape([zeros(1,n); ones(n-1,n)],N,1)], T_frames,1), [0 1], T_frames*N, T_frames*N);</span>
0205     <span class="comment">%     Dh = spdiags(repmat([reshape([-ones(n,n-1) zeros(n,1)],N,1) ...</span>
0206     <span class="comment">%         reshape([zeros(n,1) ones(n,n-1)],N,1)],T_frames,1), [0 n], T_frames*N, T_frames*N);</span>
0207     <span class="comment">%     D = sparse([Dh;Dv]);</span>
0208     
0209     N = ROW*COL;
0210     Dv = spdiags(repmat([reshape([-ones(ROW-1,COL); zeros(1,COL)],N,1) <span class="keyword">...</span>
0211         reshape([zeros(1,COL); ones(ROW-1,COL)],N,1)], T_frames,1), [0 1], T_frames*N, T_frames*N);
0212     Dh = spdiags(repmat([reshape([-ones(ROW,COL-1) zeros(ROW,1)],N,1) <span class="keyword">...</span>
0213         reshape([zeros(ROW,1) ones(ROW,COL-1)],N,1)],T_frames,1), [0 ROW], T_frames*N, T_frames*N);
0214     D = sparse([Dh;Dv]);
0215     <span class="comment">%     Dv = spdiags([reshape([-ones(n-1,n); zeros(1,n)],N,1) ...</span>
0216     <span class="comment">%         reshape([zeros(1,n); ones(n-1,n)],N,1)], [0 1], N, N);</span>
0217     <span class="comment">%     Dh = spdiags([reshape([-ones(n,n-1) zeros(n,1)],N,1) ...</span>
0218     <span class="comment">%         reshape([zeros(n,1) ones(n,n-1)],N,1)], [0 n], N, N);</span>
0219     <span class="comment">%     D = sparse([Dh;Dv]);</span>
0220 <span class="keyword">end</span>
0221 
0222 
0223 Lmu1 = 1/Lmu;
0224 <span class="comment">% SLmu = sqrt(Lmu);</span>
0225 <span class="comment">% SLmu1 = 1/sqrt(Lmu);</span>
0226 lambdaY = 0;
0227 lambdaZ = 0;
0228 
0229 <span class="comment">%---- setup data storage variables</span>
0230 [DISPLAY_ERROR, RECORD_DATA] = deal(false);
0231 outputData = deal([]);
0232 residuals = zeros(maxiter,2);
0233 <span class="keyword">if</span> ~isempty(errFcn), DISPLAY_ERROR = true; <span class="keyword">end</span>
0234 <span class="keyword">if</span> ~isempty(outFcn) &amp;&amp; nargout &gt;= 4
0235     RECORD_DATA = true;
0236     outputData = zeros(maxiter, size(outFcn(xplug),2) );
0237 <span class="keyword">end</span>
0238 
0239 <span class="keyword">for</span> k = 0:maxiter-1,
0240     
0241    <span class="comment">%---- Dual problem</span>
0242    clear Acp AtAcp df fx uk;
0243    <span class="keyword">if</span> strcmpi(TypeMin,<span class="string">'L1'</span>)  [df,fx,val,uk,U,Ut,normU] = <a href="#_sub3" class="code" title="subfunction [df,fx,val,uk, U, Ut, normU] = Perform_L1_Constraint(xk,mu,U,Ut,M)">Perform_L1_Constraint</a>(xk,mu,U,Ut,length(b));<span class="keyword">end</span>
0244    
0245    <span class="keyword">if</span> strcmpi(TypeMin,<span class="string">'TV'</span>)  [df,fx] = <a href="#_sub4" class="code" title="subfunction [df,fx] = Perform_TV_Constraint(xk,mu,Dv,Dh,D,U,Ut)">Perform_TV_Constraint</a>(xk,mu,Dv,Dh,D,U,Ut);<span class="keyword">end</span>
0246    
0247    <span class="comment">%---- Primal Problem</span>
0248    
0249    <span class="comment">%---- Updating yk</span>
0250     
0251     <span class="comment">%</span>
0252     <span class="comment">% yk = Argmin_x Lmu/2 ||x - xk||_l2^2 + &lt;df,x-xk&gt; s.t. ||b-Ax||_l2 &lt; delta</span>
0253     <span class="comment">% Let xp be sqrt(Lmu) (x-xk), dfp be df/sqrt(Lmu), bp be sqrt(Lmu)(b- Axk) and deltap be sqrt(Lmu)delta</span>
0254     <span class="comment">% yk =  xk + 1/sqrt(Lmu) Argmin_xp 1/2 || xp ||_2^2 + &lt;dfp,xp&gt; s.t. || bp - Axp ||_2 &lt; deltap</span>
0255     <span class="comment">%</span>
0256     
0257     
0258     cp = xk - 1/Lmu*df;  <span class="comment">% this is &quot;q&quot; in eq. (3.7) in the paper</span>
0259     
0260     Acp = Afun( cp );
0261     <span class="keyword">if</span> ~isempty(AAtinv) &amp;&amp; isempty(USV)
0262         AtAcp = Atfun( AAtinv_fun( Acp ) );
0263     <span class="keyword">else</span>
0264         AtAcp = Atfun( Acp );
0265     <span class="keyword">end</span>
0266     
0267     residuals(k+1,1) = norm( b-Axk);    <span class="comment">% the residual</span>
0268     residuals(k+1,2) = fx;              <span class="comment">% the value of the objective</span>
0269     <span class="comment">%--- if user has supplied a function, apply it to the iterate</span>
0270     <span class="keyword">if</span> RECORD_DATA
0271         outputData(k+1,:) = outFcn(xk);
0272     <span class="keyword">end</span>
0273     
0274     <span class="keyword">if</span> delta &gt; 0
0275         <span class="keyword">if</span> ~isempty(USV)
0276             <span class="comment">% there are more efficient methods, but we're assuming</span>
0277             <span class="comment">% that A is negligible compared to U and Ut.</span>
0278             <span class="comment">% Here we make the change of variables x &lt;-- x - xk</span>
0279             <span class="comment">%       and                            df &lt;-- df/L</span>
0280             dfp = -Lmu1*df;  Adfp = -(Axk - Acp);
0281             bp = b - Axk;
0282             deltap = delta;
0283             <span class="comment">% Check if we even need to project:</span>
0284             <span class="keyword">if</span> norm( Adfp - bp ) &lt; deltap
0285                 lambdaY = 0;  projIter = 0;
0286                 <span class="comment">% i.e. projection = dfp;</span>
0287                 yk = xk + dfp;
0288                 Ayk = Axk + Adfp;
0289             <span class="keyword">else</span>
0290                 lambdaY_old = lambdaY;
0291                 [projection,projIter,lambdaY] = fastProjection(Q,S,V,dfp,bp,<span class="keyword">...</span>
0292                     deltap, .999*lambdaY_old );
0293                 <span class="keyword">if</span> lambdaY &gt; 0, disp(<span class="string">'lambda is positive!'</span>); keyboard; <span class="keyword">end</span>
0294                 yk = xk + projection;
0295                 Ayk = Afun(yk);
0296                 <span class="comment">% DEBUGGING</span>
0297 <span class="comment">%                 if projIter == 50</span>
0298 <span class="comment">%                     fprintf('\n Maxed out iterations at y\n');</span>
0299 <span class="comment">%                     keyboard</span>
0300 <span class="comment">%                 end</span>
0301             <span class="keyword">end</span>
0302         <span class="keyword">else</span>
0303             lambda = max(0,Lmu*(norm(b-Acp)/delta - 1));gamma = lambda/(lambda + Lmu);
0304             yk = lambda/Lmu*(1-gamma)*Atb + cp - gamma*AtAcp;
0305             <span class="comment">% for calculating the residual, we'll avoid calling A()</span>
0306             <span class="comment">% by storing A(yk) here (using A'*A = I):</span>
0307             Ayk = lambda/Lmu*(1-gamma)*b + Acp - gamma*Acp;
0308         <span class="keyword">end</span>
0309     <span class="keyword">else</span>
0310         <span class="comment">% if delta is 0, the projection is simplified:</span>
0311         yk = AtAAtb + cp - AtAcp;
0312         Ayk = b;
0313     <span class="keyword">end</span>
0314 
0315     <span class="comment">% DEBUGGING</span>
0316 <span class="comment">%     if norm( Ayk - b ) &gt; (1.05)*delta</span>
0317 <span class="comment">%         fprintf('\nAyk failed projection test\n');</span>
0318 <span class="comment">%         keyboard;</span>
0319 <span class="comment">%     end</span>
0320     
0321     <span class="comment">%--- Stopping criterion</span>
0322     qp = abs(fx - mean(fmean))/mean(fmean);
0323     
0324     <span class="keyword">switch</span> stopTest
0325         <span class="keyword">case</span> 1
0326             <span class="comment">% look at the relative change in function value</span>
0327             <span class="keyword">if</span> qp &lt;= TolVar &amp;&amp; OK; <span class="keyword">break</span>;<span class="keyword">end</span>
0328             <span class="keyword">if</span> qp &lt;= TolVar &amp;&amp; ~OK; OK=1; <span class="keyword">end</span>
0329         <span class="keyword">case</span> 2
0330             <span class="comment">% look at the l_inf change from previous iterate</span>
0331             <span class="keyword">if</span> k &gt;= 1 &amp;&amp; norm( xk - xold, <span class="string">'inf'</span> ) &lt;= TolVar
0332                 <span class="keyword">break</span>
0333             <span class="keyword">end</span>
0334     <span class="keyword">end</span>
0335     fmean = [fx,fmean];
0336     <span class="keyword">if</span> (length(fmean) &gt; 10) fmean = fmean(1:10);<span class="keyword">end</span>
0337     
0338 
0339     
0340     <span class="comment">%--- Updating zk</span>
0341   
0342     apk =0.5*(k+1);
0343     Ak = Ak + apk; 
0344     tauk = 2/(k+3); 
0345     
0346     wk =  apk*df + wk;
0347     
0348     <span class="comment">%</span>
0349     <span class="comment">% zk = Argmin_x Lmu/2 ||b - Ax||_l2^2 + Lmu/2||x - xplug ||_2^2+ &lt;wk,x-xk&gt;</span>
0350     <span class="comment">%   s.t. ||b-Ax||_l2 &lt; delta</span>
0351     <span class="comment">%</span>
0352     
0353     cp = xplug - 1/Lmu*wk;
0354     
0355     Acp = Afun( cp );
0356     <span class="keyword">if</span> ~isempty( AAtinv ) &amp;&amp; isempty(USV)
0357         AtAcp = Atfun( AAtinv_fun( Acp ) );
0358     <span class="keyword">else</span>
0359         AtAcp = Atfun( Acp );
0360     <span class="keyword">end</span>
0361     
0362     <span class="keyword">if</span> delta &gt; 0
0363         <span class="keyword">if</span> ~isempty(USV)
0364             <span class="comment">% Make the substitution wk &lt;-- wk/K</span>
0365                  
0366 <span class="comment">%             dfp = (xplug - Lmu1*wk);  % = cp</span>
0367 <span class="comment">%             Adfp= (Axplug - Acp);</span>
0368             dfp = cp; Adfp = Acp; 
0369             bp = b;
0370             deltap = delta;            
0371 <span class="comment">%             dfp = SLmu*xplug - SLmu1*wk;</span>
0372 <span class="comment">%             bp = SLmu*b;</span>
0373 <span class="comment">%             deltap = SLmu*delta;</span>
0374 
0375             <span class="comment">% See if we even need to project:</span>
0376             <span class="keyword">if</span> norm( Adfp - bp ) &lt; deltap
0377                 zk = dfp;
0378                 Azk = Adfp;
0379             <span class="keyword">else</span>
0380                 [projection,projIter,lambdaZ] = fastProjection(Q,S,V,dfp,bp,<span class="keyword">...</span>
0381                     deltap, .999*lambdaZ );
0382                 <span class="keyword">if</span> lambdaZ &gt; 0, disp(<span class="string">'lambda is positive!'</span>); keyboard; <span class="keyword">end</span>
0383                 zk = projection;
0384                 <span class="comment">%             zk = SLmu1*projection;</span>
0385                 Azk = Afun(zk);
0386             
0387                 <span class="comment">% DEBUGGING:</span>
0388 <span class="comment">%                 if projIter == 50</span>
0389 <span class="comment">%                     fprintf('\n Maxed out iterations at z\n');</span>
0390 <span class="comment">%                     keyboard</span>
0391 <span class="comment">%                 end</span>
0392             <span class="keyword">end</span>
0393         <span class="keyword">else</span>
0394             lambda = max(0,Lmu*(norm(b-Acp)/delta - 1));gamma = lambda/(lambda + Lmu);
0395             zk = lambda/Lmu*(1-gamma)*Atb + cp - gamma*AtAcp;
0396             <span class="comment">% for calculating the residual, we'll avoid calling A()</span>
0397             <span class="comment">% by storing A(zk) here (using A'*A = I):</span>
0398             Azk = lambda/Lmu*(1-gamma)*b + Acp - gamma*Acp;
0399         <span class="keyword">end</span>
0400     <span class="keyword">else</span>
0401         <span class="comment">% if delta is 0, this is simplified:</span>
0402         zk = AtAAtb + cp - AtAcp;
0403         Azk = b;
0404     <span class="keyword">end</span>
0405     
0406     <span class="comment">% DEBUGGING</span>
0407 <span class="comment">%     if norm( Ayk - b ) &gt; (1.05)*delta</span>
0408 <span class="comment">%         fprintf('\nAzk failed projection test\n');</span>
0409 <span class="comment">%         keyboard;</span>
0410 <span class="comment">%     end</span>
0411 
0412     <span class="comment">%--- Updating xk</span>
0413     
0414     xkp = tauk*zk + (1-tauk)*yk;
0415     xold = xk;
0416     xk=xkp; 
0417     Axk = tauk*Azk + (1-tauk)*Ayk;
0418     
0419     <span class="keyword">if</span> ~mod(k,10), Axk = Afun(xk); <span class="keyword">end</span>   <span class="comment">% otherwise slowly lose precision</span>
0420     <span class="comment">% DEBUG</span>
0421 <span class="comment">%     if norm(Axk - Afun(xk) ) &gt; 1e-6, disp('error with Axk'); keyboard; end</span>
0422     
0423     <span class="comment">%--- display progress if desired</span>
0424     <span class="keyword">if</span> ~mod(k+1,Verbose )
0425         <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Iter: %3d  ~ fmu: %.3e ~ Rel. Variation of fmu: %.2e ~ Residual: %.2e'</span>,<span class="keyword">...</span>
0426             k+1,fx,qp,residuals(k+1,1) ); 
0427         <span class="comment">%--- if user has supplied a function to calculate the error,</span>
0428         <span class="comment">% apply it to the current iterate and dislay the output:</span>
0429         <span class="keyword">if</span> DISPLAY_ERROR, <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">' ~ Error: %.2e'</span>,errFcn(xk)); <span class="keyword">end</span>
0430         <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'\n'</span>);
0431         
0432       
0433         <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0434     <span class="keyword">end</span>
0435     <span class="keyword">if</span> abs(fx)&gt;1e20 || abs(residuals(k+1,1)) &gt;1e20 || isnan(fx)
0436         error(<span class="string">'Nesta: possible divergence or NaN.  Bad estimate of ||A''A||?'</span>);
0437     <span class="keyword">end</span>
0438 
0439 <span class="keyword">end</span>
0440 
0441 niter = k+1; 
0442 
0443 <span class="comment">%-- truncate output vectors</span>
0444 residuals = residuals(1:niter,:);
0445 <span class="keyword">if</span> RECORD_DATA,     outputData = outputData(1:niter,:); <span class="keyword">end</span>
0446 
0447 
0448 
0449 <span class="comment">%---- internal routine for setting defaults</span>
0450 <a name="_sub2" href="#_subfunctions" class="code">function [var,userSet] = setOpts(field,default,mn,mx)</a>
0451     var = default;
0452     <span class="comment">% has the option already been set?</span>
0453     <span class="keyword">if</span> ~isfield(opts,field) 
0454         <span class="comment">% see if there is a capitalization problem:</span>
0455         names = fieldnames(opts);
0456         <span class="keyword">for</span> i = 1:length(names)
0457             <span class="keyword">if</span> strcmpi(names{i},field)
0458                 opts.(field) = opts.(names{i});
0459                 opts = rmfield(opts,names{i});
0460                 <span class="keyword">break</span>;
0461             <span class="keyword">end</span>
0462         <span class="keyword">end</span>
0463     <span class="keyword">end</span>
0464     
0465     <span class="keyword">if</span> isfield(opts,field) &amp;&amp; ~isempty(opts.(field))
0466         var = opts.(field);  <span class="comment">% override the default</span>
0467         userSet = true;
0468     <span class="keyword">else</span>
0469         userSet = false;
0470     <span class="keyword">end</span>
0471     
0472     <span class="comment">% perform error checking, if desired</span>
0473     <span class="keyword">if</span> nargin &gt;= 3 &amp;&amp; ~isempty(mn)
0474         <span class="keyword">if</span> var &lt; mn
0475             <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Variable %s is %f, should be at least %f\n'</span>,<span class="keyword">...</span>
0476                 field,var,mn); error(<span class="string">'variable out-of-bounds'</span>);
0477         <span class="keyword">end</span>
0478     <span class="keyword">end</span>
0479     <span class="keyword">if</span> nargin &gt;= 4 &amp;&amp; ~isempty(mx)
0480         <span class="keyword">if</span> var &gt; mx
0481             <a href="#_sub1" class="code" title="subfunction printf(varargin), fprintf(fid,varargin{:}); end">printf</a>(<span class="string">'Variable %s is %f, should be at least %f\n'</span>,<span class="keyword">...</span>
0482                 field,var,mn); error(<span class="string">'variable out-of-bounds'</span>);
0483         <span class="keyword">end</span>
0484     <span class="keyword">end</span>
0485     opts.(field) = var;
0486 <span class="keyword">end</span>
0487 
0488 
0489 <span class="keyword">end</span> <span class="comment">%% end of main Core_Nesterov routine</span>
0490 
0491 
0492 <span class="comment">%%%%%%%%%%%% PERFORM THE L1 CONSTRAINT %%%%%%%%%%%%%%%%%%</span>
0493 
0494 <a name="_sub3" href="#_subfunctions" class="code">function [df,fx,val,uk, U, Ut, normU] = Perform_L1_Constraint(xk,mu,U,Ut,M)</a>
0495 
0496     <span class="keyword">if</span> isa(U,<span class="string">'function_handle'</span>)
0497         uk = U(xk);
0498     <span class="keyword">else</span>
0499         uk = U*xk;
0500     <span class="keyword">end</span>
0501     fx = uk;
0502 
0503     uk = uk./max(mu,abs(uk));
0504     val = real(uk'*fx);
0505     fx = real(uk'*fx - mu/2*norm(uk)^2);
0506 
0507     <span class="keyword">if</span> isa(Ut,<span class="string">'function_handle'</span>)
0508         df = Ut(uk);
0509     <span class="keyword">else</span>
0510         df = U'*uk;
0511     <span class="keyword">end</span>
0512     
0513     gamma = find(xk);
0514     ewt_b = 2*M*(norm(xk,2)/norm(xk,1))^2;
0515     W_new = ones(length(xk),1);
0516     W_new(gamma) = min([W_new(gamma) 1./abs(xk(gamma))/ewt_b],[],2);
0517     
0518     U = U; <span class="comment">%spdiags(W_new,0,length(xk),length(xk));</span>
0519     Ut = U;
0520     normU = max(W_new);
0521 <span class="keyword">end</span>
0522 
0523 <span class="comment">%%%%%%%%%%%% PERFORM THE TV CONSTRAINT %%%%%%%%%%%%%%%%%%</span>
0524 
0525 <a name="_sub4" href="#_subfunctions" class="code">function [df,fx] = Perform_TV_Constraint(xk,mu,Dv,Dh,D,U,Ut)</a>
0526     <span class="keyword">if</span> isa(U,<span class="string">'function_handle'</span>)
0527         x = U(xk);
0528     <span class="keyword">else</span>
0529         x = U*xk;
0530     <span class="keyword">end</span>
0531     df = zeros(size(x));
0532 
0533     Dhx = Dh*x;
0534     Dvx = Dv*x;
0535             
0536     tvx = sum(sqrt(abs(Dhx).^2+abs(Dvx).^2));
0537     w = max(mu,sqrt(abs(Dhx).^2 + abs(Dvx).^2));
0538     uh = Dhx ./ w;
0539     uv = Dvx ./ w;
0540     u = [uh;uv];
0541     fx = real(u'*D*x - mu/2 * 1/numel(u)*sum(u'*u));
0542     <span class="keyword">if</span> isa(Ut,<span class="string">'function_handle'</span>)
0543         df = Ut(D'*u);
0544     <span class="keyword">else</span>
0545         df = U'*(D'*u);
0546     <span class="keyword">end</span>
0547 <span class="keyword">end</span>
0548</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
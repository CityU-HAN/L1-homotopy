<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SpaRSA_adpW</title>
  <meta name="keywords" content="SpaRSA_adpW">
  <meta name="description" content="SpaRSA version 2.0, December 31, 2007">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html solvers -->
<h1>SpaRSA_adpW
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>SpaRSA version 2.0, December 31, 2007</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [x,x_debias,objective,times,debias_start,mses,taus, numA, numAt]=SpaRSA_adpW(y,A,tau,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> SpaRSA version 2.0, December 31, 2007

 This function solves the convex problem

 arg min_x = 0.5*|| y - A x ||_2^2 + tau phi(x)

 using the SpaRSA algorithm, which is described in &quot;Sparse Reconstruction
 by Separable Approximation&quot; by S. Wright, R. Nowak, M. Figueiredo,
 IEEE Transactions on Signal Processing, 2009 (to appear).

 The algorithm is related GPSR (Figueiredo, Nowak, Wright) but does not
 rely on the conversion to QP form of the l1 norm, because it is not
 limited to being used with l1 regularization. Instead it forms a separable
 approximation to the first term of the objective, which has the form

  d'*A'*(A x - y) + 0.5*alpha*d'*d

 where alpha is obtained from a BB formula. In a monotone variant, alpha is
 increased until we see a decreasein the original objective function over
 this step.

 -----------------------------------------------------------------------
 Copyright (2007): Mario Figueiredo, Robert Nowak, Stephen Wright

 GPSR is distributed under the terms
 of the GNU General Public License 2.0.

 Permission to use, copy, modify, and distribute this software for
 any purpose without fee is hereby granted, provided that this entire
 notice is included in all copies of any software which is or includes
 a copy or modification of this software and in all copies of the
 supporting documentation for such software.
 This software is being provided &quot;as is&quot;, without any express or
 implied warranty.  In particular, the authors do not make any
 representation or warranty of any kind concerning the merchantability
 of this software or its fitness for any particular purpose.&quot;
 ----------------------------------------------------------------------

 Please check for the latest version of the code and paper at
 www.lx.it.pt/~mtf/SpaRSA

  ===== Required inputs =============

  y: 1D vector or 2D array (image) of observations

  A: if y and x are both 1D vectors, A can be a
     k*n (where k is the size of y and n the size of x)
     matrix or a handle to a function that computes
     products of the form A*v, for some vector v.
     In any other case (if y and/or x are 2D arrays),
     A has to be passed as a handle to a function which computes
     products of the form A*x; another handle to a function
     AT which computes products of the form A'*x is also required
     in this case. The size of x is determined as the size
     of the result of applying AT.

  tau: regularization parameter (scalar)

  ===== Optional inputs =============


  'AT'    = function handle for the function that implements
            the multiplication by the conjugate of A, when A
            is a function handle. If A is an array, AT is ignored.

  'Psi'   = handle to the denoising function, that is, to a function
            that computes the solution of the densoing probelm
            corresponding to the desired regularizer. That is,
            Psi(y,tau) = arg min_x (1/2)*(x - y)^2 + tau phi(x).
            Default: in the absence of any Phi given by the user,
            it is assumed that phi(x) = ||x||_1 thus
            Psi(y,tau) = soft(y,tau)
            Important: if Psi is given, phi must also be given,
                       so that the algorithm may also compute
                       the objective function.

  'StopCriterion' = type of stopping criterion to use
                    0 = algorithm stops when the relative
                        change in the number of non-zero
                        components of the estimate falls
                        below 'ToleranceA'
                    1 = stop when the relative
                       change in the objective function
                       falls below 'ToleranceA'
                    2 = stop when relative duality gap
                       falls below 'ToleranceA'
                    3 = stop when LCP estimate of relative
                       distance to solution falls below ToleranceA
                    4 = stop when the objective function
                        becomes equal or less than toleranceA.
                    5 = stop when the norm of the difference between
                        two consecutive estimates, divided by the norm
                        of one of them falls below toleranceA
                    Default = 2

  'ToleranceA' = stopping threshold; Default = 0.01

  'Debias'     = debiasing option: 1 = yes, 0 = no.
                 Default = 0.

  'ToleranceD' = stopping threshold for the debiasing phase:
                 Default = 0.0001.
                 If no debiasing takes place, this parameter,
                 if present, is ignored.

  'MaxiterA' = maximum number of iterations allowed in the
               main phase of the algorithm.
               Default = 1000

  'MiniterA' = minimum number of iterations performed in the
               main phase of the algorithm.
               Default = 5

  'MaxiterD' = maximum number of iterations allowed in the
               debising phase of the algorithm.
               Default = 200

  'MiniterD' = minimum number of iterations to perform in the
               debiasing phase of the algorithm.
               Default = 5

  'Initialization' must be one of {0,1,2,array}
               0 -&gt; Initialization at zero.
               1 -&gt; Random initialization.
               2 -&gt; initialization with A'*y.
           array -&gt; initialization provided by the user.
               Default = 0;

  'BB_variant' specifies which variant of Barzila-Borwein to use, or not.
               0 -&gt; don't use a BB rule - instead pick the starting alpha
               based on the successful value at the previous iteration
               1 -&gt; standard BB choice  s'r/s's
               2 -&gt; inverse BB variant r'r/r's
               Default = 1

  'BB_cycle' specifies the cycle length  - the number of iterations between
             recalculation of alpha. Requires integer value at least
             1. Relevant only if a **nonmonotone BB rule** is used
             (BB_variant = 1 or 2 and Monotone=0).
             Default = 1

  'Monotone' =  enforce monotonic decrease in f, or not?
               any nonzero -&gt; enforce monotonicity (overrides 'Safeguard')
               0 -&gt; don't enforce monotonicity.
               Default = 0;

  'Safeguard' = enforce a &quot;sufficient decrease&quot; over the largest
               objective value of the past M iterations.
               any nonzero -&gt; safeguard
               0 -&gt; don't safeguard
               Default = 0.

  'M'        = number of steps to look back in the safeguarding process.
               Ignored if Safeguard=0 or if Monotone is nonzero.
               (positive integer. Default = 5)

  'sigma'    = sigma value used in Safeguarding test for sufficient
               decrease. Ignored unless 'Safeguard' is nonzero. Must be
               in (0,1). Drfault: .01.

  'Eta'      = factor by which alpha is multiplied within an iteration,
               until a decrease in the objective function is
               obtained.
               Default = 2;

  'Alpha_factor' = factor by which to reduce the successful value of
                alpha at iteration k, to give the first value of alpha
                to be tried at iteration k+1.
                If a Barzilai-Borwein rule is specified (BB_variant &gt; 0),
                this parameter is ignored.
                Default = 0.8;

  'Continuation' = Continuation or not (1 or 0)
                   Specifies the choice for a continuation scheme,
                   in which we start with a large value of tau, and
                   then decrease tau until the desired value is
                   reached. At each value, the solution obtained
                   with the previous values is used as initialization.
                   Default = 0

 'ContinuationSteps' = Number of steps in the continuation procedure;
                       ignored if 'Continuation' equals zero.
                       If -1, an adaptive continuation procedure is used.
                       Default = -1.

 'FirstTauFactor'  = Initial tau value, if using continuation, is
                     obtained by multiplying the given tau by
                     this factor. This parameter is ignored if
                     'Continuation' equals zero or
                     'ContinuationSteps' equals -1.
                     Default = 10.

  'True_x' = if the true underlying x is passed in
                this argument, MSE plots are generated.

  'AlphaMin' = the alphamin parameter of the BB method.
               Default = 1e-30;

  'AlphaMax' = the alphamax parameter of the BB method.
               Default = 1e30;

  'Verbose'  = work silently (0) or verbosely (1)

 ===================================================
 ============ Outputs ==============================
   x = solution of the main algorithm

   x_debias = solution after the debiasing phase;
                  if no debiasing phase took place, this
                  variable is empty, x_debias = [].

   objective = sequence of values of the objective function

   times = CPU time after each iteration

   debias_start = iteration number at which the debiasing
                  phase started. If no debiasing took place,
                  this variable is returned as zero.

   mses = sequence of MSE values, with respect to True_x,
          if it was given; if it was not given, mses is empty,
          mses = [].
 ========================================================</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="soft.html" class="code" title="function y = soft(x,T)">soft</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../L1_homotopy_v2.0/WeightedBPDN/src/script_simulation_adpWBPDN.html" class="code" title="">script_simulation_adpWBPDN</a>	partial script for running different solvers for adaptive reweighting</li><li><a href="../../L1_homotopy_v2.0/WeightedBPDN/src/script_simulation_wtBPDN.html" class="code" title="">script_simulation_wtBPDN</a>	partial script for running different solvers</li><li><a href="../../L1_homotopy_v2.0/demo_KalmanRWT.html" class="code" title="">demo_KalmanRWT</a>	demo_KalmanRWT</li><li><a href="../../L1_homotopy_v2.0/demo_dynamicRWT.html" class="code" title="">demo_dynamicRWT</a>	demo_dynamicRWT</li><li><a href="../../L1_homotopy_v2.0/demo_streaming.html" class="code" title="">demo_streaming</a>	demo_streaming</li><li><a href="../../L1_homotopy_v2.0/demo_streamingDWT.html" class="code" title="">demo_streamingDWT</a>	demo_streamingDWT</li><li><a href="../../L1_homotopy_v2.0/demo_streamingLOT.html" class="code" title="">demo_streamingLOT</a>	demo_streamingLOT</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [x,x_debias,objective,times,debias_start,mses,taus, numA, numAt]= </a><span class="keyword">...</span>
0002     SpaRSA_adpW(y,A,tau,varargin)
0003 
0004 <span class="comment">% SpaRSA version 2.0, December 31, 2007</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% This function solves the convex problem</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% arg min_x = 0.5*|| y - A x ||_2^2 + tau phi(x)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% using the SpaRSA algorithm, which is described in &quot;Sparse Reconstruction</span>
0011 <span class="comment">% by Separable Approximation&quot; by S. Wright, R. Nowak, M. Figueiredo,</span>
0012 <span class="comment">% IEEE Transactions on Signal Processing, 2009 (to appear).</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% The algorithm is related GPSR (Figueiredo, Nowak, Wright) but does not</span>
0015 <span class="comment">% rely on the conversion to QP form of the l1 norm, because it is not</span>
0016 <span class="comment">% limited to being used with l1 regularization. Instead it forms a separable</span>
0017 <span class="comment">% approximation to the first term of the objective, which has the form</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%  d'*A'*(A x - y) + 0.5*alpha*d'*d</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% where alpha is obtained from a BB formula. In a monotone variant, alpha is</span>
0022 <span class="comment">% increased until we see a decreasein the original objective function over</span>
0023 <span class="comment">% this step.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% -----------------------------------------------------------------------</span>
0026 <span class="comment">% Copyright (2007): Mario Figueiredo, Robert Nowak, Stephen Wright</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% GPSR is distributed under the terms</span>
0029 <span class="comment">% of the GNU General Public License 2.0.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% Permission to use, copy, modify, and distribute this software for</span>
0032 <span class="comment">% any purpose without fee is hereby granted, provided that this entire</span>
0033 <span class="comment">% notice is included in all copies of any software which is or includes</span>
0034 <span class="comment">% a copy or modification of this software and in all copies of the</span>
0035 <span class="comment">% supporting documentation for such software.</span>
0036 <span class="comment">% This software is being provided &quot;as is&quot;, without any express or</span>
0037 <span class="comment">% implied warranty.  In particular, the authors do not make any</span>
0038 <span class="comment">% representation or warranty of any kind concerning the merchantability</span>
0039 <span class="comment">% of this software or its fitness for any particular purpose.&quot;</span>
0040 <span class="comment">% ----------------------------------------------------------------------</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% Please check for the latest version of the code and paper at</span>
0043 <span class="comment">% www.lx.it.pt/~mtf/SpaRSA</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%  ===== Required inputs =============</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%  y: 1D vector or 2D array (image) of observations</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%  A: if y and x are both 1D vectors, A can be a</span>
0050 <span class="comment">%     k*n (where k is the size of y and n the size of x)</span>
0051 <span class="comment">%     matrix or a handle to a function that computes</span>
0052 <span class="comment">%     products of the form A*v, for some vector v.</span>
0053 <span class="comment">%     In any other case (if y and/or x are 2D arrays),</span>
0054 <span class="comment">%     A has to be passed as a handle to a function which computes</span>
0055 <span class="comment">%     products of the form A*x; another handle to a function</span>
0056 <span class="comment">%     AT which computes products of the form A'*x is also required</span>
0057 <span class="comment">%     in this case. The size of x is determined as the size</span>
0058 <span class="comment">%     of the result of applying AT.</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%  tau: regularization parameter (scalar)</span>
0061 <span class="comment">%</span>
0062 <span class="comment">%  ===== Optional inputs =============</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%  'AT'    = function handle for the function that implements</span>
0066 <span class="comment">%            the multiplication by the conjugate of A, when A</span>
0067 <span class="comment">%            is a function handle. If A is an array, AT is ignored.</span>
0068 <span class="comment">%</span>
0069 <span class="comment">%  'Psi'   = handle to the denoising function, that is, to a function</span>
0070 <span class="comment">%            that computes the solution of the densoing probelm</span>
0071 <span class="comment">%            corresponding to the desired regularizer. That is,</span>
0072 <span class="comment">%            Psi(y,tau) = arg min_x (1/2)*(x - y)^2 + tau phi(x).</span>
0073 <span class="comment">%            Default: in the absence of any Phi given by the user,</span>
0074 <span class="comment">%            it is assumed that phi(x) = ||x||_1 thus</span>
0075 <span class="comment">%            Psi(y,tau) = soft(y,tau)</span>
0076 <span class="comment">%            Important: if Psi is given, phi must also be given,</span>
0077 <span class="comment">%                       so that the algorithm may also compute</span>
0078 <span class="comment">%                       the objective function.</span>
0079 <span class="comment">%</span>
0080 <span class="comment">%  'StopCriterion' = type of stopping criterion to use</span>
0081 <span class="comment">%                    0 = algorithm stops when the relative</span>
0082 <span class="comment">%                        change in the number of non-zero</span>
0083 <span class="comment">%                        components of the estimate falls</span>
0084 <span class="comment">%                        below 'ToleranceA'</span>
0085 <span class="comment">%                    1 = stop when the relative</span>
0086 <span class="comment">%                       change in the objective function</span>
0087 <span class="comment">%                       falls below 'ToleranceA'</span>
0088 <span class="comment">%                    2 = stop when relative duality gap</span>
0089 <span class="comment">%                       falls below 'ToleranceA'</span>
0090 <span class="comment">%                    3 = stop when LCP estimate of relative</span>
0091 <span class="comment">%                       distance to solution falls below ToleranceA</span>
0092 <span class="comment">%                    4 = stop when the objective function</span>
0093 <span class="comment">%                        becomes equal or less than toleranceA.</span>
0094 <span class="comment">%                    5 = stop when the norm of the difference between</span>
0095 <span class="comment">%                        two consecutive estimates, divided by the norm</span>
0096 <span class="comment">%                        of one of them falls below toleranceA</span>
0097 <span class="comment">%                    Default = 2</span>
0098 <span class="comment">%</span>
0099 <span class="comment">%  'ToleranceA' = stopping threshold; Default = 0.01</span>
0100 <span class="comment">%</span>
0101 <span class="comment">%  'Debias'     = debiasing option: 1 = yes, 0 = no.</span>
0102 <span class="comment">%                 Default = 0.</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%  'ToleranceD' = stopping threshold for the debiasing phase:</span>
0105 <span class="comment">%                 Default = 0.0001.</span>
0106 <span class="comment">%                 If no debiasing takes place, this parameter,</span>
0107 <span class="comment">%                 if present, is ignored.</span>
0108 <span class="comment">%</span>
0109 <span class="comment">%  'MaxiterA' = maximum number of iterations allowed in the</span>
0110 <span class="comment">%               main phase of the algorithm.</span>
0111 <span class="comment">%               Default = 1000</span>
0112 <span class="comment">%</span>
0113 <span class="comment">%  'MiniterA' = minimum number of iterations performed in the</span>
0114 <span class="comment">%               main phase of the algorithm.</span>
0115 <span class="comment">%               Default = 5</span>
0116 <span class="comment">%</span>
0117 <span class="comment">%  'MaxiterD' = maximum number of iterations allowed in the</span>
0118 <span class="comment">%               debising phase of the algorithm.</span>
0119 <span class="comment">%               Default = 200</span>
0120 <span class="comment">%</span>
0121 <span class="comment">%  'MiniterD' = minimum number of iterations to perform in the</span>
0122 <span class="comment">%               debiasing phase of the algorithm.</span>
0123 <span class="comment">%               Default = 5</span>
0124 <span class="comment">%</span>
0125 <span class="comment">%  'Initialization' must be one of {0,1,2,array}</span>
0126 <span class="comment">%               0 -&gt; Initialization at zero.</span>
0127 <span class="comment">%               1 -&gt; Random initialization.</span>
0128 <span class="comment">%               2 -&gt; initialization with A'*y.</span>
0129 <span class="comment">%           array -&gt; initialization provided by the user.</span>
0130 <span class="comment">%               Default = 0;</span>
0131 <span class="comment">%</span>
0132 <span class="comment">%  'BB_variant' specifies which variant of Barzila-Borwein to use, or not.</span>
0133 <span class="comment">%               0 -&gt; don't use a BB rule - instead pick the starting alpha</span>
0134 <span class="comment">%               based on the successful value at the previous iteration</span>
0135 <span class="comment">%               1 -&gt; standard BB choice  s'r/s's</span>
0136 <span class="comment">%               2 -&gt; inverse BB variant r'r/r's</span>
0137 <span class="comment">%               Default = 1</span>
0138 <span class="comment">%</span>
0139 <span class="comment">%  'BB_cycle' specifies the cycle length  - the number of iterations between</span>
0140 <span class="comment">%             recalculation of alpha. Requires integer value at least</span>
0141 <span class="comment">%             1. Relevant only if a **nonmonotone BB rule** is used</span>
0142 <span class="comment">%             (BB_variant = 1 or 2 and Monotone=0).</span>
0143 <span class="comment">%             Default = 1</span>
0144 <span class="comment">%</span>
0145 <span class="comment">%  'Monotone' =  enforce monotonic decrease in f, or not?</span>
0146 <span class="comment">%               any nonzero -&gt; enforce monotonicity (overrides 'Safeguard')</span>
0147 <span class="comment">%               0 -&gt; don't enforce monotonicity.</span>
0148 <span class="comment">%               Default = 0;</span>
0149 <span class="comment">%</span>
0150 <span class="comment">%  'Safeguard' = enforce a &quot;sufficient decrease&quot; over the largest</span>
0151 <span class="comment">%               objective value of the past M iterations.</span>
0152 <span class="comment">%               any nonzero -&gt; safeguard</span>
0153 <span class="comment">%               0 -&gt; don't safeguard</span>
0154 <span class="comment">%               Default = 0.</span>
0155 <span class="comment">%</span>
0156 <span class="comment">%  'M'        = number of steps to look back in the safeguarding process.</span>
0157 <span class="comment">%               Ignored if Safeguard=0 or if Monotone is nonzero.</span>
0158 <span class="comment">%               (positive integer. Default = 5)</span>
0159 <span class="comment">%</span>
0160 <span class="comment">%  'sigma'    = sigma value used in Safeguarding test for sufficient</span>
0161 <span class="comment">%               decrease. Ignored unless 'Safeguard' is nonzero. Must be</span>
0162 <span class="comment">%               in (0,1). Drfault: .01.</span>
0163 <span class="comment">%</span>
0164 <span class="comment">%  'Eta'      = factor by which alpha is multiplied within an iteration,</span>
0165 <span class="comment">%               until a decrease in the objective function is</span>
0166 <span class="comment">%               obtained.</span>
0167 <span class="comment">%               Default = 2;</span>
0168 <span class="comment">%</span>
0169 <span class="comment">%  'Alpha_factor' = factor by which to reduce the successful value of</span>
0170 <span class="comment">%                alpha at iteration k, to give the first value of alpha</span>
0171 <span class="comment">%                to be tried at iteration k+1.</span>
0172 <span class="comment">%                If a Barzilai-Borwein rule is specified (BB_variant &gt; 0),</span>
0173 <span class="comment">%                this parameter is ignored.</span>
0174 <span class="comment">%                Default = 0.8;</span>
0175 <span class="comment">%</span>
0176 <span class="comment">%  'Continuation' = Continuation or not (1 or 0)</span>
0177 <span class="comment">%                   Specifies the choice for a continuation scheme,</span>
0178 <span class="comment">%                   in which we start with a large value of tau, and</span>
0179 <span class="comment">%                   then decrease tau until the desired value is</span>
0180 <span class="comment">%                   reached. At each value, the solution obtained</span>
0181 <span class="comment">%                   with the previous values is used as initialization.</span>
0182 <span class="comment">%                   Default = 0</span>
0183 <span class="comment">%</span>
0184 <span class="comment">% 'ContinuationSteps' = Number of steps in the continuation procedure;</span>
0185 <span class="comment">%                       ignored if 'Continuation' equals zero.</span>
0186 <span class="comment">%                       If -1, an adaptive continuation procedure is used.</span>
0187 <span class="comment">%                       Default = -1.</span>
0188 <span class="comment">%</span>
0189 <span class="comment">% 'FirstTauFactor'  = Initial tau value, if using continuation, is</span>
0190 <span class="comment">%                     obtained by multiplying the given tau by</span>
0191 <span class="comment">%                     this factor. This parameter is ignored if</span>
0192 <span class="comment">%                     'Continuation' equals zero or</span>
0193 <span class="comment">%                     'ContinuationSteps' equals -1.</span>
0194 <span class="comment">%                     Default = 10.</span>
0195 <span class="comment">%</span>
0196 <span class="comment">%  'True_x' = if the true underlying x is passed in</span>
0197 <span class="comment">%                this argument, MSE plots are generated.</span>
0198 <span class="comment">%</span>
0199 <span class="comment">%  'AlphaMin' = the alphamin parameter of the BB method.</span>
0200 <span class="comment">%               Default = 1e-30;</span>
0201 <span class="comment">%</span>
0202 <span class="comment">%  'AlphaMax' = the alphamax parameter of the BB method.</span>
0203 <span class="comment">%               Default = 1e30;</span>
0204 <span class="comment">%</span>
0205 <span class="comment">%  'Verbose'  = work silently (0) or verbosely (1)</span>
0206 <span class="comment">%</span>
0207 <span class="comment">% ===================================================</span>
0208 <span class="comment">% ============ Outputs ==============================</span>
0209 <span class="comment">%   x = solution of the main algorithm</span>
0210 <span class="comment">%</span>
0211 <span class="comment">%   x_debias = solution after the debiasing phase;</span>
0212 <span class="comment">%                  if no debiasing phase took place, this</span>
0213 <span class="comment">%                  variable is empty, x_debias = [].</span>
0214 <span class="comment">%</span>
0215 <span class="comment">%   objective = sequence of values of the objective function</span>
0216 <span class="comment">%</span>
0217 <span class="comment">%   times = CPU time after each iteration</span>
0218 <span class="comment">%</span>
0219 <span class="comment">%   debias_start = iteration number at which the debiasing</span>
0220 <span class="comment">%                  phase started. If no debiasing took place,</span>
0221 <span class="comment">%                  this variable is returned as zero.</span>
0222 <span class="comment">%</span>
0223 <span class="comment">%   mses = sequence of MSE values, with respect to True_x,</span>
0224 <span class="comment">%          if it was given; if it was not given, mses is empty,</span>
0225 <span class="comment">%          mses = [].</span>
0226 <span class="comment">% ========================================================</span>
0227 
0228 <span class="comment">%----------------------------------------------------------------</span>
0229 <span class="comment">% Some modification for solving weighted L1 problem</span>
0230 <span class="comment">% Added an option to perform adaptive reweighting using flag</span>
0231 <span class="comment">%</span>
0232 <span class="comment">% adp_wt = adaptive reweighting</span>
0233 <span class="comment">%           1 - adaptive reweighting,</span>
0234 <span class="comment">%           0 - standard SpaRSA (default)</span>
0235 <span class="comment">%</span>
0236 <span class="comment">% W_new assigns the values to the weights</span>
0237 <span class="comment">% Termination criteria 2 and 3 modified to accomodate weighted L1 norm</span>
0238 <span class="comment">%</span>
0239 <span class="comment">% Modified: June 2012 by Salman Asif @ Georgia Tech.</span>
0240 <span class="comment">%----------------------------------------------------------------</span>
0241 
0242 <span class="comment">% start the clock</span>
0243 t0 = cputime;
0244 times(1) = cputime - t0;
0245 
0246 <span class="comment">% test for number of required parametres</span>
0247 <span class="keyword">if</span> (nargin-length(varargin)) ~= 3
0248     error(<span class="string">'Wrong number of required parameters'</span>);
0249 <span class="keyword">end</span>
0250 
0251 <span class="comment">% Set the defaults for the optional parameters</span>
0252 stopCriterion = 2;
0253 tolA = 0.01;
0254 tolD = 0.0001;
0255 debias = 0;
0256 maxiter = 10000;
0257 maxiter_debias = 200;
0258 miniter = 5;
0259 miniter_debias = 0;
0260 init = 0;
0261 bbVariant = 1;
0262 bbCycle = 1;
0263 enforceMonotone = 0;
0264 enforceSafeguard = 0;
0265 M = 5;
0266 sigma = .01;
0267 alphamin = 1e-30;
0268 alphamax = 1e30;
0269 compute_mse = 0;
0270 AT = 0;
0271 verbose = 1;
0272 adp_wt = 0;     <span class="comment">% adaptive reweighting</span>
0273 W_new = 1;
0274 continuation = 0;
0275 cont_steps = -1;
0276 psi_ok = 0;
0277 phi_ok = 0;
0278 <span class="comment">% amount by which to increase alpha after an unsuccessful step</span>
0279 eta = 2.0;
0280 <span class="comment">% amount by which to decrease alpha between iterations, if a</span>
0281 <span class="comment">% Barzilai-Borwein rule is not used to make the initial guess at each</span>
0282 <span class="comment">% iteration.</span>
0283 alphaFactor = 0.8;
0284 phi_l1 = 0;
0285 
0286 <span class="comment">% Set the defaults for outputs that may not be computed</span>
0287 debias_start = 0;
0288 x_debias = [];
0289 mses = [];
0290 
0291 <span class="comment">% number of matrix multiplies</span>
0292 numA = 0; numAt = 0;
0293 
0294 <span class="comment">% Read the optional parameters</span>
0295 <span class="keyword">if</span> (rem(length(varargin),2)==1)
0296     error(<span class="string">'Optional parameters should always go by pairs'</span>);
0297 <span class="keyword">else</span>
0298     <span class="keyword">for</span> i=1:2:(length(varargin)-1)
0299         <span class="keyword">switch</span> upper(varargin{i})
0300             <span class="keyword">case</span> <span class="string">'PSI'</span>
0301                 psi_function = varargin{i+1};
0302             <span class="keyword">case</span> <span class="string">'PHI'</span>
0303                 phi_function = varargin{i+1};
0304             <span class="keyword">case</span> <span class="string">'STOPCRITERION'</span>
0305                 stopCriterion = varargin{i+1};
0306             <span class="keyword">case</span> <span class="string">'TOLERANCEA'</span>
0307                 tolA = varargin{i+1};
0308             <span class="keyword">case</span> <span class="string">'TOLERANCED'</span>
0309                 tolD = varargin{i+1};
0310             <span class="keyword">case</span> <span class="string">'DEBIAS'</span>
0311                 debias = varargin{i+1};
0312             <span class="keyword">case</span> <span class="string">'MAXITERA'</span>
0313                 maxiter = varargin{i+1};
0314             <span class="keyword">case</span> <span class="string">'MAXITERD'</span>
0315                 maxiter_debias = varargin{i+1};
0316             <span class="keyword">case</span> <span class="string">'MINITERA'</span>
0317                 miniter = varargin{i+1};
0318             <span class="keyword">case</span> <span class="string">'MINITERD'</span>
0319                 miniter_debias = varargin{i+1};
0320             <span class="keyword">case</span> <span class="string">'INITIALIZATION'</span>
0321                 <span class="keyword">if</span> prod(size(varargin{i+1})) &gt; 1   <span class="comment">% we have an initial x</span>
0322                     init = 33333;    <span class="comment">% some flag to be used below</span>
0323                     x = varargin{i+1};
0324                 <span class="keyword">else</span>
0325                     init = varargin{i+1};
0326                 <span class="keyword">end</span>
0327             <span class="keyword">case</span> <span class="string">'BB_VARIANT'</span>
0328                 bbVariant = varargin{i+1};
0329             <span class="keyword">case</span> <span class="string">'BB_CYCLE'</span>
0330                 bbCycle = varargin{i+1};
0331             <span class="keyword">case</span> <span class="string">'MONOTONE'</span>
0332                 enforceMonotone = varargin{i+1};
0333             <span class="keyword">case</span> <span class="string">'SAFEGUARD'</span>
0334                 enforceSafeguard = varargin{i+1};
0335             <span class="keyword">case</span> <span class="string">'M'</span>
0336                 M = varargin{i+1};
0337             <span class="keyword">case</span> <span class="string">'SIGMA'</span>
0338                 sigma = varargin{i+1};
0339             <span class="keyword">case</span> <span class="string">'ETA'</span>
0340                 eta = varargin{i+1};
0341             <span class="keyword">case</span> <span class="string">'ALPHA_FACTOR'</span>
0342                 alphaFactor = varargin{i+1};
0343             <span class="keyword">case</span> <span class="string">'CONTINUATION'</span>
0344                 continuation = varargin{i+1};
0345             <span class="keyword">case</span> <span class="string">'CONTINUATIONSTEPS'</span>
0346                 cont_steps = varargin{i+1};
0347             <span class="keyword">case</span> <span class="string">'FIRSTTAUFACTOR'</span>
0348                 firstTauFactor = varargin{i+1};
0349             <span class="keyword">case</span> <span class="string">'TRUE_X'</span>
0350                 compute_mse = 1;
0351                 true = varargin{i+1};
0352             <span class="keyword">case</span> <span class="string">'ALPHAMIN'</span>
0353                 alphamin = varargin{i+1};
0354             <span class="keyword">case</span> <span class="string">'ALPHAMAX'</span>
0355                 alphamax = varargin{i+1};
0356             <span class="keyword">case</span> <span class="string">'AT'</span>
0357                 AT = varargin{i+1};
0358             <span class="keyword">case</span> <span class="string">'VERBOSE'</span>
0359                 verbose = varargin{i+1};
0360             <span class="keyword">case</span> <span class="string">'ADP_WT'</span>
0361                 adp_wt = varargin{i+1};
0362             <span class="keyword">case</span> <span class="string">'W_NEW'</span>
0363                 W_new = varargin{i+1};
0364             <span class="keyword">otherwise</span>
0365                 <span class="comment">% Hmmm, something wrong with the parameter string</span>
0366                 error([<span class="string">'Unrecognized option: '''</span> varargin{i} <span class="string">''''</span>]);
0367         <span class="keyword">end</span>;
0368     <span class="keyword">end</span>;
0369 <span class="keyword">end</span>
0370 <span class="comment">%%%%%%%%%%%%%%</span>
0371 
0372 <span class="comment">% it makes no sense to ask for a nonmonotone variant of a non-BB method</span>
0373 <span class="keyword">if</span> ~enforceMonotone &amp;&amp; bbVariant==0
0374     error([<span class="string">'non-monotone, non-BBmethod requested'</span>]);
0375 <span class="keyword">end</span>
0376 
0377 <span class="keyword">if</span> (sum(stopCriterion == [0 1 2 3 4 5])==0)
0378     error([<span class="string">'Unknown stopping criterion'</span>]);
0379 <span class="keyword">end</span>
0380 
0381 <span class="comment">% if A is a function handle, we have to check presence of AT,</span>
0382 <span class="keyword">if</span> isa(A, <span class="string">'function_handle'</span>) &amp;&amp; ~isa(AT,<span class="string">'function_handle'</span>)
0383     error([<span class="string">'The function handle for transpose of A is missing'</span>]);
0384 <span class="keyword">end</span>
0385 
0386 <span class="comment">% if A is a matrix, we find out dimensions of y and x,</span>
0387 <span class="comment">% and create function handles for multiplication by A and A',</span>
0388 <span class="comment">% so that the code below doesn't have to distinguish between</span>
0389 <span class="comment">% the handle/not-handle cases</span>
0390 <span class="keyword">if</span> ~isa(A, <span class="string">'function_handle'</span>)
0391     AT = @(x) A'*x;
0392     A = @(x) A*x;
0393 <span class="keyword">end</span>
0394 <span class="comment">% from this point down, A and AT are always function handles.</span>
0395 
0396 <span class="comment">% Precompute A'*y since it'll be used a lot</span>
0397 Aty = AT(y); numAt = numAt+1;
0398 
0399 <span class="comment">% if phi was given, check to see if it is a handle and that it</span>
0400 <span class="comment">% accepts two arguments</span>
0401 <span class="keyword">if</span> exist(<span class="string">'psi_function'</span>,<span class="string">'var'</span>)
0402     <span class="keyword">if</span> isa(psi_function,<span class="string">'function_handle'</span>)
0403         <span class="keyword">try</span>  <span class="comment">% check if phi can be used, using Aty, which we know has</span>
0404             <span class="comment">% same size as x</span>
0405             dummy = psi_function(Aty,tau);
0406             psi_ok = 1;
0407         <span class="keyword">catch</span>
0408             error([<span class="string">'Something is wrong with function handle for psi'</span>])
0409         <span class="keyword">end</span>
0410     <span class="keyword">else</span>
0411         error([<span class="string">'Psi does not seem to be a valid function handle'</span>]);
0412     <span class="keyword">end</span>
0413 <span class="keyword">else</span> <span class="comment">%if nothing was given, use soft thresholding</span>
0414     psi_function = @(x,tau) <a href="soft.html" class="code" title="function y = soft(x,T)">soft</a>(x,tau);
0415 <span class="keyword">end</span>
0416 
0417 <span class="comment">% if psi exists, phi must also exist</span>
0418 <span class="keyword">if</span> (psi_ok == 1)
0419     <span class="keyword">if</span> exist(<span class="string">'phi_function'</span>,<span class="string">'var'</span>)
0420         <span class="keyword">if</span> isa(phi_function,<span class="string">'function_handle'</span>)
0421             <span class="keyword">try</span>  <span class="comment">% check if phi can be used, using Aty, which we know has</span>
0422                 <span class="comment">% same size as x</span>
0423                 dummy = phi_function(Aty);
0424             <span class="keyword">catch</span>
0425                 error([<span class="string">'Something is wrong with function handle for phi'</span>])
0426             <span class="keyword">end</span>
0427         <span class="keyword">else</span>
0428             error([<span class="string">'Phi does not seem to be a valid function handle'</span>]);
0429         <span class="keyword">end</span>
0430     <span class="keyword">else</span>
0431         error([<span class="string">'If you give Psi you must also give Phi'</span>]);
0432     <span class="keyword">end</span>
0433 <span class="keyword">else</span>  <span class="comment">% if no psi and phi were given, simply use the l1 norm.</span>
0434     phi_function = @(x) sum(abs(x(:)));
0435     phi_l1 = 1;
0436 <span class="keyword">end</span>
0437 phi_l1 = 1;
0438 
0439 <span class="comment">% Initialization</span>
0440 <span class="keyword">switch</span> init
0441     <span class="keyword">case</span> 0   <span class="comment">% initialize at zero, using AT to find the size of x</span>
0442         x = AT(zeros(size(y)));
0443     <span class="keyword">case</span> 1   <span class="comment">% initialize randomly, using AT to find the size of x</span>
0444         x = randn(size(AT(zeros(size(y)))));
0445     <span class="keyword">case</span> 2   <span class="comment">% initialize x0 = A'*y</span>
0446         x = Aty;
0447     <span class="keyword">case</span> 33333
0448         <span class="comment">% initial x was given as a function argument; just check size</span>
0449         <span class="keyword">if</span> size(A(x)) ~= size(y)
0450             error([<span class="string">'Size of initial x is not compatible with A'</span>]);
0451         <span class="keyword">end</span>
0452     <span class="keyword">otherwise</span>
0453         error([<span class="string">'Unknown ''Initialization'' option'</span>]);
0454 <span class="keyword">end</span>
0455 
0456 <span class="comment">% if the true x was given, check its size</span>
0457 <span class="keyword">if</span> compute_mse &amp; (size(true) ~= size(x))
0458     error([<span class="string">'Initial x has incompatible size'</span>]);
0459 <span class="keyword">end</span>
0460 
0461 <span class="comment">% if tau is large enough, in the case of phi = l1, thus psi = soft,</span>
0462 <span class="comment">% the optimal solution is the zero vector</span>
0463 <span class="keyword">if</span> phi_l1
0464     aux = AT(y); numAt = numAt+1;
0465     max_tau = max(abs(aux(:)));
0466     firstTauFactor = 0.8*max_tau / tau;
0467     <span class="keyword">if</span> (tau &gt;= max_tau) &amp;&amp; (psi_ok==0)
0468         x = zeros(size(aux));
0469         <span class="keyword">if</span> debias
0470             x_debias = x;
0471         <span class="keyword">end</span>
0472         objective(1) = 0.5*(y(:)'*y(:));
0473         times(1) = 0;
0474         <span class="keyword">if</span> compute_mse
0475             mses(1) = sum(true(:).^2);
0476         <span class="keyword">end</span>
0477         <span class="keyword">return</span>
0478     <span class="keyword">end</span>
0479 <span class="keyword">end</span>
0480 
0481 <span class="comment">% define the indicator vector or matrix of nonzeros in x</span>
0482 nz_x = (x ~= 0.0);
0483 num_nz_x = sum(nz_x(:));
0484 
0485 <span class="comment">% store given tau, because we're going to change it in the</span>
0486 <span class="comment">% continuation procedure</span>
0487 final_tau = tau;
0488 <span class="comment">% if we choose to use adaptive continuation, need to reset tau to realmax to</span>
0489 <span class="comment">% make things work (don't ask...)</span>
0490 <span class="keyword">if</span> cont_steps == -1
0491     tau = realmax;
0492 <span class="keyword">end</span>
0493 
0494 <span class="comment">% store given stopping criterion and threshold, because we're going</span>
0495 <span class="comment">% to change them in the continuation procedure</span>
0496 final_stopCriterion = stopCriterion;
0497 final_tolA = tolA;
0498 
0499 <span class="comment">% set continuation factors</span>
0500 
0501 <span class="keyword">if</span> (continuation &amp;&amp; phi_l1 &amp;&amp; (cont_steps &gt; 1))
0502     <span class="comment">% If tau is scalar, first check top see if the first factor is</span>
0503     <span class="comment">% too large (i.e., large enough to make the first</span>
0504     <span class="comment">% solution all zeros). If so, make it a little smaller than that.</span>
0505     <span class="keyword">if</span> prod(size(tau)) == 1
0506         <span class="keyword">if</span> firstTauFactor*tau &gt;= max_tau
0507             firstTauFactor = 0.5 * max_tau / tau;
0508             <span class="keyword">if</span> verbose
0509                 fprintf(1,<span class="string">'\n setting parameter FirstTauFactor\n'</span>)
0510             <span class="keyword">end</span>
0511         <span class="keyword">end</span>
0512         cont_factors = 10.^[log10(firstTauFactor):<span class="keyword">...</span>
0513             log10(1/firstTauFactor)/(cont_steps-1):0];
0514     <span class="keyword">end</span>
0515 <span class="keyword">else</span>
0516     <span class="keyword">if</span> ( ~continuation )
0517         cont_factors = 1;
0518         cont_steps = 1;
0519     <span class="keyword">end</span>
0520 <span class="keyword">end</span>
0521 
0522 keep_continuation = 1;
0523 cont_loop = 1;
0524 iter = 1;
0525 taus = [];
0526 
0527 <span class="comment">% loop for continuation</span>
0528 <span class="keyword">while</span> keep_continuation
0529     
0530     <span class="comment">% initialize the count of steps since last update of alpha</span>
0531     <span class="comment">% (for use in cyclic BB)</span>
0532     iterThisCycle = 0;
0533     
0534     <span class="comment">% Compute the initial residual and gradient</span>
0535     resid =  A(x) - y; numA = numA+1;
0536     gradq = AT(resid); numAt = numAt+1;
0537     
0538     <span class="keyword">if</span> cont_steps == -1
0539         
0540         temp_tau = max(final_tau,0.2*max(abs(gradq(:)))); 
0541         
0542         <span class="keyword">if</span> temp_tau &gt; tau
0543             tau = final_tau;
0544         <span class="keyword">else</span>
0545             tau = temp_tau;
0546         <span class="keyword">end</span>
0547         
0548         <span class="keyword">if</span> tau == final_tau
0549             stopCriterion = final_stopCriterion;
0550             tolA = final_tolA;
0551             keep_continuation = 0;
0552         <span class="keyword">else</span>
0553             stopCriterion = 1;
0554             tolA = 1e-5;
0555         <span class="keyword">end</span>
0556     <span class="keyword">else</span>
0557         tau = final_tau * cont_factors(cont_loop);
0558         <span class="keyword">if</span> cont_loop == cont_steps
0559             stopCriterion = final_stopCriterion;
0560             tolA = final_tolA;
0561             keep_continuation = 0;
0562         <span class="keyword">else</span>
0563             stopCriterion = 1;
0564             tolA = 1e-5;
0565         <span class="keyword">end</span>
0566     <span class="keyword">end</span>
0567     
0568     taus = [taus tau];
0569     
0570     <span class="keyword">if</span> verbose
0571         fprintf(<span class="string">'\n Regularization parameter tau = %10.6e\n'</span>,tau)
0572     <span class="keyword">end</span>
0573     
0574     <span class="comment">% compute and store initial value of the objective function</span>
0575     <span class="comment">% for this tau</span>
0576     alpha = 1; <span class="comment">%1/eps;</span>
0577     
0578     f = 0.5*(resid(:)'*resid(:)) + tau * phi_function(x);
0579     <span class="keyword">if</span> enforceSafeguard
0580         f_lastM = f;
0581     <span class="keyword">end</span>
0582     
0583     <span class="comment">% if we are at the very start of the process, store the initial mses and</span>
0584     <span class="comment">% objective in the plotting arrays</span>
0585     <span class="keyword">if</span> cont_loop==1
0586         objective(1) = f;
0587         <span class="keyword">if</span> compute_mse
0588             mses(1) = (x(:)-true(:))'*(x(:)-true(:));
0589         <span class="keyword">end</span>
0590         <span class="keyword">if</span> verbose
0591             fprintf(1,<span class="string">'Initial obj=%10.6e, alpha=%6.2e, nonzeros=%7d\n'</span>,<span class="keyword">...</span>
0592                 f,alpha,num_nz_x);
0593         <span class="keyword">end</span>
0594     <span class="keyword">end</span>
0595     
0596     <span class="comment">%----------------------------------------------------------------------</span>
0597     <span class="comment">% adaptive weight selection</span>
0598     <span class="comment">% [modified by Salman Asif @ Georgia Tech June 2012]</span>
0599     <span class="comment">%----------------------------------------------------------------------</span>
0600     <span class="keyword">if</span> adp_wt
0601         <span class="keyword">if</span> exist(<span class="string">'W_new'</span>,<span class="string">'var'</span>)
0602             gamma = find(abs(x)&gt;tau);
0603             ewt_b = length(y)*(norm(x,2)/norm(x,1))^2;
0604             W_old = W_new;
0605             W_new = ones(length(x),1);
0606             <span class="keyword">if</span> tau &lt; 5*final_tau;
0607                 <span class="comment">% [alpha beta epsilon] = weight_param(5,1,x,length(y));</span>
0608                 <span class="comment">% W_new = 1/alpha./(beta*(abs(x))+epsilon);</span>
0609                 
0610                 W_new(gamma) = min([W_old(gamma) 1./abs(x(gamma))/ewt_b],[],2);
0611             <span class="keyword">else</span>
0612                 W_new(gamma) = min([W_old(gamma) 1./abs(x(gamma))/ewt_b],[],2);
0613                 <span class="comment">% W_new(gamma) = W_old(gamma)/2; % 1/2</span>
0614             <span class="keyword">end</span>
0615             psi_function = @(x,tau) <a href="soft.html" class="code" title="function y = soft(x,T)">soft</a>(x,tau*W_new);
0616             phi_function = @(x) sum(abs(W_new.*x));
0617             <span class="comment">% figure(115);</span>
0618             <span class="comment">% subplot(211); plot([true x]);</span>
0619             <span class="comment">% subplot(212); semilogy([W_new]); pause(1);</span>
0620         <span class="keyword">else</span>
0621             W_new = 1;
0622             psi_function = @(x,tau) <a href="soft.html" class="code" title="function y = soft(x,T)">soft</a>(x,tau*W_new);
0623             phi_function = @(x) sum(abs(W_new.*x));
0624         <span class="keyword">end</span>
0625     <span class="keyword">end</span>
0626     
0627     
0628     <span class="comment">% initialization of alpha</span>
0629     <span class="comment">% alpha = 1/max(max(abs(du(:))),max(abs(dv(:))));</span>
0630     <span class="comment">% or just do a dumb initialization</span>
0631     <span class="comment">%alphas(iter) = alpha;</span>
0632     
0633     <span class="comment">% control variable for the outer loop and iteration counter</span>
0634     keep_going = 1;
0635     
0636     <span class="keyword">while</span> keep_going
0637         
0638         <span class="comment">% compute gradient</span>
0639         gradq = AT(resid); numAt = numAt+1;
0640         
0641         <span class="comment">% save current values</span>
0642         prev_x = x;
0643         prev_f = f;
0644         prev_resid = resid;
0645         
0646         
0647         <span class="comment">% computation of step</span>
0648         
0649         cont_inner = 1;
0650         <span class="keyword">while</span> cont_inner
0651             x = psi_function(prev_x - gradq*(1/alpha),tau/alpha);
0652             dx = x - prev_x;
0653             Adx = A(dx); numA = numA+1;
0654             resid = prev_resid + Adx;
0655             f = 0.5*(resid(:)'*resid(:)) + tau * phi_function(x);
0656             <span class="keyword">if</span> enforceMonotone
0657                 f_threshold = prev_f;
0658             <span class="keyword">elseif</span> enforceSafeguard
0659                 f_threshold = max(f_lastM) - 0.5*sigma*alpha*(dx(:)'*dx(:));
0660             <span class="keyword">else</span>
0661                 f_threshold = inf;
0662             <span class="keyword">end</span>
0663             <span class="comment">% f_threshold</span>
0664             
0665             <span class="keyword">if</span> f &lt;= f_threshold
0666                 cont_inner=0;
0667             <span class="keyword">else</span>
0668                 <span class="comment">% not good enough, increase alpha and try again</span>
0669                 alpha = eta*alpha;
0670                 <span class="keyword">if</span> verbose
0671                     fprintf(1,<span class="string">' f=%10.6e, increasing alpha to %6.2e\n'</span>, f, alpha);
0672                 <span class="keyword">end</span>
0673             <span class="keyword">end</span>
0674         <span class="keyword">end</span>   <span class="comment">% of while cont_inner</span>
0675         
0676         <span class="keyword">if</span> enforceSafeguard
0677             <span class="keyword">if</span> length(f_lastM)&lt;M+1
0678                 f_lastM = [f_lastM f];
0679             <span class="keyword">else</span>
0680                 f_lastM = [f_lastM(2:M+1) f];
0681             <span class="keyword">end</span>
0682         <span class="keyword">end</span>
0683         
0684         <span class="comment">% print stuff</span>
0685         <span class="keyword">if</span> verbose
0686             fprintf(1,<span class="string">'t=%4d, obj=%10.6e, alpha=%e  '</span>, iter, f, alpha );
0687         <span class="keyword">end</span>
0688         
0689         <span class="keyword">if</span> bbVariant==1
0690             <span class="comment">% standard BB choice of initial alpha for next step</span>
0691             <span class="keyword">if</span> iterThisCycle==0 | enforceMonotone==1
0692                 dd  = dx(:)'*dx(:);
0693                 dGd = Adx(:)'*Adx(:);
0694                 alpha = min(alphamax,max(alphamin,dGd/(realmin+dd)));
0695             <span class="keyword">end</span>
0696         <span class="keyword">elseif</span> bbVariant==2
0697             <span class="comment">% alternative BB choice of initial alpha for next step</span>
0698             <span class="keyword">if</span> iterThisCycle==0 | enforceMonotone==1
0699                 dd  = dx(:)'*dx(:);
0700                 dGd = Adx(:)'*Adx(:);
0701                 ATAdx=AT(Adx); numAt = numAt+1;
0702                 dGGd = ATAdx(:)'*ATAdx(:);
0703                 alpha = min(alphamax,max(alphamin,dGGd/(realmin+dGd)));
0704             <span class="keyword">end</span>
0705         <span class="keyword">else</span>
0706             <span class="comment">% reduce current alpha to get initial alpha for next step</span>
0707             alpha = alpha * alphaFactor;
0708         <span class="keyword">end</span>
0709         
0710         <span class="comment">% update iteration counts, store results and times</span>
0711         iter=iter+1;
0712         iterThisCycle=mod(iterThisCycle+1,bbCycle);
0713         objective(iter) = f;
0714         times(iter) = cputime-t0;
0715         <span class="comment">% alphas(iter) = alpha;</span>
0716         <span class="keyword">if</span> compute_mse
0717             err = true - x;
0718             mses(iter) = (err(:)'*err(:));
0719         <span class="keyword">end</span>
0720         
0721         <span class="comment">% compute stopping criteria and test for termination</span>
0722         <span class="keyword">switch</span> stopCriterion
0723             <span class="keyword">case</span> 0,
0724                 <span class="comment">% compute the stopping criterion based on the change</span>
0725                 <span class="comment">% of the number of non-zero components of the estimate</span>
0726                 nz_x_prev = nz_x;
0727                 nz_x = (abs(x)~=0.0);
0728                 num_nz_x = sum(nz_x(:));
0729                 num_changes_active = (sum(nz_x(:)~=nz_x_prev(:)));
0730                 <span class="keyword">if</span> num_nz_x &gt;= 1
0731                     criterionActiveSet = num_changes_active / num_nz_x;
0732                     keep_going = (criterionActiveSet &gt; tolA);
0733                 <span class="keyword">end</span>
0734                 <span class="keyword">if</span> verbose
0735                     fprintf(1,<span class="string">'Delta nz = %d (target = %e)\n'</span>,<span class="keyword">...</span>
0736                         criterionActiveSet , tolA)
0737                 <span class="keyword">end</span>
0738             <span class="keyword">case</span> 1,
0739                 <span class="comment">% compute the stopping criterion based on the relative</span>
0740                 <span class="comment">% variation of the objective function.</span>
0741                 criterionObjective = abs(f-prev_f)/(prev_f);
0742                 keep_going =  (criterionObjective &gt; tolA);
0743                 <span class="keyword">if</span> verbose
0744                     fprintf(1,<span class="string">'Delta obj. = %e (target = %e)\n'</span>,<span class="keyword">...</span>
0745                         criterionObjective , tolA)
0746                 <span class="keyword">end</span>
0747             <span class="keyword">case</span> 2,
0748                 <span class="comment">% compute the &quot;duality&quot; stopping criterion - actually based on the</span>
0749                 <span class="comment">% iterate PRIOR to the step just taken. Make it relative to the primal</span>
0750                 <span class="comment">% function value.</span>
0751                 scaleFactor = norm(gradq(:)./W_new,inf);
0752                 w = tau.*prev_resid(:) / scaleFactor;
0753                 criterionDuality = 0.5* (prev_resid(:)'*prev_resid(:)) + <span class="keyword">...</span>
0754                     tau * phi_function(prev_x) + 0.5*w(:)'*w(:) + y(:)'*w(:);
0755                 criterionDuality = criterionDuality / prev_f;
0756                 keep_going = (criterionDuality &gt; tolA);
0757                 <span class="keyword">if</span> verbose
0758                     fprintf(1,<span class="string">'Duality = %e (target = %e)\n'</span>,<span class="keyword">...</span>
0759                         criterionDuality , tolA)
0760                 <span class="keyword">end</span>
0761             <span class="keyword">case</span> 3,
0762                 <span class="comment">% compute the &quot;LCP&quot; stopping criterion - again based on the previous</span>
0763                 <span class="comment">% iterate. Make it &quot;relative&quot; to the norm of x.</span>
0764                 w = [ min(tau.*W_new + gradq(:), max(prev_x(:),0.0)); <span class="keyword">...</span>
0765                     min(tau.*W_new - gradq(:), max(-prev_x(:),0.0))];
0766                 criterionLCP = norm(w(:), inf);
0767                 criterionLCP = criterionLCP / max(1.0e-6, norm(prev_x(:),inf));
0768                 keep_going = (criterionLCP &gt; tolA);
0769                 <span class="keyword">if</span> verbose
0770                     fprintf(1,<span class="string">'LCP = %e (target = %e)\n'</span>,criterionLCP,tolA)
0771                 <span class="keyword">end</span>
0772             <span class="keyword">case</span> 4,
0773                 <span class="comment">% continue if not yeat reached target value tolA</span>
0774                 keep_going = (f &gt; tolA);
0775                 <span class="keyword">if</span> verbose
0776                     fprintf(1,<span class="string">'Objective = %e (target = %e)\n'</span>,f,tolA)
0777                 <span class="keyword">end</span>
0778             <span class="keyword">case</span> 5,
0779                 <span class="comment">% stopping criterion based on relative norm of step taken</span>
0780                 delta_x_criterion = sqrt(dx(:)'*dx(:))/(x(:)'*x(:));
0781                 keep_going = (delta_x_criterion &gt; tolA);
0782                 <span class="keyword">if</span> verbose
0783                     fprintf(1,<span class="string">'Norm(delta x)/norm(x) = %e (target = %e)\n'</span>,<span class="keyword">...</span>
0784                         delta_x_criterion,tolA)
0785                 <span class="keyword">end</span>
0786             <span class="keyword">otherwise</span>,
0787                 error([<span class="string">'Unknown stopping criterion'</span>]);
0788         <span class="keyword">end</span> <span class="comment">% end of the stopping criteria switch</span>
0789         
0790         <span class="comment">% overrule the stopping decision to ensure we take between miniter and</span>
0791         <span class="comment">% maxiter iterations</span>
0792         <span class="keyword">if</span> iter&lt;=miniter
0793             <span class="comment">% take no fewer than miniter...</span>
0794             keep_going = 1;
0795         <span class="keyword">elseif</span> iter &gt; maxiter
0796             <span class="comment">% and no more than maxiter iterations</span>
0797             keep_going = 0;
0798         <span class="keyword">end</span>
0799         
0800     <span class="keyword">end</span> <span class="comment">% end of the main loop of the GPBB algorithm (while keep_going)</span>
0801     
0802     cont_loop = cont_loop + 1;
0803     
0804 <span class="keyword">end</span> <span class="comment">% end of the continuation loop (while keep_continuation)</span>
0805 
0806 <span class="comment">% Print results</span>
0807 <span class="keyword">if</span> verbose
0808     fprintf(1,<span class="string">'\nFinished the main algorithm!  Results:\n'</span>)
0809     fprintf(1,<span class="string">'Number of iterations = %d\n'</span>,iter)
0810     fprintf(1,<span class="string">'0.5*||A x - y ||_2^2 = %10.3e\n'</span>,0.5*resid(:)'*resid(:))
0811     fprintf(1,<span class="string">'tau * Penalty = %10.3e\n'</span>,tau * phi_function(x))
0812     fprintf(1,<span class="string">'Objective function = %10.3e\n'</span>,f);
0813     fprintf(1,<span class="string">'Number of non-zero components = %d\n'</span>,sum(x(:)~=0));
0814     fprintf(1,<span class="string">'CPU time so far = %10.3e\n'</span>, times(iter));
0815     fprintf(1,<span class="string">'\n'</span>);
0816 <span class="keyword">end</span>
0817 
0818 <span class="comment">% If the 'Debias' option is set to 1, we try to</span>
0819 <span class="comment">% remove the bias from the l1 penalty, by applying CG to the</span>
0820 <span class="comment">% least-squares problem obtained by omitting the l1 term</span>
0821 <span class="comment">% and fixing the zero coefficients at zero.</span>
0822 
0823 <span class="keyword">if</span> (debias &amp; (sum(x(:)~=0)~=0))
0824     <span class="keyword">if</span> verbose
0825         fprintf(1,<span class="string">'\nStarting the debiasing phase...\n\n'</span>)
0826     <span class="keyword">end</span>
0827     
0828     x_debias = x;
0829     zeroind = (x_debias~=0);
0830     cont_debias_cg = 1;
0831     debias_start = iter;
0832     
0833     <span class="comment">% calculate initial residual</span>
0834     resid = A(x_debias); numA = numA+1;
0835     resid = resid-y;
0836     prev_resid = eps*ones(size(resid));
0837     
0838     rvec = AT(resid); numAt = numAt+1;
0839     
0840     <span class="comment">% mask out the zeros</span>
0841     rvec = rvec .* zeroind;
0842     rTr_cg = rvec(:)'*rvec(:);
0843     
0844     <span class="comment">% set convergence threshold for the residual || RW x_debias - y ||_2</span>
0845     tol_debias = tolD * (rvec(:)'*rvec(:));
0846     
0847     <span class="comment">% initialize pvec</span>
0848     pvec = -rvec;
0849     
0850     <span class="comment">% main loop</span>
0851     <span class="keyword">while</span> cont_debias_cg
0852         
0853         <span class="comment">% calculate A*p = Wt * Rt * R * W * pvec</span>
0854         RWpvec = A(pvec);      numA = numA+1;
0855         Apvec = AT(RWpvec);     numAt = numAt+1;
0856         
0857         <span class="comment">% mask out the zero terms</span>
0858         Apvec = Apvec .* zeroind;
0859         
0860         <span class="comment">% calculate alpha for CG</span>
0861         alpha_cg = rTr_cg / (pvec(:)'* Apvec(:));
0862         
0863         <span class="comment">% take the step</span>
0864         x_debias = x_debias + alpha_cg * pvec;
0865         resid = resid + alpha_cg * RWpvec;
0866         rvec  = rvec  + alpha_cg * Apvec;
0867         
0868         rTr_cg_plus = rvec(:)'*rvec(:);
0869         beta_cg = rTr_cg_plus / rTr_cg;
0870         pvec = -rvec + beta_cg * pvec;
0871         
0872         rTr_cg = rTr_cg_plus;
0873         
0874         iter = iter+1;
0875         
0876         objective(iter) = 0.5*(resid(:)'*resid(:)) + <span class="keyword">...</span>
0877             tau * phi_function(x_debias(:));
0878         times(iter) = cputime - t0;
0879         
0880         <span class="keyword">if</span> compute_mse
0881             err = true - x_debias;
0882             mses(iter) = (err(:)'*err(:));
0883         <span class="keyword">end</span>
0884         
0885         <span class="comment">% in the debiasing CG phase, always use convergence criterion</span>
0886         <span class="comment">% based on the residual (this is standard for CG)</span>
0887         <span class="keyword">if</span> verbose
0888             fprintf(1,<span class="string">'t = %5d, debias resid = %13.8e, convergence = %8.3e\n'</span>, <span class="keyword">...</span>
0889                 iter, resid(:)'*resid(:), rTr_cg / tol_debias);
0890         <span class="keyword">end</span>
0891         cont_debias_cg = <span class="keyword">...</span>
0892             (iter-debias_start &lt;= miniter_debias )| <span class="keyword">...</span>
0893             ((rTr_cg &gt; tol_debias) &amp; <span class="keyword">...</span>
0894             (iter-debias_start &lt;= maxiter_debias));
0895         
0896     <span class="keyword">end</span>
0897     <span class="keyword">if</span> verbose
0898         fprintf(1,<span class="string">'\nFinished the debiasing phase! Results:\n'</span>)
0899         fprintf(1,<span class="string">'Final number of iterations = %d\n'</span>,iter);
0900         fprintf(1,<span class="string">'0.5*||A x - y ||_2 = %10.3e\n'</span>,0.5*resid(:)'*resid(:))
0901         fprintf(1,<span class="string">'tau * penalty = %10.3e\n'</span>,tau * phi_function(x))
0902         fprintf(1,<span class="string">'Objective function = %10.3e\n'</span>,f);
0903         fprintf(1,<span class="string">'Number of non-zero components = %d\n'</span>,<span class="keyword">...</span>
0904             sum((x_debias(:)~=0.0)));
0905         fprintf(1,<span class="string">'CPU time so far = %10.3e\n'</span>, times(iter));
0906         fprintf(1,<span class="string">'\n'</span>);
0907     <span class="keyword">end</span>
0908 <span class="keyword">end</span>
0909 
0910 <span class="keyword">if</span> compute_mse
0911     mses = mses/length(true(:));
0912 <span class="keyword">end</span>
0913</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
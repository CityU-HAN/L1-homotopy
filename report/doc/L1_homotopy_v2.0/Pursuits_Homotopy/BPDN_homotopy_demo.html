<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of BPDN_homotopy_demo</title>
  <meta name="keywords" content="BPDN_homotopy_demo">
  <meta name="description" content="BPDN_homotopy_demo.m">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html Pursuits_Homotopy -->
<h1>BPDN_homotopy_demo
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>BPDN_homotopy_demo.m</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> BPDN_homotopy_demo.m
 
 Solves the following basis pursuit denoising problem
 min_x  \epsilon ||x||_1 + 1/2*||y-Ax||_2^2

 This script is a modified version of PD_pursuit method which
 uses only Primal update in PD_pursuit method.

 Here support of primal and dual vectors remain same at every step.
 The update direction here can be considered as equivalent to dual in Dantzig
 selector.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="update_inverse.html" class="code" title="function iAtB = update_inverse(AtB, iAtB_old,flag);">update_inverse</a>	function iAtB_mod = update_inverse(AtB, Atb, atB, atb);</li><li><a href="update_primal.html" class="code" title="function [i_delta, out_x, delta, chk_x] = update_primal(gamma_x, gamma_lambda, z_x, x_k, del_x_vec, pk, dk, epsilon, out_lambda);">update_primal</a>	update_primal.m</li><li><a href="../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% BPDN_homotopy_demo.m</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Solves the following basis pursuit denoising problem</span>
0004 <span class="comment">% min_x  \epsilon ||x||_1 + 1/2*||y-Ax||_2^2</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% This script is a modified version of PD_pursuit method which</span>
0007 <span class="comment">% uses only Primal update in PD_pursuit method.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Here support of primal and dual vectors remain same at every step.</span>
0010 <span class="comment">% The update direction here can be considered as equivalent to dual in Dantzig</span>
0011 <span class="comment">% selector.</span>
0012 
0013 <span class="comment">% In S-step solution property (for noiseless case) this becomes more clear when,</span>
0014 <span class="comment">% if primal update direction and dual vector match at every step</span>
0015 <span class="comment">% (maybe opposite in sign, depending on the formulation) then</span>
0016 <span class="comment">% homotopy path taken by BPDN and Dantzig selector is exactly same.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0019 <span class="comment">% Email: sasif@gatech.edu</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%-------------------------------------------+</span>
0022 <span class="comment">% Copyright (c) 2008.  Muhammad Salman Asif</span>
0023 <span class="comment">%-------------------------------------------+</span>
0024 
0025 clear; close all
0026 
0027 rseed = 0;
0028 rand(<span class="string">'state'</span>,rseed);
0029 randn(<span class="string">'state'</span>,rseed);
0030 
0031 N = 512;   <span class="comment">% signal length</span>
0032 T = 50;    <span class="comment">% sparsity level</span>
0033 M = 250;    <span class="comment">% no. of measurements</span>
0034 
0035 <span class="comment">% Generate a random signal</span>
0036 x = zeros(N,1);
0037 q = randperm(N);
0038 x(q(1:T)) = sign(randn(T,1));
0039 
0040 <span class="comment">% measurement matrix</span>
0041 A = randn(M,N)/sqrt(M); <span class="comment">% Gaussian</span>
0042 
0043 <span class="comment">% Hadamard</span>
0044 <span class="comment">% H = hadamard(N);</span>
0045 <span class="comment">% A = H(q(1:M),:)/sqrt(M);</span>
0046 
0047 <span class="comment">% Bernoulli</span>
0048 <span class="comment">% A = randsrc(M,N)/sqrt(M);</span>
0049 
0050 <span class="comment">% Random Projection</span>
0051 <span class="comment">% A = orth(A')';</span>
0052 
0053 <span class="comment">% AtA = A'*A;</span>
0054 
0055 <span class="comment">% measurements</span>
0056 SNR = inf;
0057 s = A*x;
0058 sigma = sqrt((norm(s)^2/(10^(SNR/10)))/M);
0059 <span class="comment">% sigma = 0.01;</span>
0060 e = randn(M,1)*sigma;
0061 y = A*x+e;
0062 thresh = 1e-3; <span class="comment">%sqrt(2*log(N))*sigma;</span>
0063 
0064 <span class="comment">% Initialization of primal and dual sign and support</span>
0065 z_x = zeros(N,1);
0066 z_lambda = zeros(N,1);
0067 gamma_lambda = [];  <span class="comment">% Dual support</span>
0068 gamma_x = [];       <span class="comment">% Primal support</span>
0069 
0070 <span class="comment">% Initial step</span>
0071 Primal_constrk = -A'*y; 
0072 [c i] = max(abs(Primal_constrk));
0073 
0074 gamma_lambdak = i;
0075 gamma_xk = gamma_lambdak;
0076 
0077 z_lambda(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak));
0078 epsilon = c;
0079 Primal_constrk(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak))*epsilon;
0080 xk_1 = zeros(N,1);
0081 
0082 lambdak_1 = zeros(N,1);
0083 lambdak_1(gamma_lambdak) = inv(A(:,gamma_lambdak)'*A(:,gamma_lambdak))*z_lambda(gamma_lambdak);
0084 
0085 Dual_constrk = A'*(A*lambdak_1);
0086 
0087 z_x(gamma_xk) = -sign(Dual_constrk(gamma_xk));
0088 Dual_constrk(gamma_xk) = sign(Dual_constrk(gamma_xk));
0089 
0090 z_xk = z_x;
0091 z_lambdak = z_lambda;
0092 
0093 <span class="comment">% loop parameters</span>
0094 done = 0;
0095 iter = 0;
0096 data_precision = eps;   <span class="comment">% floating point precision</span>
0097 
0098 old_delta = 0;
0099 out_lambda = [];
0100 out_x = [];
0101 count_delta_stop = 0;
0102 
0103 <span class="comment">% Turn the plots on and off</span>
0104 constraint_plots = 1; <span class="comment">% 1 - draw the plots after every homotopy iteration.</span>
0105 
0106 AtglAgx = A(:,gamma_lambdak)'*A(:,gamma_xk);
0107 iAtglAgx = inv(A(:,gamma_lambdak)'*A(:,gamma_xk));
0108 AtgxAgl = AtglAgx';
0109 iAtgxAgl = iAtglAgx';
0110 
0111 <span class="keyword">while</span> ~done
0112     iter = iter+1;
0113     <span class="comment">% warning('off','MATLAB:divideByZero')</span>
0114 
0115     gamma_x = gamma_xk;
0116     gamma_lambda = gamma_lambdak;
0117     z_lambda = z_lambdak;
0118     z_x = z_xk;
0119     x_k = xk_1;
0120     lambda_k = lambdak_1;
0121 
0122     <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0123     <span class="comment">%%%% update on x %%%%</span>
0124     <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0125 
0126     <span class="comment">% Update direction</span>
0127 <span class="comment">%     del_x = -inv(A(:,gamma_lambda)'*A(:,gamma_x))*z_lambda(gamma_lambda);</span>
0128 <span class="comment">%     diff_inv = [ max(max(abs(inv(A(:,gamma_lambda)'*A(:,gamma_x))-iAtglAgx)))]</span>
0129 <span class="comment">%     if diff_inv &gt; 1e-8</span>
0130 <span class="comment">%         stp =1;</span>
0131 <span class="comment">%     end</span>
0132     del_x = -iAtglAgx*z_lambda(gamma_lambda);
0133     del_x_vec = zeros(N,1);
0134     del_x_vec(gamma_x) = del_x;
0135 
0136     pk = Primal_constrk;
0137     <span class="comment">% dk = AtA*del_x_vec;</span>
0138     dk = A'*(A(:,gamma_x)*del_x);
0139     
0140     <span class="comment">%%% CONTROL THE MACHINE PRECISION ERROR AT EVERY OPERATION: LIKE BELOW.</span>
0141     pk_temp = Primal_constrk;
0142     gammaL_temp = find(abs(abs(Primal_constrk)-epsilon)&lt;min(epsilon,1e-12));
0143     pk_temp(gammaL_temp) = sign(Primal_constrk(gammaL_temp))*epsilon;
0144     
0145     xk_temp = x_k;
0146     gammaX_temp = find(abs(x_k)&lt;1*eps);
0147     xk_temp(gammaX_temp) = 0;
0148     <span class="comment">%%%---</span>
0149     
0150     <span class="comment">% Compute the step size</span>
0151     [i_delta, out_x, delta, chk_x] = <a href="update_primal.html" class="code" title="function [i_delta, out_x, delta, chk_x] = update_primal(gamma_x, gamma_lambda, z_x, x_k, del_x_vec, pk, dk, epsilon, out_lambda);">update_primal</a>(gamma_x, gamma_lambda, z_x,  xk_temp, del_x_vec, pk_temp, dk, epsilon, out_lambda);
0152     
0153     <span class="keyword">if</span> old_delta &lt; 4*eps &amp; delta &lt; 4*eps
0154         count_delta_stop = count_delta_stop + 1;
0155     <span class="keyword">else</span>
0156         count_delta_stop = 0;
0157     <span class="keyword">end</span>
0158     <span class="keyword">if</span> count_delta_stop &gt;= 50
0159         disp(<span class="string">'stuck in some corner'</span>);
0160         <span class="keyword">break</span>;
0161     <span class="keyword">end</span>
0162     old_delta = delta;
0163 
0164     xk_1 = x_k+delta*del_x_vec;
0165     Primal_constrk = pk+delta*dk;
0166     epsilon_old = epsilon;
0167     epsilon = epsilon-delta;
0168     
0169     <span class="keyword">if</span> epsilon &lt; thresh; <span class="comment">%sqrt(2*log(N))*sigma; %1e-7 %|| iter &gt; 5*T || (length(gamma_lambda) == K)</span>
0170         delta_end = epsilon_old-thresh;
0171         Primal_constrk = pk+delta_end*dk;
0172         xk_1 = x_k + delta_end*del_x_vec;
0173         disp(<span class="string">'done!'</span>);
0174         <span class="keyword">break</span>;
0175     <span class="keyword">end</span>
0176     
0177     <span class="keyword">if</span> length(gamma_x)==M &amp; chk_x ==0
0178         stp =1;
0179         disp(<span class="string">'Cannot do it Sire'</span>); <span class="comment">% Commondos: are you out of your mind Sire!</span>
0180         <span class="keyword">break</span>;
0181     <span class="keyword">end</span>
0182 
0183     <span class="keyword">if</span> chk_x == 1
0184         <span class="comment">% If an element is removed from gamma_x</span>
0185         gl_old = gamma_lambda;
0186         gx_old = gamma_x;
0187 
0188         outx_index = find(gamma_x==out_x);
0189         gamma_x(outx_index) = gamma_x(end);
0190         gamma_x(end) = out_x;
0191         gamma_x = gamma_x(1:end-1);
0192 
0193         outl_index = outx_index;
0194         gamma_lambda = gamma_x;
0195         gamma_lambdak = gamma_lambda;
0196         gamma_xk = gamma_x;
0197 
0198         rowi = outx_index; <span class="comment">% ith row of A is swapped with last row (out_x)</span>
0199         colj = outl_index; <span class="comment">% jth column of A is swapped with last column (out_lambda)</span>
0200         AtgxAgl_ij = AtgxAgl;
0201         temp_row = AtgxAgl_ij(rowi,:);
0202         AtgxAgl_ij(rowi,:) = AtgxAgl_ij(<span class="keyword">end</span>,:);
0203         AtgxAgl_ij(<span class="keyword">end</span>,:) = temp_row;
0204         temp_col = AtgxAgl_ij(:,colj);
0205         AtgxAgl_ij(:,colj) = AtgxAgl_ij(:,end);
0206         AtgxAgl_ij(:,end) = temp_col;
0207         iAtgxAgl_ij = iAtgxAgl;
0208         temp_row = iAtgxAgl_ij(colj,:);
0209         iAtgxAgl_ij(colj,:) = iAtgxAgl_ij(<span class="keyword">end</span>,:);
0210         iAtgxAgl_ij(<span class="keyword">end</span>,:) = temp_row;
0211         temp_col = iAtgxAgl_ij(:,rowi);
0212         iAtgxAgl_ij(:,rowi) = iAtgxAgl_ij(:,end);
0213         iAtgxAgl_ij(:,end) = temp_col;
0214 
0215         AtgxAgl = AtgxAgl_ij(1:end-1,1:end-1);
0216         AtglAgx = AtgxAgl;
0217         iAtgxAgl = <a href="update_inverse.html" class="code" title="function iAtB = update_inverse(AtB, iAtB_old,flag);">update_inverse</a>(AtgxAgl_ij, iAtgxAgl_ij,2);
0218         iAtglAgx = iAtgxAgl;
0219         xk_1(out_x) = 0;
0220     <span class="keyword">else</span>
0221         <span class="comment">% If an element is added to gamma_x</span>
0222         gamma_lambdak = [gamma_lambda; i_delta];
0223         gamma_xk = gamma_lambdak;
0224         i_theta = i_delta;
0225         new_lambda = i_delta;
0226         AtgxAnl = A(:,gamma_x)'*A(:,new_lambda);
0227         AtglAgx_mod = [AtglAgx A(:,gamma_lambda)'*A(:,i_theta); AtgxAnl' A(:,new_lambda)'*A(:,i_theta)];
0228 
0229         AtglAgx = AtglAgx_mod;
0230         AtgxAgl = AtglAgx;
0231         iAtglAgx = <a href="update_inverse.html" class="code" title="function iAtB = update_inverse(AtB, iAtB_old,flag);">update_inverse</a>(AtglAgx, iAtglAgx,1);
0232         iAtgxAgl = iAtglAgx;
0233         xk_1(i_theta) = 0;
0234     <span class="keyword">end</span>
0235 
0236     z_lambdak = zeros(N,1);
0237     z_lambdak(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak));
0238     z_xk = -z_lambdak;
0239     Primal_constrk(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak))*epsilon;
0240     
0241     <span class="keyword">if</span> iter &gt; 500*T
0242         disp(<span class="string">'too many iterations ooooooooops'</span>);
0243         <span class="keyword">break</span>;
0244     <span class="keyword">end</span>
0245 
0246     <span class="keyword">if</span> constraint_plots
0247         <a href="../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a> = figure(1);
0248         subplot(2,1,1)
0249         hold off
0250         plot(pk,<span class="string">'.r'</span>, <span class="string">'MarkerSize'</span>,14);
0251         hold on;
0252         plot(Primal_constrk, <span class="string">'LineWidth'</span>,1);
0253 
0254         <span class="keyword">if</span> chk_x == 0
0255             plot(new_lambda, Primal_constrk(new_lambda),<span class="string">'or'</span>,<span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0256             text(new_lambda, Primal_constrk(new_lambda)*1.1, [<span class="string">'Incoming \gamma = '</span>,num2str(new_lambda)],<span class="string">'FontSize'</span>,14);
0257         <span class="keyword">else</span>
0258             plot(out_x, Primal_constrk(out_x),<span class="string">'*k'</span>,<span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0259             text(out_x,Primal_constrk(out_x)*1.1, [<span class="string">'Outgoing \gamma = '</span>,num2str(out_x)],<span class="string">'FontSize'</span>,14);
0260         <span class="keyword">end</span>
0261         set(gca,<span class="string">'FontSize'</span>,16, <span class="string">'XLim'</span>,[1 N] );
0262         title({<span class="string">'BPDN shrinkage constraints,'</span>; [<span class="string">'n = '</span>,num2str(N), <span class="string">', m = '</span>, num2str(M), <span class="string">', T = '</span>,num2str(T)]});
0263         plot(1:N, epsilon*ones(1,N),<span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0264         plot(1:N, -epsilon*ones(1,N), <span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0265         plot(1:N, epsilon_old*ones(1,N),<span class="string">'--m'</span>,<span class="string">'MarkerSize'</span>,12);
0266         plot(1:N, -epsilon_old*ones(1,N), <span class="string">'--m'</span>,<span class="string">'MarkerSize'</span>,12);
0267 
0268         subplot(2,1,2)
0269         hold off
0270         plot(x_k,<span class="string">'.r'</span>,<span class="string">'MarkerSize'</span>,14); hold on;
0271         plot(xk_1,<span class="string">'LineWidth'</span>,1);
0272         <span class="keyword">if</span> chk_x == 1
0273             plot(out_x, 0,<span class="string">'ok'</span>, <span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0274         <span class="keyword">else</span>
0275             plot(new_lambda, 0,<span class="string">'or'</span>, <span class="string">'MarkerSize'</span>,18,<span class="string">'LineWidth'</span>,2);
0276         <span class="keyword">end</span>
0277         set(gca,<span class="string">'FontSize'</span>,16,<span class="string">'XLim'</span>,[1 N]);
0278         title([<span class="string">'BPDN estimate at \tau = '</span>,num2str(epsilon), <span class="string">', iter = '</span>, num2str(iter)]);
0279         
0280         <span class="keyword">if</span> iter == 1
0281             disp(<span class="string">'  '</span>);
0282             disp(<span class="string">'Every frame in the figure corresponds to a critical point on the homotopy path.'</span>)
0283             disp(<span class="string">'Circle represents an incoming element, star represents an outgoing element.'</span>);
0284             disp(<span class="string">' '</span>);
0285             disp(<span class="string">'Put pause somewhere in the code to see this. '</span>);
0286             disp(<span class="string">'For now press some key to continue...'</span>);
0287             pause
0288         <span class="keyword">end</span>
0289 
0290         <span class="comment">%drawnow;</span>
0291         <span class="comment">%print(gcf,'-dbmp','-r200',['BPDNPath_',num2str(iter)])</span>
0292     <span class="keyword">end</span>
0293     <span class="comment">% pause</span>
0294     [iter epsilon delta]
0295 <span class="keyword">end</span>
0296 
0297 <a href="../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a> = figure(1);
0298 subplot(2,1,1)
0299 hold off
0300 plot(pk,<span class="string">'.r'</span>, <span class="string">'MarkerSize'</span>,14);
0301 hold on;
0302 plot(Primal_constrk, <span class="string">'LineWidth'</span>,1);
0303 
0304 
0305 set(gca,<span class="string">'FontSize'</span>,16, <span class="string">'XLim'</span>,[1 N] );
0306 title({<span class="string">'BPDN shrinkage constraints,'</span>; [<span class="string">'n = '</span>,num2str(N), <span class="string">', m = '</span>, num2str(M), <span class="string">', T = '</span>,num2str(T)]});
0307 plot(1:N, epsilon*ones(1,N),<span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0308 plot(1:N, -epsilon*ones(1,N), <span class="string">'--k'</span>,<span class="string">'MarkerSize'</span>,12);
0309 plot(1:N, epsilon_old*ones(1,N),<span class="string">'--m'</span>,<span class="string">'MarkerSize'</span>,12);
0310 plot(1:N, -epsilon_old*ones(1,N), <span class="string">'--m'</span>,<span class="string">'MarkerSize'</span>,12);
0311 
0312 figure(1);
0313 subplot(2,1,2)
0314 hold off
0315 plot(x,<span class="string">'.r'</span>,<span class="string">'MarkerSize'</span>,14); hold on;
0316 plot(xk_1,<span class="string">'LineWidth'</span>,1);
0317 set(gca,<span class="string">'FontSize'</span>,16,<span class="string">'XLim'</span>,[1 N]);
0318 title([<span class="string">'BPDN estimate at \tau = '</span>,num2str(thresh), <span class="string">', iter = '</span>, num2str(iter)]);</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
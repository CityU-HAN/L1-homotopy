<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of DS_homotopy_function</title>
  <meta name="keywords" content="DS_homotopy_function">
  <meta name="description" content="DS_homotopy_function.m">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html Pursuits_Homotopy -->
<h1>DS_homotopy_function
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>DS_homotopy_function.m</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [xk_1, lambdak_1, gamma_xk, gamma_lambdak, iter, th] = DS_homotopy_function(A, y, thresh, maxiter); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> DS_homotopy_function.m
 
 Solves the following Dantzing selector (DS) problem
 min_x  ||x||_1  subject to  ||A'(Ax-y)||_\infty &lt;= epsilon

 using Primal Dual Pursuit Homotopy method. 

 Usage: 
 [xk_1, lambdak_1, gamma_xk, gamma_lambdak, iter, th] = DS_homotopy_function(A, y, thresh, maxiter);
 
 Inputs: 
 A - MxN measurement matrix.  
 y - Mx1 vector of observations.
 thresh - scalar (desired value of epsilon)
 maxiter - Maximum number of primal-dual iterations.  
           Default = 10*M.
 
 Outputs:
 xk_1 - Final Primal solution
 lambdak_1 - Final Dual solution
 gamma_xk - Primal support at the solution
 gamma_lambdak - Dual support at the solution</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="update_dual.html" class="code" title="function [i_theta, out_lambda, theta, chk_lambda] = update_dual(gamma_x, gamma_lambda, z_lambda, lambda_k, del_lambda_p, ak, bk, new_lambda, out_x);">update_dual</a>	update_dual.m</li><li><a href="update_inverse.html" class="code" title="function iAtB = update_inverse(AtB, iAtB_old,flag);">update_inverse</a>	function iAtB_mod = update_inverse(AtB, Atb, atB, atb);</li><li><a href="update_primal.html" class="code" title="function [i_delta, out_x, delta, chk_x] = update_primal(gamma_x, gamma_lambda, z_x, x_k, del_x_vec, pk, dk, epsilon, out_lambda);">update_primal</a>	update_primal.m</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../L1_homotopy_v2.0/DynamicSeq/DynamicSeq_DS_demo.html" class="code" title="">DynamicSeq_DS_demo</a>	Dantzig selector sequential measurement update homotopy comparison</li><li><a href="../../L1_homotopy_v2.0/DynamicX/DynamicX_DS_demo.html" class="code" title="">DynamicX_DS_demo</a>	Test file for Dantzig selector (DS) update with dynamic change in x</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% DS_homotopy_function.m</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Solves the following Dantzing selector (DS) problem</span>
0004 <span class="comment">% min_x  ||x||_1  subject to  ||A'(Ax-y)||_\infty &lt;= epsilon</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% using Primal Dual Pursuit Homotopy method.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Usage:</span>
0009 <span class="comment">% [xk_1, lambdak_1, gamma_xk, gamma_lambdak, iter, th] = DS_homotopy_function(A, y, thresh, maxiter);</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs:</span>
0012 <span class="comment">% A - MxN measurement matrix.</span>
0013 <span class="comment">% y - Mx1 vector of observations.</span>
0014 <span class="comment">% thresh - scalar (desired value of epsilon)</span>
0015 <span class="comment">% maxiter - Maximum number of primal-dual iterations.</span>
0016 <span class="comment">%           Default = 10*M.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% Outputs:</span>
0019 <span class="comment">% xk_1 - Final Primal solution</span>
0020 <span class="comment">% lambdak_1 - Final Dual solution</span>
0021 <span class="comment">% gamma_xk - Primal support at the solution</span>
0022 <span class="comment">% gamma_lambdak - Dual support at the solution</span>
0023 
0024 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0025 <span class="comment">% Email: sasif@ece.gatech.edu</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%-------------------------------------------+</span>
0028 <span class="comment">% Copyright (c) 2007.  Muhammad Salman Asif</span>
0029 <span class="comment">%-------------------------------------------+</span>
0030 
0031 <a name="_sub0" href="#_subfunctions" class="code">function [xk_1, lambdak_1, gamma_xk, gamma_lambdak, iter, th] = DS_homotopy_function(A, y, thresh, maxiter);</a>
0032 
0033 N = size(A,2);
0034 M = size(A,1);
0035 t0 = cputime;
0036 <span class="keyword">if</span> (nargin &lt; 4), maxiter = 10*M;  <span class="keyword">end</span>
0037 
0038 <span class="comment">% Initialization of primal and dual sign and support</span>
0039 z_x = zeros(N,1);
0040 z_lambda = zeros(N,1);
0041 gamma_lambda = [];  <span class="comment">% Dual support</span>
0042 gamma_x = [];       <span class="comment">% Primal support</span>
0043 
0044 <span class="comment">% Initial step</span>
0045 Primal_constrk = -A'*y;
0046 [c i] = max(abs(Primal_constrk));
0047 
0048 gamma_lambdak = i;
0049 gamma_xk = gamma_lambdak;
0050 
0051 z_lambda(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak));
0052 epsilon = c;
0053 Primal_constrk(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak))*epsilon;
0054 xk_1 = zeros(N,1);
0055 
0056 lambdak_1 = zeros(N,1);
0057 lambdak_1(gamma_lambdak) = inv(A(:,gamma_lambdak)'*A(:,gamma_lambdak))*z_lambda(gamma_lambdak);
0058 
0059 Dual_constrk = A'*(A*lambdak_1);
0060 
0061 z_x(gamma_xk) = -sign(Dual_constrk(gamma_xk));
0062 Dual_constrk(gamma_xk) = sign(Dual_constrk(gamma_xk));
0063 
0064 z_xk = z_x;
0065 z_lambdak = z_lambda;
0066 
0067 <span class="comment">% loop parameters</span>
0068 done = 0;
0069 iter = 0;
0070 data_precision = eps;   <span class="comment">% floating point precision</span>
0071 
0072 old_delta = 0;
0073 out_lambda = [];
0074 out_x = [];
0075 count_delta_stop = 0;
0076 
0077 AtglAgx = A(:,gamma_lambdak)'*A(:,gamma_xk);
0078 iAtglAgx = inv(A(:,gamma_lambdak)'*A(:,gamma_xk));
0079 AtgxAgl = AtglAgx';
0080 iAtgxAgl = iAtglAgx';
0081 
0082 <span class="keyword">while</span> iter &lt; maxiter
0083     iter = iter+1;
0084     <span class="comment">% warning('off','MATLAB:divideByZero')</span>
0085 
0086     gamma_x = gamma_xk;
0087     gamma_lambda = gamma_lambdak;
0088     z_lambda = z_lambdak;
0089     z_x = z_xk;
0090     x_k = xk_1;
0091     lambda_k = lambdak_1;
0092 
0093     <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0094     <span class="comment">%%%% update on x %%%%</span>
0095     <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0096     
0097     <span class="comment">% Update direction</span>
0098     <span class="comment">%del_x = -inv(A(:,gamma_lambda)'*A(:,gamma_x))*z_lambda(gamma_lambda);</span>
0099     del_x = -iAtglAgx*z_lambda(gamma_lambda);
0100     del_x_vec = zeros(N,1);
0101     del_x_vec(gamma_x) = del_x;
0102 
0103     pk = Primal_constrk;
0104     <span class="comment">% dk = AtA*del_x_vec;</span>
0105     Agdelx = A(:,gamma_x)*del_x;
0106     dk = A'*Agdelx;
0107     
0108     <span class="comment">%%% CONTROL THE MACHINE PRECISION ERROR AT EVERY OPERATION: LIKE BELOW.</span>
0109     pk_temp = Primal_constrk;
0110     gammaL_temp = find(abs(abs(Primal_constrk)-epsilon)&lt;min(epsilon,1e-12));
0111     pk_temp(gammaL_temp) = sign(Primal_constrk(gammaL_temp))*epsilon;
0112     
0113     xk_temp = x_k;
0114     gammaX_temp = find(abs(x_k)&lt;1*eps);
0115     xk_temp(gammaX_temp) = 0;
0116     <span class="comment">%%%---</span>
0117     
0118     <span class="comment">% Step size computation</span>
0119     [i_delta, out_x, delta, chk_x] = <a href="update_primal.html" class="code" title="function [i_delta, out_x, delta, chk_x] = update_primal(gamma_x, gamma_lambda, z_x, x_k, del_x_vec, pk, dk, epsilon, out_lambda);">update_primal</a>(gamma_x, gamma_lambda, z_x,  xk_temp, del_x_vec, pk_temp, dk, epsilon, out_lambda);
0120 
0121     <span class="keyword">if</span> old_delta &lt; 4*eps &amp; delta &lt; 4*eps
0122         count_delta_stop = count_delta_stop + 1;
0123     <span class="keyword">else</span>
0124         count_delta_stop = 0;
0125     <span class="keyword">end</span>
0126     <span class="keyword">if</span> count_delta_stop &gt;= 50
0127         disp(<span class="string">'stuck in some corner'</span>);
0128         <span class="keyword">break</span>;
0129     <span class="keyword">end</span>
0130     old_delta = delta;
0131     
0132     xk_1 = x_k+delta*del_x_vec;
0133     Primal_constrk = pk+delta*dk;
0134     epsilon_old = epsilon;
0135     epsilon = epsilon-delta;
0136     <span class="keyword">if</span> epsilon &lt; thresh;
0137         xk_1 = x_k + (epsilon_old-thresh)*del_x_vec;
0138         <span class="keyword">break</span>;
0139     <span class="keyword">end</span>
0140 
0141     <span class="keyword">if</span> chk_x == 1
0142         <span class="comment">% If an element is removed from gamma_x</span>
0143         out_x = out_x(1);
0144         gl_old = gamma_lambda;
0145         gx_old = gamma_x;
0146 
0147         outx_index = find(gamma_x==out_x);
0148         gamma_x(outx_index) = gamma_x(end);
0149         gamma_x(end) = out_x;
0150         gamma_x = gamma_x(1:end-1);
0151 
0152         <span class="comment">%CHECK THIS SINGULARITY CONDITION USING SCHUR COMPLEMENT IDEA !!!</span>
0153         <span class="comment">% X = [A B; C D];</span>
0154         <span class="comment">% detX = detA detS</span>
0155         <span class="comment">% S = D-C A^{-1} B</span>
0156 
0157         <span class="comment">% So the idea here is slightly different, we don't want the last</span>
0158         <span class="comment">% entry (Q22) in the inverse of modified Gram matrix to be zero, because</span>
0159         <span class="comment">% that will make inversion impossible.</span>
0160 
0161         <span class="comment">% This is a better thing, pick the index with maximum absolute</span>
0162         <span class="comment">% value in the column corresponding to out_x in iAtgxgl. This will</span>
0163         <span class="comment">% ensure that new matrix will be invertible.</span>
0164         [max_val outl_index] = max(abs(iAtgxAgl(:,outx_index)));
0165         new_lambda = gamma_lambda(outl_index);
0166         some_lambda = new_lambda;
0167 
0168         outl_index = find(gamma_lambda==some_lambda);
0169         gamma_lambda(outl_index) = gamma_lambda(end);
0170         gamma_lambda(end) = some_lambda;
0171         gamma_lambdak = gamma_lambda;
0172         gamma_lambda = gamma_lambda(1:end-1);
0173 
0174         rowi = outx_index; <span class="comment">% ith row of A is swapped with last row (out_x)</span>
0175         colj = outl_index; <span class="comment">% jth column of A is swapped with last column (out_lambda)</span>
0176         AtgxAgl_ij = AtgxAgl;
0177         temp_row = AtgxAgl_ij(rowi,:);
0178         AtgxAgl_ij(rowi,:) = AtgxAgl_ij(<span class="keyword">end</span>,:);
0179         AtgxAgl_ij(<span class="keyword">end</span>,:) = temp_row;
0180         temp_col = AtgxAgl_ij(:,colj);
0181         AtgxAgl_ij(:,colj) = AtgxAgl_ij(:,end);
0182         AtgxAgl_ij(:,end) = temp_col;
0183         iAtgxAgl_ij = iAtgxAgl;
0184         temp_row = iAtgxAgl_ij(colj,:);
0185         iAtgxAgl_ij(colj,:) = iAtgxAgl_ij(<span class="keyword">end</span>,:);
0186         iAtgxAgl_ij(<span class="keyword">end</span>,:) = temp_row;
0187         temp_col = iAtgxAgl_ij(:,rowi);
0188         iAtgxAgl_ij(:,rowi) = iAtgxAgl_ij(:,end);
0189         iAtgxAgl_ij(:,end) = temp_col;
0190 
0191         AtgxAgl = AtgxAgl_ij(1:end-1,1:end-1);
0192         AtglAgx = AtgxAgl';
0193         iAtgxAgl = <a href="update_inverse.html" class="code" title="function iAtB = update_inverse(AtB, iAtB_old,flag);">update_inverse</a>(AtgxAgl_ij, iAtgxAgl_ij,2);
0194         iAtglAgx = iAtgxAgl';
0195         xk_1(out_x) = 0;
0196     <span class="keyword">else</span>
0197         <span class="comment">% If a new element is added to gamma_lambda</span>
0198         gamma_lambdak = [gamma_lambda; i_delta];
0199         new_lambda = i_delta;
0200         lambda_k(new_lambda) = 0;
0201     <span class="keyword">end</span>
0202 
0203     out_lambda = [];
0204     z_lambdak = zeros(N,1);
0205     z_lambdak(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak));
0206     sgn_new_lambda = sign(Primal_constrk(new_lambda));
0207     Primal_constrk(gamma_lambdak) = sign(Primal_constrk(gamma_lambdak))*epsilon;
0208 
0209 
0210     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%</span>
0211     <span class="comment">%%% update on lambda %%%</span>
0212     <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%</span>
0213     
0214     sgn_new_lambda = sign(Primal_constrk(new_lambda));
0215     
0216     AtgxAnl = A(:,gamma_x)'*A(:,new_lambda);
0217     <span class="comment">%AtgxAnl = AtA(gamma_x,new_lambda);</span>
0218 
0219     <span class="comment">% Update direction</span>
0220     <span class="comment">%del_lambda = -inv(A(:,gamma_x)'*A(:,gamma_lambda))*(A(:,gamma_x)'*A(:,new_lambda));</span>
0221     del_lambda = -iAtgxAgl*AtgxAnl;
0222     del_lambda_p = zeros(N,1);
0223     del_lambda_p(gamma_lambda) = del_lambda*sgn_new_lambda;
0224     del_lambda_p(new_lambda) = 1*sgn_new_lambda;
0225 
0226     ak = Dual_constrk;
0227     <span class="comment">% bk = AtA*del_lambda_p;</span>
0228     Agdel_lam = A(:,[gamma_lambda; new_lambda])*del_lambda_p([gamma_lambda; new_lambda]);
0229     bk = A'*Agdel_lam;
0230 
0231     <span class="comment">% check if the sign of update direction is correct</span>
0232     <span class="keyword">if</span> sign(bk(out_x)) == sign(ak(out_x)) &amp; abs(bk(out_x)) &gt;=eps
0233         bk = -bk;
0234         del_lambda_p = -del_lambda_p;
0235     <span class="keyword">end</span>
0236     
0237     <span class="comment">%%% CONTROL THE MACHINE PRECISION ERROR AT EVERY OPERATION: LIKE BELOW.</span>
0238     ak_temp = Dual_constrk;
0239     gammaX_temp = find(abs(abs(Dual_constrk)-1)&lt;2*eps);
0240     ak_temp(gammaX_temp) = sign(Dual_constrk(gammaX_temp));
0241     
0242     lambdak_temp = lambda_k;
0243     gammaL_temp = find(abs(lambda_k)&lt;1*eps);
0244     lambdak_temp(gammaL_temp) = 0;
0245     <span class="comment">%%%---</span>
0246     
0247     <span class="comment">% Step size computation</span>
0248     [i_theta, out_lambda, theta, chk_lambda] = <a href="update_dual.html" class="code" title="function [i_theta, out_lambda, theta, chk_lambda] = update_dual(gamma_x, gamma_lambda, z_lambda, lambda_k, del_lambda_p, ak, bk, new_lambda, out_x);">update_dual</a>(gamma_x, gamma_lambda, z_lambda, lambdak_temp, del_lambda_p, ak_temp, bk, new_lambda, out_x);
0249 
0250     out_x = [];
0251 
0252     lambdak_1 = lambda_k + theta*del_lambda_p;
0253     Dual_constrk = ak+theta*bk;
0254 
0255     <span class="keyword">if</span> chk_lambda == 1
0256         <span class="comment">% If an element is removed from gamma_lambda</span>
0257         outl_index = find(gamma_lambda==out_lambda);
0258         i_theta = gamma_x(end);
0259 
0260         <span class="keyword">if</span> ~isempty(outl_index) <span class="comment">% because otherwise new_lambda is removed.</span>
0261             <span class="comment">% Use Sherman-Woodburry-Morrison formula</span>
0262             <span class="comment">% (A+BC)^{-1} = A^{-1} - A^{-1}B(I+CA^{-1}B)^{-1}CA^{-1};</span>
0263             iA = iAtgxAgl;
0264             B = AtgxAnl-A(:,gamma_x)'*A(:,out_lambda);
0265             C = zeros(1,length(gamma_lambda));
0266             C(outl_index) = 1;
0267             AtgxAgl(:,outl_index) = AtgxAnl;
0268             AtglAgx = AtgxAgl';
0269 
0270             iAB = iA*B;
0271             CiA = iA(outl_index,:);
0272             iAtgxAgl = iA-iAB*((CiA)/(1+iAB(outl_index)));
0273             iAtglAgx = iAtgxAgl';
0274 
0275             gamma_lambda(outl_index) = new_lambda;
0276         <span class="keyword">end</span>
0277 
0278         z_xk = zeros(N,1);
0279         z_xk(gamma_x) = -sign(Dual_constrk(gamma_x));
0280         lambdak_1(out_lambda) = 0;
0281     <span class="keyword">else</span>
0282         <span class="comment">% If an element is added to gamma_x</span>
0283 
0284         <span class="comment">%%% adding columns</span>
0285         <span class="comment">% AtglAgx_mod = zeros(length(gamma_x));</span>
0286         AtglAgx_mod = [AtglAgx A(:,gamma_lambda)'*A(:,i_theta); AtgxAnl' A(:,new_lambda)'*A(:,i_theta)];
0287         <span class="comment">%AtglAgx_mod = [AtglAgx AtA(gamma_lambda,i_theta); AtgxAnl' AtA(new_lambda,i_theta)];</span>
0288 
0289         <span class="comment">%CHECK THIS SINGULARITY CONDITION USING SCHUR COMPLEMENT IDEA !!!</span>
0290         <span class="comment">% X = [A B; C D];</span>
0291         <span class="comment">% detX = detA detS</span>
0292         <span class="comment">% S = D-C A^{-1} B</span>
0293         A11 = AtglAgx;
0294         A12 = AtglAgx_mod(1:end-1,end);
0295         A21 = AtglAgx_mod(<span class="keyword">end</span>,1:end-1);
0296         A22 = AtglAgx_mod(<span class="keyword">end</span>,end);
0297         S = A22 - A21*(iAtglAgx*A12);
0298         <span class="keyword">if</span> abs(S) &lt; 2*eps
0299             disp(<span class="string">'matrix has become singular'</span>);
0300             <span class="comment">% done = 1;</span>
0301             <span class="comment">% break;</span>
0302         <span class="keyword">end</span>
0303         AtglAgx = AtglAgx_mod;
0304         AtgxAgl = AtglAgx';
0305         iAtglAgx = <a href="update_inverse.html" class="code" title="function iAtB = update_inverse(AtB, iAtB_old,flag);">update_inverse</a>(AtglAgx, iAtglAgx,1);
0306         iAtgxAgl = iAtglAgx';
0307 
0308         out_lambda = [];
0309         gamma_lambda = [gamma_lambda; new_lambda];
0310 
0311         gamma_x = [gamma_x; i_theta];
0312         z_xk = zeros(N,1);
0313         z_xk(gamma_x) = -sign(Dual_constrk(gamma_x));
0314         xk_1(i_theta) = 0;
0315     <span class="keyword">end</span>
0316     Dual_constrk(gamma_x) = sign(Dual_constrk(gamma_x));
0317     gamma_lambdak = gamma_lambda;
0318     gamma_xk = gamma_x;
0319 <span class="keyword">end</span>
0320 th = cputime-t0;</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
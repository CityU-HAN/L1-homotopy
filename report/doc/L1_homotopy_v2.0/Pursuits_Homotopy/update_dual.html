<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of update_dual</title>
  <meta name="keywords" content="update_dual">
  <meta name="description" content="update_dual.m">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html Pursuits_Homotopy -->
<h1>update_dual
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>update_dual.m</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [i_theta, out_lambda, theta, chk_lambda] = update_dual(gamma_x, gamma_lambda, z_lambda, lambda_k, del_lambda_p, ak, bk, new_lambda, out_x); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> update_dual.m

 This function computes the minimum step size in the dual update direction and
 finds change in the primal or dual support with that step.
 
 Inputs: 
 gamma_x - current support of x
 gamma_lambda - current support of lambda
 z_x - sign sequence of x
 z_lambda - sign sequence of lambda
 del_lambda_p - dual update direction
 ak 
 bk
 new_lambda - element entered in the support of lambda during primal update
 out_x - element of x shrunk to zero during primal update phase.

 Outputs: 
 i_theta - index corresponding to newly active dual constraint (new_x)
 out_lambda - element in lambda shrunk to zero
 theta - dual step size 
 chk_lambda - 1  an element is removed from support of lambda
              0  a new element enters the support of x
 
 Written by: Salman Asif, Georgia Tech
 Email: sasif@ece.gatech.edu</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="DS_homotopy_demo.html" class="code" title="">DS_homotopy_demo</a>	DS_homotopy_demo_test.m</li><li><a href="DS_homotopy_function.html" class="code" title="function [xk_1, lambdak_1, gamma_xk, gamma_lambdak, iter, th] = DS_homotopy_function(A, y, thresh, maxiter);">DS_homotopy_function</a>	DS_homotopy_function.m</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% update_dual.m</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% This function computes the minimum step size in the dual update direction and</span>
0004 <span class="comment">% finds change in the primal or dual support with that step.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Inputs:</span>
0007 <span class="comment">% gamma_x - current support of x</span>
0008 <span class="comment">% gamma_lambda - current support of lambda</span>
0009 <span class="comment">% z_x - sign sequence of x</span>
0010 <span class="comment">% z_lambda - sign sequence of lambda</span>
0011 <span class="comment">% del_lambda_p - dual update direction</span>
0012 <span class="comment">% ak</span>
0013 <span class="comment">% bk</span>
0014 <span class="comment">% new_lambda - element entered in the support of lambda during primal update</span>
0015 <span class="comment">% out_x - element of x shrunk to zero during primal update phase.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Outputs:</span>
0018 <span class="comment">% i_theta - index corresponding to newly active dual constraint (new_x)</span>
0019 <span class="comment">% out_lambda - element in lambda shrunk to zero</span>
0020 <span class="comment">% theta - dual step size</span>
0021 <span class="comment">% chk_lambda - 1  an element is removed from support of lambda</span>
0022 <span class="comment">%              0  a new element enters the support of x</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0025 <span class="comment">% Email: sasif@ece.gatech.edu</span>
0026 
0027 <a name="_sub0" href="#_subfunctions" class="code">function [i_theta, out_lambda, theta, chk_lambda] = update_dual(gamma_x, gamma_lambda, z_lambda, lambda_k, del_lambda_p, ak, bk, new_lambda, out_x);</a>
0028 
0029 N = length(lambda_k);
0030 
0031 <span class="comment">% gamma_xc = setdiff([1:N]', [gamma_x; out_x]); WRONG</span>
0032 <span class="comment">% check out_x as well, that is if outgoing x switches sign in just one step</span>
0033 temp_gamma = zeros(N,1);
0034 temp_gamma(gamma_x) = gamma_x;
0035 gamma_xc = find([1:N]' ~= temp_gamma);
0036 
0037 theta1_constr = (1-ak(gamma_xc))./bk(gamma_xc);
0038 theta1_pos_index = find(theta1_constr&gt;0);
0039 theta1_pos = theta1_constr(theta1_pos_index);
0040 [theta1 i_theta1] = min(theta1_pos);
0041 <span class="keyword">if</span> isempty(theta1)
0042     theta1 = inf;
0043 <span class="keyword">end</span>
0044 theta2_constr = -(1+ak(gamma_xc))./bk(gamma_xc);
0045 theta2_pos_index = find(theta2_constr&gt;0);
0046 theta2_pos = theta2_constr(theta2_pos_index);
0047 [theta2 i_theta2] = min(theta2_pos);
0048 <span class="keyword">if</span> isempty(theta2)
0049     theta2 = inf;
0050 <span class="keyword">end</span>
0051 
0052 <span class="keyword">if</span> theta1 &gt; theta2
0053     theta = theta2;
0054     i_theta = gamma_xc(theta2_pos_index(i_theta2));
0055 <span class="keyword">else</span>
0056     theta = theta1;
0057     i_theta = gamma_xc(theta1_pos_index(i_theta1));
0058 <span class="keyword">end</span>
0059 
0060 gamma_lambda_app = [gamma_lambda; new_lambda];
0061 theta3_constr = (-lambda_k(gamma_lambda_app)./del_lambda_p(gamma_lambda_app));
0062 theta3_pos_index = find(theta3_constr&gt;0);
0063 [theta3 i_theta3] = min(theta3_constr(theta3_pos_index));
0064 out_lambda_index = gamma_lambda_app(theta3_pos_index(i_theta3));
0065 
0066 chk_lambda = 0;
0067 out_lambda = [];
0068 <span class="keyword">if</span> theta3 &gt; 0 &amp; theta3&lt;theta
0069     chk_lambda = 1;
0070     theta = theta3;
0071     out_lambda = out_lambda_index;
0072 <span class="keyword">end</span>
0073 
0074 
0075 <span class="comment">%%% THESE ARE PROBABLY UNNECESSARY</span>
0076 <span class="comment">%%% NEED TO REMOVE THEM.</span>
0077 
0078 <span class="comment">% This one is ONLY for those indices which are zero. And we don't know where</span>
0079 <span class="comment">% will its dlambda point in next steps, so after we calculate dlambda and its in opposite</span>
0080 <span class="comment">% direction to z_lambda, we will have to remove that index from the support.</span>
0081 
0082 lambdak_1 = lambda_k+theta*del_lambda_p;
0083 lambdak_1(out_lambda) = 0;
0084 wrong_sign = find(sign(lambdak_1(gamma_lambda)).*z_lambda(gamma_lambda)==-1);
0085 <span class="keyword">if</span> ~isempty(gamma_lambda(wrong_sign))
0086     chk_lambda = 1;
0087     theta = 0;
0088     out_lambda = gamma_lambda(wrong_sign(1));
0089 <span class="keyword">end</span>
0090 
0091 <span class="comment">% The following checks are just to deal with degenerate cases when more</span>
0092 <span class="comment">% than one elements want to enter or leave the support at any step</span>
0093 <span class="comment">% (e.g., Bernoulli matrix with small number of measurements)</span>
0094 
0095 <span class="comment">% This happens if more than one dual constraints become active in one step</span>
0096 <span class="comment">% so some of the new elements in support of x got missed, here we check if</span>
0097 <span class="comment">% they are still active.</span>
0098 i_theta_temp = gamma_xc(find(abs(ak(gamma_xc)+theta*bk(gamma_xc))-1 &gt;= 10*eps));
0099 <span class="keyword">if</span> ~isempty(out_x)
0100     i_theta_more = i_theta_temp(find(i_theta_temp~=out_x));
0101 <span class="keyword">else</span>
0102     i_theta_more = i_theta_temp;
0103 <span class="keyword">end</span>
0104 <span class="keyword">if</span> ~isempty(i_theta_more)
0105     theta = 0;
0106     i_theta = i_theta_more(1);
0107     out_lambda=[];
0108     chk_lambda=0;
0109 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
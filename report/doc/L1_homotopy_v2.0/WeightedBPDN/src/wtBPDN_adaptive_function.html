<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of wtBPDN_adaptive_function</title>
  <meta name="keywords" content="wtBPDN_adaptive_function">
  <meta name="description" content="wtBPDN_adaptive_function">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html L1_homotopy_v2.0 --><!-- ../menu.html WeightedBPDN --><!-- menu.html src -->
<h1>wtBPDN_adaptive_function
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>wtBPDN_adaptive_function</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function out = wtBPDN_adaptive_function(A, y, in) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> wtBPDN_adaptive_function

 Solves the following basis pursuit denoising (BPDN) problem
 min_x  \Sum \tau \e_i |x_i| + 1/2*||y-Ax||_2^2
 where at every homotopy step the e_i corresponding to the incoming element
 is reduced to a very small value (e.g., 1e-6). This way active and
 inactive indices have different values of the regularization parameter.
 The active elements have smaller weight, so they can stay active as long
 as there is no change in sign. The inactive elements have higher weight,
 so they are pushed towards zero. The hope is that, in this adaptive
 procedure, only the true elements will become active and stay active
 along the homotopy path.

 In homotopy, such an adaptive weight selection strategy can be included
 at every step without any additional cost.

 Inputs:
 A - m x n measurement matrix
 y - measurement vector
 in - input structure
   tau - final value of regularization parameter

   shrinkage_mode - (fixed or adaptive weight selection)
       (for more details, see shrinkage_update.m)
           'Tsteps':   active weights are reduced to tau/ewt
           'frac':     active weights are divided by ewt
           'Trwt':     active weights updated as w_i = tau/(beta*x_i)
           'rwt':      ...
           'OLS': set according to LS solution on the active support
               such as w_gamma = 1./abs((A_gamma'*A_gamma)^-1*A_gamma'*y);
               
           &quot;Tsteps&quot; signifies the observation that using Tsteps along with
           a large value of ewt often yields solution in T steps.

   ewt - Selects weight factor for the active elements (Use a large value)
           ewt controls tradeoff b/w speed and accuracy
           higher ewt --&gt; quicker but potentially unstable
           (ewt=1, shrinkage_mode = Tsteps &amp;&amp; shrinkage_flag=2) solves 
           standard LASSO homotopy path

   shrinkage_flag - 0, 1, or 2 (default is 0)
           0 - Instantaneously set active constraints to the &quot;desired&quot;
               value as long as it does not interfere with the active set.
               And if any constraint is violated, take care of that by
               resetting the running value of epsilon
               FAST BUT POTENTIALLY UNSTABLE
           1 - Step size that causes a constraint violation by a member
               of the inactive set
           2 - Gradually change the active constraints, step size takes
               into consideration both sign of elements in the active set
               and constraint violations by the members of inactive set
               (as is the case in standard homotopy)
           3 - FLASH variation???

   maxiter - maximum number of homotopy iterations
   Te - maximum support size allowed
   omp - comparison with OMP
   record - record iteration history
   x_orig - origianl signal for error history
   debias - debias the solution at the end
   early_terminate - terminate early if the support is identified
                   (useful only in high SNR settings)

 Outputs:
 out - output structure
   x_out - output for BPDN
   gamma - support of the solution
   iter - number of homotopy iterations taken by the solver
   time - time taken by the solver
   error_table - error table with iteration record

 Written by: Salman Asif, Georgia Tech
 Email: sasif@gatech.edu

-------------------------------------------+
 Copyright (c) 2012.  M. Salman Asif
-------------------------------------------+</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="shrinkage_update.html" class="code" title="">shrinkage_update</a>	% Shrinkage parameters selection</li><li><a href="../../../L1_homotopy_v2.0/utils/compute_delta.html" class="code" title="function out = compute_delta(in)">compute_delta</a>	</li><li><a href="../../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>	</li><li><a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>	script to ubpdate delx</li><li><a href="../../../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>	script to update support</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="script_rwtBPDN_adaptive.html" class="code" title="function out = script_rwtBPDN_adaptive(in)">script_rwtBPDN_adaptive</a>	BPDN rwt update (initialize with adaptive_wtBPDN)</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% wtBPDN_adaptive_function</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Solves the following basis pursuit denoising (BPDN) problem</span>
0004 <span class="comment">% min_x  \Sum \tau \e_i |x_i| + 1/2*||y-Ax||_2^2</span>
0005 <span class="comment">% where at every homotopy step the e_i corresponding to the incoming element</span>
0006 <span class="comment">% is reduced to a very small value (e.g., 1e-6). This way active and</span>
0007 <span class="comment">% inactive indices have different values of the regularization parameter.</span>
0008 <span class="comment">% The active elements have smaller weight, so they can stay active as long</span>
0009 <span class="comment">% as there is no change in sign. The inactive elements have higher weight,</span>
0010 <span class="comment">% so they are pushed towards zero. The hope is that, in this adaptive</span>
0011 <span class="comment">% procedure, only the true elements will become active and stay active</span>
0012 <span class="comment">% along the homotopy path.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% In homotopy, such an adaptive weight selection strategy can be included</span>
0015 <span class="comment">% at every step without any additional cost.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Inputs:</span>
0018 <span class="comment">% A - m x n measurement matrix</span>
0019 <span class="comment">% y - measurement vector</span>
0020 <span class="comment">% in - input structure</span>
0021 <span class="comment">%   tau - final value of regularization parameter</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%   shrinkage_mode - (fixed or adaptive weight selection)</span>
0024 <span class="comment">%       (for more details, see shrinkage_update.m)</span>
0025 <span class="comment">%           'Tsteps':   active weights are reduced to tau/ewt</span>
0026 <span class="comment">%           'frac':     active weights are divided by ewt</span>
0027 <span class="comment">%           'Trwt':     active weights updated as w_i = tau/(beta*x_i)</span>
0028 <span class="comment">%           'rwt':      ...</span>
0029 <span class="comment">%           'OLS': set according to LS solution on the active support</span>
0030 <span class="comment">%               such as w_gamma = 1./abs((A_gamma'*A_gamma)^-1*A_gamma'*y);</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%           &quot;Tsteps&quot; signifies the observation that using Tsteps along with</span>
0033 <span class="comment">%           a large value of ewt often yields solution in T steps.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%   ewt - Selects weight factor for the active elements (Use a large value)</span>
0036 <span class="comment">%           ewt controls tradeoff b/w speed and accuracy</span>
0037 <span class="comment">%           higher ewt --&gt; quicker but potentially unstable</span>
0038 <span class="comment">%           (ewt=1, shrinkage_mode = Tsteps &amp;&amp; shrinkage_flag=2) solves</span>
0039 <span class="comment">%           standard LASSO homotopy path</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%   shrinkage_flag - 0, 1, or 2 (default is 0)</span>
0042 <span class="comment">%           0 - Instantaneously set active constraints to the &quot;desired&quot;</span>
0043 <span class="comment">%               value as long as it does not interfere with the active set.</span>
0044 <span class="comment">%               And if any constraint is violated, take care of that by</span>
0045 <span class="comment">%               resetting the running value of epsilon</span>
0046 <span class="comment">%               FAST BUT POTENTIALLY UNSTABLE</span>
0047 <span class="comment">%           1 - Step size that causes a constraint violation by a member</span>
0048 <span class="comment">%               of the inactive set</span>
0049 <span class="comment">%           2 - Gradually change the active constraints, step size takes</span>
0050 <span class="comment">%               into consideration both sign of elements in the active set</span>
0051 <span class="comment">%               and constraint violations by the members of inactive set</span>
0052 <span class="comment">%               (as is the case in standard homotopy)</span>
0053 <span class="comment">%           3 - FLASH variation???</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%   maxiter - maximum number of homotopy iterations</span>
0056 <span class="comment">%   Te - maximum support size allowed</span>
0057 <span class="comment">%   omp - comparison with OMP</span>
0058 <span class="comment">%   record - record iteration history</span>
0059 <span class="comment">%   x_orig - origianl signal for error history</span>
0060 <span class="comment">%   debias - debias the solution at the end</span>
0061 <span class="comment">%   early_terminate - terminate early if the support is identified</span>
0062 <span class="comment">%                   (useful only in high SNR settings)</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% Outputs:</span>
0065 <span class="comment">% out - output structure</span>
0066 <span class="comment">%   x_out - output for BPDN</span>
0067 <span class="comment">%   gamma - support of the solution</span>
0068 <span class="comment">%   iter - number of homotopy iterations taken by the solver</span>
0069 <span class="comment">%   time - time taken by the solver</span>
0070 <span class="comment">%   error_table - error table with iteration record</span>
0071 <span class="comment">%</span>
0072 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0073 <span class="comment">% Email: sasif@gatech.edu</span>
0074 <span class="comment">%</span>
0075 <span class="comment">%-------------------------------------------+</span>
0076 <span class="comment">% Copyright (c) 2012.  M. Salman Asif</span>
0077 <span class="comment">%-------------------------------------------+</span>
0078 
0079 <a name="_sub0" href="#_subfunctions" class="code">function out = wtBPDN_adaptive_function(A, y, in)</a>
0080 
0081 N = size(A,2);
0082 M = size(A,1);
0083 
0084 <span class="comment">% Regularization parameters</span>
0085 tau = in.tau;
0086 ewt = in.ewt;
0087 shrinkage_mode = in.shrinkage_mode;
0088 shrinkage_flag = 0;
0089 <span class="keyword">if</span> isfield(in,<span class="string">'shrinkage_flag'</span>)
0090     shrinkage_flag = in.shrinkage_flag;
0091 <span class="keyword">end</span>
0092 
0093 maxiter = in.maxiter;
0094 Te = inf;
0095 <span class="keyword">if</span> isfield(in,<span class="string">'Te'</span>)
0096     Te = in.Te;
0097 <span class="keyword">end</span>
0098 err_record = 0;
0099 <span class="keyword">if</span> isfield(in,<span class="string">'record'</span>);
0100     err_record = in.record;
0101     <span class="keyword">if</span> err_record
0102         x_orig = in.x_orig;
0103     <span class="keyword">end</span>
0104 <span class="keyword">end</span>
0105 omp = 0; <span class="comment">% compare results with OMP</span>
0106 <span class="keyword">if</span> isfield(in,<span class="string">'omp'</span>);
0107     omp = in.omp;
0108 <span class="keyword">end</span>
0109 plots = 0; <span class="comment">% debug plots</span>
0110 <span class="keyword">if</span> isfield(in,<span class="string">'plots'</span>);
0111     plots = in.plots;
0112 <span class="keyword">end</span>
0113 plot_wts = 0; <span class="comment">% plot evolution of weights</span>
0114 <span class="keyword">if</span> isfield(in,<span class="string">'plot_wts'</span>);
0115     plot_wts = in.plot_wts;
0116 <span class="keyword">end</span>
0117 debias = 0;
0118 <span class="keyword">if</span> isfield(in,<span class="string">'debias'</span>)
0119     debias = in.debias;
0120 <span class="keyword">end</span>
0121 early_terminate = 0;
0122 <span class="keyword">if</span> isfield(in,<span class="string">'early_terminate'</span>)
0123     early_terminate = in.early_terminate;
0124 <span class="keyword">end</span>
0125 
0126 t0 = cputime;
0127 
0128 <span class="comment">%% Phase I (support selection)</span>
0129 <span class="comment">% Initial step</span>
0130 z_x = zeros(N,1);
0131 pk_old = -A'*y;
0132 [c idelta] = max(abs(pk_old));
0133 
0134 gamma_xh = idelta;
0135 temp_gamma = zeros(N,1);
0136 temp_gamma(gamma_xh) = gamma_xh;
0137 gamma_xc = find([1:N]' ~= temp_gamma);
0138 
0139 z_x(gamma_xh) = -sign(pk_old(gamma_xh));
0140 epsilon = c;
0141 pk_old(gamma_xh) = sign(pk_old(gamma_xh))*epsilon;
0142 xk_1 = zeros(N,1);
0143 
0144 <span class="comment">%% loop parameters</span>
0145 done = 0;
0146 iter = 0;
0147 rwt_step2 = 0;
0148 
0149 gamma_omp = gamma_xh;
0150 
0151 error_table = [];
0152 <span class="keyword">if</span> err_record
0153     error_table = [epsilon norm(xk_1-x_orig) 1];
0154 <span class="keyword">end</span>
0155 
0156 
0157 <span class="comment">%% (selective support shrinkage)</span>
0158 epsilon_old = epsilon;
0159 Supp_ledger = zeros(N,1);
0160 Supp_ledger(idelta) = 1;
0161 
0162 tau_vec = ones(N,1)*tau; <span class="comment">% Final value of the regularization parameters</span>
0163 epsilon_vec = ones(N,1)*epsilon; <span class="comment">% Running values of the regularization parameters</span>
0164 
0165 <span class="comment">% Update target weights</span>
0166 <a href="shrinkage_update.html" class="code" title="">shrinkage_update</a>
0167 
0168 <span class="comment">% initialize delx</span>
0169 in_delx = [];
0170 delx_mode = in.delx_mode;
0171 rhs = (epsilon_vec-tau_vec).*z_x;
0172 update_mode = <span class="string">'init0'</span>;
0173 <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0174 
0175 <span class="keyword">while</span> iter &lt; maxiter
0176     iter = iter+1;
0177     <span class="comment">% warning('off','MATLAB:divideByZero')</span>
0178     <span class="comment">%% OMP comparison</span>
0179     <span class="keyword">if</span> omp &amp;&amp; iter &lt; M
0180         x_omp = zeros(N,1);
0181         x_omp(gamma_omp) = A(:,gamma_omp)\y;
0182         p_omp = A'*(y-A*x_omp);
0183         gamma_ompC = setdiff([1:N],gamma_omp);
0184         [val_omp, ind_omp] = max(abs(p_omp(gamma_ompC)));
0185         gamma_omp = [gamma_omp; gamma_ompC(ind_omp)];
0186     <span class="keyword">end</span>
0187     
0188     <span class="comment">%% Homotopy</span>
0189     x_k = xk_1;
0190     
0191     <span class="comment">% Update direction</span>
0192     delx_vec = zeros(N,1);
0193     delx_vec(gamma_xh) = delx;
0194     
0195     <span class="keyword">if</span> ~isempty(idelta) &amp;&amp; (sign(delx_vec(idelta)) == sign(pk_old(idelta)) &amp;&amp; abs(x_k(idelta)) == 0)
0196         delta = 0; flag = 0;
0197     <span class="keyword">else</span>
0198         pk = pk_old;
0199         <span class="comment">% dk = AtA*delx_vec;</span>
0200         dk_temp = A*delx_vec;
0201         dk = A'*dk_temp;
0202         
0203         <span class="comment">%%%--- compute step size</span>
0204         in = [];
0205         
0206         <span class="comment">% Setting shrinkage_flag to zero shrinks new active constraint towards the</span>
0207         <span class="comment">% final value instantly if doing so doesn't disturb the active set</span>
0208         in.shrinkage_flag = shrinkage_flag;
0209         in.pk = pk; in.dk = dk;
0210         in.ak = epsilon_vec; in.bk = tau_vec-epsilon_vec;
0211         in.gamma = gamma_xh; in.gamma_c = gamma_xc;
0212         in.delx_vec = delx_vec; in.x = xk_1;
0213         out = <a href="../../../L1_homotopy_v2.0/utils/compute_delta.html" class="code" title="function out = compute_delta(in)">compute_delta</a>(in);
0214         delta = out.delta; idelta = out.idelta;
0215         flag = out.flag;
0216         
0217         <span class="comment">%% FLASH stepsize selection???</span>
0218         <span class="keyword">if</span> shrinkage_flag == 3 &amp;&amp; flag == 1
0219             delta_l = 0.5;
0220             delta_avg = out.delta_in*(1-delta_l)+delta_l; <span class="comment">% Select stpe size as a convex combination of forward selection (FS) and LASSO...</span>
0221             <span class="keyword">if</span> delta_avg &lt; out.delta_out
0222                 delta = delta_avg;
0223                 idelta = out.idelta_in;
0224             <span class="keyword">else</span>
0225                 delta = out.delta_out;
0226                 idelta = out.idelta_out;
0227                 flag = 0;
0228             <span class="keyword">end</span>
0229         <span class="keyword">end</span>
0230         
0231         <span class="keyword">if</span> delta &gt; 1
0232             delta = 1;
0233             flag = 1;
0234         <span class="keyword">end</span>
0235         
0236         xk_1(gamma_xh) = x_k(gamma_xh)+delta*delx_vec(gamma_xh);
0237         pk_old = pk+delta*dk;
0238         
0239         epsilon_vec_old = epsilon_vec;
0240         <span class="comment">% epsilon_vec(gamma_xh) = (1-delta)*epsilon_vec(gamma_xh)+delta*tau_vec(gamma_xh);</span>
0241         epsilon_vec = (1-delta)*epsilon_vec+delta*tau_vec;
0242                 
0243         pk_old(gamma_xh) = sign(pk_old(gamma_xh)).*epsilon_vec(gamma_xh);
0244         
0245         
0246 <span class="comment">%         fig(333); plot(abs([A'*(A(:,gamma_xh)*x_orig(gamma_xh)-y) A'*(A(:,gamma_xh)*xk_1(gamma_xh)-y) tau_vec epsilon_vec]));</span>
0247 <span class="comment">%         pause;</span>
0248         
0249         <span class="comment">% Check convergence criterion (this can be useful)...</span>
0250         <span class="keyword">if</span> early_terminate
0251                 <span class="keyword">if</span> length(gamma_xh) &lt; M/2
0252                     xhat = zeros(N,1);
0253                     <span class="comment">% xhat(gamma_xh) = AtAgx\(A(:,gamma_xh)'*y);</span>
0254                     <span class="keyword">switch</span> delx_mode
0255                         <span class="keyword">case</span> <span class="string">'mil'</span>
0256                             xhat(gamma_xh) = iAtA*(A(:,gamma_xh)'*y);
0257                         <span class="keyword">case</span> <span class="string">'qr'</span>
0258                             xhat(gamma_xh) = R\(R'\(A(:,gamma_xh)'*y));
0259                     <span class="keyword">end</span>
0260                     <span class="keyword">if</span> norm(y-A*xhat) &lt; tau
0261                         xk_1 = xhat;
0262                         <span class="keyword">break</span>;
0263                     <span class="keyword">end</span>
0264                 <span class="keyword">end</span>
0265         <span class="keyword">end</span>
0266         
0267         <span class="keyword">if</span> max(abs(pk_old)) &lt;= tau
0268             <span class="comment">% if you want to solve exactly according to tau, uncomment the</span>
0269             <span class="comment">% following lines:</span>
0270             <span class="comment">%</span>
0271             <span class="comment">% delta_end = epsilon_old-tau;</span>
0272             <span class="comment">% xk_1(gamma_xh) = x_k(gamma_xh)+delta_end*delx_vec(gamma_xh);</span>
0273             <span class="comment">% pk_old = pk+delta_end*dk;</span>
0274             <span class="comment">% epsilon_vec = epsilon_vec_old;</span>
0275             <span class="comment">% epsilon_vec(gamma_xh) = (1-delta_end)*epsilon_vec(gamma_xh)+delta_end*tau_vec(gamma_xh);</span>
0276             
0277             <span class="comment">% disp('epsilon reduce below threshold');</span>
0278             <span class="comment">% fig(303); plot([xk_1(gamma_xh)-(A(:,gamma_xh)'*A(:,gamma_xh))\(A(:,gamma_xh)'*y-epsilon_vec(gamma_xh).*z_x(gamma_xh))])</span>
0279             <span class="keyword">if</span> flag == 0
0280                 outx_index = find(gamma_xh==idelta);
0281                 gamma_xh = [gamma_xh(1:outx_index-1); gamma_xh(outx_index+1:end)];
0282                 
0283                 xk_1(idelta) = 0;
0284                 epsilon_vec(idelta) = epsilon;
0285             <span class="keyword">end</span>
0286             <span class="keyword">break</span>;
0287         <span class="keyword">end</span>
0288         <span class="keyword">if</span> length(gamma_xh) &gt;= Te
0289             total_time = cputime-t0;
0290             <span class="comment">% disp('support size exceeds limit');</span>
0291             <span class="comment">% fig(303); plot([xk_1(gamma_xh) (A(:,gamma_xh)'*A(:,gamma_xh))\(A(:,gamma_xh)'*y-tau*z_x(gamma_xh)) x_orig(gamma_xh)])</span>
0292             <span class="comment">% setxor(gamma_xh,find(abs(x_orig)&gt;0))</span>
0293             <span class="keyword">break</span>;
0294         <span class="keyword">end</span>
0295         
0296         <span class="comment">%% Search for new element</span>
0297         <span class="comment">% The one that violates the constraint</span>
0298         epsilon_old = epsilon;
0299         [epsilon index] = max(abs(pk_old));
0300         <span class="keyword">if</span> flag == 1 &amp;&amp; delta == 1
0301             <span class="keyword">if</span> nnz(index == gamma_xh)
0302                 <span class="comment">% iter = iter-1;</span>
0303                 <a href="shrinkage_update.html" class="code" title="">shrinkage_update</a>;
0304                 z_x = -sign(pk_old);
0305                 rhs = (epsilon_vec-tau_vec).*z_x;
0306                 
0307                 <span class="keyword">switch</span> delx_mode
0308                     <span class="keyword">case</span> <span class="string">'mil'</span>
0309                         delx = iAtA*rhs(gamma_xh);
0310                     <span class="keyword">case</span> <span class="string">'qr'</span>
0311                         delx = R\(R'\rhs(gamma_xh));
0312                 <span class="keyword">end</span>
0313                 <span class="keyword">continue</span>;
0314                 <span class="comment">% because the index already exists in the active set</span>
0315             <span class="keyword">end</span>
0316             idelta = index;
0317             epsilon_vec(idelta) = epsilon;
0318         <span class="keyword">elseif</span> flag == 1
0319             epsilon_vec(idelta) = abs(pk_old(idelta)); <span class="comment">% (1-delta)*epsilon_vec(idelta)+delta*tau_vec(idelta);</span>
0320         <span class="keyword">end</span>
0321     <span class="keyword">end</span>
0322 
0323     <span class="keyword">if</span> err_record
0324         error_table = [error_table; epsilon norm(xk_1-x_orig) length(gamma_xh)];
0325     <span class="keyword">end</span>
0326     
0327     
0328     <span class="comment">% update support</span>
0329     <a href="../../../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>;
0330     
0331     temp_gamma = zeros(N,1);
0332     temp_gamma(gamma_xh) = gamma_xh;
0333     gamma_xc = find([1:N]' ~= temp_gamma);
0334     epsilon_vec(gamma_xc) = epsilon;
0335     <span class="comment">% epsilon_vec(gamma_xc) = max(abs(A'*y));</span>
0336     
0337     <span class="keyword">if</span> flag == 0
0338         Supp_ledge(idelta) = 0;
0339     <span class="keyword">else</span>
0340         Supp_ledger(gamma_xh) = Supp_ledger(gamma_xh)+1;
0341     <span class="keyword">end</span>
0342     
0343     <span class="comment">%% Shrinkage parameters selection</span>
0344     <a href="shrinkage_update.html" class="code" title="">shrinkage_update</a>;
0345     
0346     <span class="comment">% update delx</span>
0347     z_x = -sign(pk_old);
0348     rhs = (epsilon_vec-tau_vec).*z_x;
0349     in_delx.max_rec = 1;
0350     update_mode = <span class="string">'update'</span>;
0351     <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0352     <span class="comment">%     AtAgx = A(:,gamma_xh)'*A(:,gamma_xh);</span>
0353     <span class="comment">%     delx2 =  AtAgx\rhs(gamma_xh);% AtAgx\((epsilon_vec(gamma_xh)-tau_vec(gamma_xh)).*z_x(gamma_xh));</span>
0354     <span class="comment">%     fig(111); plot([delx delx2]);</span>
0355     <span class="comment">%     if norm(delx-delx2) &gt; 1e-5</span>
0356     <span class="comment">%         stp = 1;</span>
0357     <span class="comment">%     end</span>
0358     
0359     <span class="comment">%% debug...</span>
0360     <span class="keyword">if</span> plots
0361         <a href="../../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(101); plot([A'*(A*xk_1-y) pk_old epsilon_vec -epsilon_vec]);
0362         <a href="../../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(102); clf; hold on;
0363         subplot(311); plot([abs(pk_old) epsilon_vec epsilon_vec_old]);
0364         title(sprintf(<span class="string">'iter %d'</span>,iter));
0365         subplot(312); plot(delx_vec);
0366         subplot(313); hold on; stem(x_orig,<span class="string">'Marker'</span>,<span class="string">'.'</span>); plot([x_k xk_1]);
0367         pause(1/60);
0368         
0369         <span class="comment">% fig(303); plot([xk_1(gamma_xh)-(A(:,gamma_xh)'*A(:,gamma_xh))\(A(:,gamma_xh)'*y-epsilon_vec(gamma_xh).*z_x(gamma_xh))])</span>
0370         <span class="comment">% [pk(gamma_xh) x_k(gamma_xh) pk_old(gamma_xh) xk_1(gamma_xh) x_orig(gamma_xh) gamma_xh]</span>
0371         <span class="keyword">if</span> (max(abs(A'*(A*xk_1-y))-abs(pk_old)) &gt; 1e-8)
0372             disp(<span class="string">'constraints mismatch...'</span>)
0373         <span class="keyword">end</span>
0374     <span class="keyword">end</span>
0375     constr_violation = nnz((abs(pk_old(gamma_xc))-epsilon_vec(gamma_xc))&gt;1e-10);
0376     sign_violation = nnz(abs(sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh)))&gt;1);
0377     <span class="keyword">if</span> constr_violation
0378         chk = gamma_xc((abs(pk_old(gamma_xc))-epsilon_vec(gamma_xc))&gt;1e-10);
0379         stp = 1;
0380         fprintf(<span class="string">'problem... with constraint violation -- %s\n'</span>, mfilename);
0381         fprintf(<span class="string">'Refactorize the matrix... recompute delx \n'</span>);
0382         <span class="comment">% some times it comes here due to bad conditioning of AtAgx.</span>
0383         update_mode = <span class="string">'init0'</span>;
0384         <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0385     <span class="keyword">end</span>
0386     <span class="keyword">if</span> sign_violation&gt;1
0387         chk = gamma_xh(abs(sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh)))&gt;1);
0388         stp = 1;
0389         fprintf(<span class="string">'problem... sign mismatch -- %s\n'</span>,mfilename);
0390         fprintf(<span class="string">'Refactorize the matrix... recompute delx \n'</span>);
0391         update_mode = <span class="string">'init0'</span>;
0392         <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0393     <span class="keyword">end</span>
0394     
0395     <span class="comment">%% Figure to view evolution of weights</span>
0396     <span class="keyword">if</span> plot_wts
0397         <span class="keyword">if</span> mod(iter,10)==1
0398             <span class="keyword">if</span> ~exist(<span class="string">'marker_iter'</span>,<span class="string">'var'</span>)
0399                 weight_marker = {<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'k'</span>,<span class="string">'m'</span>,<span class="string">'g'</span>};
0400                 <a href="../../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(121); clf;
0401                 set(gca,<span class="string">'FontSize'</span>,16);
0402                 semilogy(1:N,epsilon_vec([gamma_xh; gamma_xc]),<span class="string">'Color'</span>,weight_marker{1},<span class="string">'LineWidth'</span>,2);
0403                 marker_iter = 1;
0404                 hold on;
0405                 EPS_VEC = [];
0406             <span class="keyword">else</span>
0407                 marker_iter = mod(marker_iter,length(weight_marker))+1;
0408                 <a href="../../../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(121); semilogy(1:N,epsilon_vec([gamma_xh; gamma_xc]),<span class="string">'Color'</span>,weight_marker{marker_iter},<span class="string">'LineWidth'</span>,2);
0409             <span class="keyword">end</span>
0410             axis tight;
0411             YLim = get(gca,<span class="string">'YLim'</span>);
0412             YLim1 = YLim;
0413             YLim1(1) = YLim(1)-(YLim(2)-YLim(1))*0.1;
0414             YLim1(2) = YLim(2)+(YLim(2)-YLim(1))*0.3;
0415             set(gca,<span class="string">'YLim'</span>,YLim1);
0416             str1 = sprintf(<span class="string">'step %d'</span>,iter);
0417             <span class="comment">% text(iter+5,epsilon*1.2, str1,'FontSize',16);</span>
0418             EPS_VEC = [EPS_VEC epsilon_vec([gamma_xh; gamma_xc])];
0419         <span class="keyword">end</span>
0420     <span class="keyword">end</span>
0421 <span class="keyword">end</span>
0422 
0423 <span class="keyword">if</span> debias
0424     x_out = zeros(N,1);
0425     <span class="keyword">switch</span> delx_mode
0426         <span class="keyword">case</span> <span class="string">'mil'</span>            
0427             x_out(gamma_xh) = iAtA*(A(:,gamma_xh)'*y);
0428         <span class="keyword">case</span> <span class="string">'qr'</span>
0429             x_out(gamma_xh) = R\(R'\(A(:,gamma_xh)'*y));
0430     <span class="keyword">end</span>
0431 <span class="keyword">else</span>
0432     x_out = xk_1;
0433 <span class="keyword">end</span>
0434 
0435 <span class="keyword">if</span> err_record
0436     error_table = [error_table; epsilon norm(x_out-x_orig) length(gamma_xh)];
0437 <span class="keyword">end</span>
0438 total_iter = iter;
0439 total_time = cputime-t0;
0440 
0441 out = [];
0442 out.x_out = x_out;
0443 out.gamma = gamma_xh; <span class="comment">% find(abs(xk_1)&gt;0);</span>
0444 out.iter = total_iter;
0445 out.time = total_time;
0446 out.error_table = error_table;
0447 out.tau_vec = epsilon_vec;
0448 
0449 <span class="comment">% if ~isempty(setxor(gamma_xh,find(abs(x_orig)&gt;0))) || iter &gt; nnz(x_orig)</span>
0450 <span class="comment">%     stp = 1;</span>
0451 <span class="comment">% end</span>
0452 <span class="comment">% fig(303); plot([xk_1(gamma_xh)-(A(:,gamma_xh)'*A(:,gamma_xh))\(A(:,gamma_xh)'*y-tau_vec(gamma_xh).*z_x(gamma_xh))])</span>
0453 <span class="comment">% fig(303); plot([xk_1(gamma_xh) (A(:,gamma_xh)'*A(:,gamma_xh))\(A(:,gamma_xh)'*y-tau_vec(gamma_xh).*z_x(gamma_xh)) x_orig(gamma_xh)])</span></pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
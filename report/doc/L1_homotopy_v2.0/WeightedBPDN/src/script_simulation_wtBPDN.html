<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of script_simulation_wtBPDN</title>
  <meta name="keywords" content="script_simulation_wtBPDN">
  <meta name="description" content="partial script for running different solvers">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html L1_homotopy_v2.0 --><!-- ../menu.html WeightedBPDN --><!-- menu.html src -->
<h1>script_simulation_wtBPDN
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>partial script for running different solvers</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> partial script for running different solvers</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../L1_homotopy_v2.0/Pursuits_Homotopy/BPDN_homotopy_function.html" class="code" title="function out = BPDN_homotopy_function(A, y, in)">BPDN_homotopy_function</a>	BPDN_homotopy_function.m</li><li><a href="script_rwtBPDN_adaptive.html" class="code" title="function out = script_rwtBPDN_adaptive(in)">script_rwtBPDN_adaptive</a>	BPDN rwt update (initialize with adaptive_wtBPDN)</li><li><a href="script_rwtBPDN_iterative.html" class="code" title="function out = script_rwtBPDN_iterative(in);">script_rwtBPDN_iterative</a>	BPDN rwt update (initialize with standard homotopy)</li><li><a href="weight_param.html" class="code" title="function [alpha beta epsilon] = weight_param(rwt_mode,itr,varargin)">weight_param</a>	Compute alpha,beta, and epsilon to update weights as</li><li><a href="../../../L1_homotopy_v2.0/solvers/SpaRSA_adpW.html" class="code" title="function [x,x_debias,objective,times,debias_start,mses,taus, numA, numAt]=SpaRSA_adpW(y,A,tau,varargin)">SpaRSA_adpW</a>	SpaRSA version 2.0, December 31, 2007</li><li><a href="../../../L1_homotopy_v2.0/solvers/soft.html" class="code" title="function y = soft(x,T)">soft</a>	</li><li><a href="../../../L1_homotopy_v2.0/solvers/spgSetParms.html" class="code" title="function options = spgSetParms(varargin)">spgSetParms</a>	SPGSETPARMS  Set options for SPGL1</li><li><a href="../../../L1_homotopy_v2.0/solvers/spgl1.html" class="code" title="function [x,r,g,info] = spgl1( A, b, tau, sigma, x, options )">spgl1</a>	SPGL1  Solve basis pursuit, basis pursuit denoise, and LASSO</li><li><a href="../../../L1_homotopy_v2.0/solvers/yall1.html" class="code" title="function [x, Out] = yall1(A, b, opts)">yall1</a>	</li><li><a href="../../../L1_homotopy_v2.0/utils/OMP_function.html" class="code" title="function out = OMP_function(y,A,in)">OMP_function</a>	</li><li><a href="../../../L1_homotopy_v2.0/utils/genAmat.html" class="code" title="function A = genAmat(M,N,in);">genAmat</a>	</li><li><a href="../../../L1_homotopy_v2.0/utils/genSignal.html" class="code" title="function [x varargout] = genSignal(N,in)">genSignal</a>	Inputs</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../L1_homotopy_v2.0/WeightedBPDN/job_wtBPDN_ALL.html" class="code" title="">job_wtBPDN_ALL</a>	Comparison of various solvers for iterative reweighting and adaptive reweighting</li><li><a href="../../../L1_homotopy_v2.0/WeightedBPDN/job_wtBPDN_WAVE.html" class="code" title="">job_wtBPDN_WAVE</a>	Comparison of various solvers for iterative reweighting and adaptive reweighting</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% partial script for running different solvers</span>
0002 
0003 <span class="comment">%% Main loop</span>
0004 SIM_stack = cell(maxsim,1);
0005 SIM_memory = cell(maxsim,1);
0006 
0007 <span class="keyword">for</span> sim = 1:maxsim
0008     <span class="comment">%% Generate a random signal</span>
0009     in = []; in.type = sType; in.T = T; in.randgen = 1; in.take_fwt = 0;
0010     <span class="keyword">switch</span> sType
0011         <span class="keyword">case</span> <span class="string">'blocks'</span>
0012             in.take_fwt = 1;
0013             in.wType = <span class="string">'haar'</span>;
0014         <span class="keyword">case</span> <span class="string">'heavisine'</span>
0015             in.take_fwt = 1;
0016             in.wType = <span class="string">'daub4'</span>;
0017         <span class="keyword">case</span> <span class="string">'pcwpoly'</span>;
0018             in.take_fwt = 1;
0019             in.wType = <span class="string">'daub8'</span>;
0020     <span class="keyword">end</span>
0021     x = <a href="../../../L1_homotopy_v2.0/utils/genSignal.html" class="code" title="function [x varargout] = genSignal(N,in)">genSignal</a>(N,in);
0022     <span class="comment">% gamma_orig = find(abs(x)&gt;0);</span>
0023     [val ind] = sort(abs(x),<span class="string">'descend'</span>);
0024     ind_pos = ind(val&gt;0);
0025     gamma_orig = ind_pos(1:min(length(ind_pos),M-1));
0026     
0027     <span class="comment">% measurement matrix</span>
0028     in = []; in.type = mType;
0029     A = <a href="../../../L1_homotopy_v2.0/utils/genAmat.html" class="code" title="function A = genAmat(M,N,in);">genAmat</a>(M,N,in);
0030     
0031     <span class="comment">% measurements</span>
0032     sigma = sqrt(norm(A*x)^2/10^(SNR/10)/M);
0033     <span class="comment">%sigma = .05;</span>
0034     e = randn(M,1)*sigma;
0035     y = A*x+e;
0036     
0037     <span class="comment">% % orthogonalize rows of A even if A itself is not orthogonal</span>
0038     <span class="comment">%     [Q, R] = qr(A',0);</span>
0039     <span class="comment">%     A = Q'; y = R' \ y;</span>
0040     
0041     <span class="comment">% parameter selection</span>
0042     <span class="keyword">if</span> lambda &gt; 0
0043         tau = lambda*max(abs(A'*y));
0044     <span class="keyword">else</span>
0045         <span class="comment">% tau = sigma*sqrt(log(N));</span>
0046         tau = max(1e-4*max(abs(A'*y)),sigma*sqrt(log(N)));        
0047     <span class="keyword">end</span>
0048     <span class="comment">% tau = max(lambda*max(abs(A'*y)),sigma*sqrt(log(N)));</span>
0049     
0050     maxiter = 2*N;
0051     
0052     <span class="comment">%% Adaptive support &amp; weight selection</span>
0053     in = [];
0054     in.A = A; in.y = y; in.x = x;
0055     in.x_init = zeros(N,1); in.max_rwt = rwt_adp;
0056     in.tau = tau;
0057     in.rwt_mode = rwt_mode;
0058     in.delx_mode = delx_mode;
0059     in.debias = 0;
0060     in.verbose = 0;
0061     <span class="keyword">if</span> in.verbose
0062         fprintf(<span class="string">'sType-%s, mType-%s, (N,M,T)-%d,%d,%d '</span>,sType,mType,N,M,T);    
0063     <span class="keyword">end</span>
0064     out = <a href="script_rwtBPDN_adaptive.html" class="code" title="function out = script_rwtBPDN_adaptive(in)">script_rwtBPDN_adaptive</a>(in);
0065     xh_adp = out.x_out;
0066     iter_adp = out.iter;
0067     gamma_adp = out.gamma;
0068     W_new = out.W_new;
0069     xh_adp_init = out.x_init;
0070     err_adp = out.err;
0071     time_adp = out.time;
0072     supp_diff_adp = out.supp_diff;
0073     
0074     <span class="comment">%% Iterative reweighted BPDN (IRW-H)</span>
0075     in = [];
0076     in.A = A; in.y = y; in.x = x;
0077     in.x_init = zeros(N,1); in.max_rwt = rwt;
0078     in.tau = tau;
0079     in.rwt_mode = rwt_mode;
0080     in.delx_mode = delx_mode;
0081     out = <a href="script_rwtBPDN_iterative.html" class="code" title="function out = script_rwtBPDN_iterative(in);">script_rwtBPDN_iterative</a>(in);
0082     xh_rwt = out.x_out;
0083     xh_rwt_init = out.x_init;
0084     iter_rwt = out.iter;
0085     gamma_rwt = out.gamma;
0086     err_rwt = out.err;
0087     time_rwt = out.time;
0088     supp_diff_rwt = out.supp_diff;
0089     
0090     <span class="comment">%% Oracle rwt BPDN</span>
0091     alpha = 5; beta = 10;
0092     W_new = ones(N,1); W_new(gamma_orig) = 1/alpha./(beta*abs(x(gamma_orig)));
0093     <span class="comment">% epsilon = 0.1; W_new = 1/alpha./(beta*(abs(x))+epsilon);</span>
0094     
0095     <span class="comment">% To check the accuracy of rwtBPDN_adaptive set</span>
0096     <span class="comment">% W_new = out.W_new/tau;</span>
0097     
0098     in = [];
0099     in.tau = tau;
0100     in.maxiter = maxiter;
0101     in.x_orig = x;
0102     in.record = 1;
0103     in.delx_mode = <span class="string">'mil'</span>;
0104     <span class="comment">%     in.Te = rwt_itr;</span>
0105     AW = A*diag(1./W_new);
0106     tic
0107     out_new = <a href="../../../L1_homotopy_v2.0/Pursuits_Homotopy/BPDN_homotopy_function.html" class="code" title="function out = BPDN_homotopy_function(A, y, in)">BPDN_homotopy_function</a>(AW, y, in); <span class="comment">%BPDN</span>
0108     <span class="comment">% time_orac = out_new.time;</span>
0109     time_orac = toc;
0110     xh_orac = out_new.x_out.*(1./W_new);
0111     gamma_orac = out_new.gamma;
0112     iter_orac = out_new.iter;
0113     
0114     <span class="comment">%% oracle LS</span>
0115     x_LS = zeros(N,1);
0116     x_LS(gamma_orig) = A(:,gamma_orig)\y;
0117     
0118     <span class="comment">%% OMP</span>
0119     in = [];
0120     in.Te = round(1.2*T);
0121     out = <a href="../../../L1_homotopy_v2.0/utils/OMP_function.html" class="code" title="function out = OMP_function(y,A,in)">OMP_function</a>(y,A,in);
0122     x_omp = out.x_out;
0123     iter_omp = out.iter;
0124     gamma_omp = out.gamma;
0125     
0126     <span class="comment">%% FPC_AS</span>
0127     <span class="comment">%     opts = [];</span>
0128     <span class="comment">%     opts.gtol = 1e-6;</span>
0129     <span class="comment">%     opts.xtol = 1e-6;</span>
0130     <span class="comment">%     opts.fullMu = false;</span>
0131     <span class="comment">%     opts.x0 = zeros(N,1);</span>
0132     <span class="comment">%     opts.eta = 4;</span>
0133     <span class="comment">%     opts.mxitr = N;</span>
0134     <span class="comment">%     % opts.PrintOutput = 0;</span>
0135     <span class="comment">%     % opts.f_value_tol = tolA;</span>
0136     <span class="comment">%     % opts.PrintOptions = 0;</span>
0137     <span class="comment">%     % opts.record = -1;</span>
0138     <span class="comment">%     % opts.scale_A = 1;</span>
0139     <span class="comment">%     W_new = ones(N,1);</span>
0140     <span class="comment">%     AW = A;</span>
0141     <span class="comment">%     x_fpc = [];</span>
0142     <span class="comment">%     iter_fpc = [];</span>
0143     <span class="comment">%     err_fpc = [];</span>
0144     <span class="comment">%     supp_diff_fpc = [];</span>
0145     <span class="comment">%     for rwt_itr = 1:rwt+1</span>
0146     <span class="comment">%         % [x_FPC, out_FPC] = FPC_AS(N,AW,y,tau,[],opts); % call FPC_AS</span>
0147     <span class="comment">%         out_FPC = fpc(N,AW,y,1/tau,[],opts);</span>
0148     <span class="comment">%         out_FPC.nProdA = out_FPC.itr;</span>
0149     <span class="comment">%         out_FPC.nProdAt = out_FPC.itr;</span>
0150     <span class="comment">%         x_FPC = out_FPC.x;</span>
0151     <span class="comment">%</span>
0152     <span class="comment">%         x_fpc = x_FPC./W_new;</span>
0153     <span class="comment">%</span>
0154     <span class="comment">%         [alpha beta epsilon] = weight_param(rwt_mode,rwt_itr,x_fpc,M);</span>
0155     <span class="comment">%         W_new = 1/alpha./(beta*abs(x_fpc)+epsilon);</span>
0156     <span class="comment">%         opts.x0 = x_fpc.*W_new;</span>
0157     <span class="comment">%         AW = A*diag(1./W_new);</span>
0158     <span class="comment">%         iter_fpc = [iter_fpc (out_FPC.nProdA+out_FPC.nProdAt)/2];</span>
0159     <span class="comment">%         err_fpc = [err_fpc norm(x-x_fpc)/norm(x)];</span>
0160     <span class="comment">%         supp_diff_fpc = [supp_diff_fpc length(setxor(gamma_orig,find(x_fpc)))];</span>
0161     <span class="comment">%     end</span>
0162     
0163     <span class="comment">%% SPGL1</span>
0164     <span class="comment">% call SPGL1</span>
0165     iter_spgl1 = []; err_spgl1 = []; supp_diff_spgl1 = []; time_spgl1 = [];
0166     <span class="keyword">if</span> ~exist(<span class="string">'spgSetParms'</span>,<span class="string">'file'</span>); error(<span class="string">'Solver SPGL1 is not found.'</span>); <span class="keyword">end</span>
0167     
0168     W_new = ones(N,1);
0169     <span class="comment">% delta = norm(e);</span>
0170     delta = sqrt(M)*sigma;
0171     x_spgl1 = [];
0172     
0173     <span class="keyword">for</span> rwt_itr = 1:rwt+1
0174         spg_opts = <a href="../../../L1_homotopy_v2.0/solvers/spgSetParms.html" class="code" title="function options = spgSetParms(varargin)">spgSetParms</a>(<span class="string">'verbosity'</span>,0,<span class="string">'weights'</span>,W_new,<span class="string">'iterations'</span>,maxiter);
0175         [x_spgl1,r,g,info] = <a href="../../../L1_homotopy_v2.0/solvers/spgl1.html" class="code" title="function [x,r,g,info] = spgl1( A, b, tau, sigma, x, options )">spgl1</a>(A,y,0,delta,x_spgl1,spg_opts);
0176         
0177         rerr = norm(x_spgl1-x)/norm(x);
0178         iter_spgl1 = [iter_spgl1  (info.nProdA+info.nProdAt)/2];
0179         err_spgl1 = [err_spgl1 rerr];
0180         supp_diff_spgl1 = [supp_diff_spgl1 length(setxor(gamma_orig,find(x_spgl1)))];
0181         time_spgl1 = [time_spgl1 info.timeTotal];
0182         [alpha beta epsilon] = <a href="weight_param.html" class="code" title="function [alpha beta epsilon] = weight_param(rwt_mode,itr,varargin)">weight_param</a>(rwt_mode,rwt_itr,x_spgl1,M);
0183         W_new = 1/alpha./(beta*abs(x_spgl1)+epsilon);
0184     <span class="keyword">end</span>
0185     
0186     <span class="comment">%% YALL1</span>
0187     <span class="comment">% set options</span>
0188     digit = 6; <span class="keyword">if</span> sigma &gt; 0; digit = 4; <span class="keyword">end</span>
0189     opts = [];
0190     opts.tol = 10^(-digit);
0191     W_new = ones(N,1);
0192     opts.weights = W_new;
0193     opts.print = 0;
0194     opts.maxit = maxiter/2;
0195     x_yall1 = [];
0196     
0197     iter_yall1 = [];
0198     err_yall1 = [];
0199     time_yall1 = [];
0200     supp_diff_yall1 = [];
0201     <span class="keyword">for</span> rwt_itr = 1:rwt+1
0202         opts.nu = 0; opts.rho = tau; 
0203         tic;
0204         [x_yall1,Out] = <a href="../../../L1_homotopy_v2.0/solvers/yall1.html" class="code" title="function [x, Out] = yall1(A, b, opts)">yall1</a>(A,y,opts);
0205         <span class="comment">% time_yall1 = [time_yall1 Out.cputime];</span>
0206         time_yall1 = [time_yall1 toc];
0207         
0208         iter_yall1 = [iter_yall1 (Out.cntA+Out.cntAt)/2];
0209         rerr = norm(x-x_yall1)/norm(x);
0210         err_yall1 = [err_yall1 rerr];
0211         
0212         supp_diff_yall1 = [supp_diff_yall1 length(setxor(gamma_orig,find(x_yall1)))];
0213         
0214         [alpha beta epsilon] = <a href="weight_param.html" class="code" title="function [alpha beta epsilon] = weight_param(rwt_mode,itr,varargin)">weight_param</a>(rwt_mode,rwt_itr,x_yall1,M);
0215         W_new = 1/alpha./(beta*abs(x_yall1)+epsilon);
0216         opts.x0 = x_yall1;
0217         opts.weights = W_new;
0218     <span class="keyword">end</span>
0219     
0220     <span class="comment">%% SpaRSA</span>
0221     W_new = 1;
0222     <span class="comment">% AW = A;</span>
0223     x_sparsa = 0;
0224     iter_sparsa = [];
0225     err_sparsa = [];
0226     time_sparsa = [];
0227     supp_diff_sparsa = [];
0228     <span class="keyword">for</span> rwt_itr = 1:rwt+1
0229         psi_function = @(x,tau) <a href="../../../L1_homotopy_v2.0/solvers/soft.html" class="code" title="function y = soft(x,T)">soft</a>(x,tau*W_new);
0230         phi_function = @(x) sum(abs(W_new.*x));
0231         tic;
0232         [x_SpaRSA,x_debias_SpaRSA_m,obj_SpaRSA_m_cont,<span class="keyword">...</span>
0233             times_SpaRSA_m_cont,debias_start_SpaRSA_m,mse_SpaRSA_m,taus_SpaRSA_m, numA, numAt]= <span class="keyword">...</span>
0234             <a href="../../../L1_homotopy_v2.0/solvers/SpaRSA_adpW.html" class="code" title="function [x,x_debias,objective,times,debias_start,mses,taus, numA, numAt]=SpaRSA_adpW(y,A,tau,varargin)">SpaRSA_adpW</a>(y,A,tau,<span class="keyword">...</span>
0235             <span class="string">'Monotone'</span>,0,<span class="keyword">...</span>
0236             <span class="string">'adp_wt'</span>,0,<span class="keyword">...</span>
0237             <span class="string">'W_new'</span>,W_new,<span class="keyword">...</span>
0238             <span class="string">'Debias'</span>,0,<span class="keyword">...</span>
0239             <span class="string">'Initialization'</span>,x_sparsa,<span class="keyword">...</span>
0240             <span class="string">'StopCriterion'</span>,2,<span class="keyword">...</span><span class="comment">            </span>
0241             <span class="string">'ToleranceA'</span>,1e-4,<span class="keyword">...</span>
0242             <span class="string">'psi'</span>,psi_function,<span class="keyword">...</span>
0243             <span class="string">'phi'</span>,phi_function,<span class="keyword">...</span>
0244             <span class="string">'Safeguard'</span>,1,<span class="keyword">...</span>
0245             <span class="string">'MaxiterA'</span>,maxiter,<span class="keyword">...</span>
0246             <span class="string">'Verbose'</span>,0,<span class="keyword">...</span>
0247             <span class="string">'True_x'</span>,x,<span class="keyword">...</span>
0248             <span class="string">'Continuation'</span>,1,<span class="keyword">...</span>
0249             <span class="string">'Continuationsteps'</span>,-1);
0250         x_sparsa = x_SpaRSA;
0251         
0252         time_sparsa = [time_sparsa toc];
0253         <span class="comment">% time_sparsa = [time_sparsa times_SpaRSA_m_cont(end)];</span>
0254 
0255         iter_sparsa = [iter_sparsa (numA+numAt)/2];
0256         rerr = norm(x-x_sparsa)/norm(x);
0257         err_sparsa = [err_sparsa rerr];
0258         
0259         
0260         <span class="keyword">if</span> rerr &gt; 100
0261             fprintf(<span class="string">'rerr big... iter # %d in %s\n'</span>,sim,str0);
0262         <span class="keyword">end</span>
0263         
0264         supp_diff_sparsa = [supp_diff_sparsa length(setxor(gamma_orig,find(x_sparsa)))];
0265         
0266         [alpha beta epsilon] = <a href="weight_param.html" class="code" title="function [alpha beta epsilon] = weight_param(rwt_mode,itr,varargin)">weight_param</a>(rwt_mode,rwt_itr,x_sparsa,M);
0267         W_new = 1/alpha./(beta*abs(x_sparsa)+epsilon);
0268     <span class="keyword">end</span>
0269     
0270     <span class="comment">%% NESTA</span>
0271     <span class="comment">%     opts = [];</span>
0272     <span class="comment">%     opts.Verbose = 0;</span>
0273     <span class="comment">%     opts.tolvar = 1e-8;</span>
0274     <span class="comment">%     delta = 0;</span>
0275     <span class="comment">%     muf = 1e-8;</span>
0276     <span class="comment">%     W_new = ones(N,1);</span>
0277     <span class="comment">%</span>
0278     <span class="comment">%     iter_nesta = [];</span>
0279     <span class="comment">%     err_nesta = [];</span>
0280     <span class="comment">%     supp_diff_nesta = [];</span>
0281     <span class="comment">%     x_nesta = [];</span>
0282     <span class="comment">%</span>
0283     <span class="comment">%     for rwt_itr = 1:rwt+1</span>
0284     <span class="comment">%         opts.U = spdiags(W_new,0,N,N);</span>
0285     <span class="comment">%         opts.Ut = opts.U;</span>
0286     <span class="comment">%         opts.normU = max(W_new);</span>
0287     <span class="comment">%         opts.xplug = x_nesta;  % use old solution as starting value</span>
0288     <span class="comment">%</span>
0289     <span class="comment">%         % constrained</span>
0290     <span class="comment">%         [x_nesta,niter,resid,outData,optsOut] = NESTA(A,[],y,muf,delta,opts);</span>
0291     <span class="comment">%         % unconstrained</span>
0292     <span class="comment">%         La = norm( A*A' );</span>
0293     <span class="comment">%         % [x_nesta,niter,resid,outData,optsOut] = NESTA_UP(A,[],y,tau,La,muf,opts);</span>
0294     <span class="comment">%</span>
0295     <span class="comment">%         iter_nesta = [iter_nesta niter*3];</span>
0296     <span class="comment">%         rerr = norm(x-x_nesta)/norm(x);</span>
0297     <span class="comment">%         err_nesta = [err_nesta rerr];</span>
0298     <span class="comment">%         supp_diff_nesta = [supp_diff_nesta length(setxor(gamma_orig,find(x_nesta)))];</span>
0299     <span class="comment">%</span>
0300     <span class="comment">%         [alpha beta epsilon] = weight_param(rwt_mode,rwt_itr,x_nesta,M);</span>
0301     <span class="comment">%         W_new = 1/alpha./(beta*abs(x_nesta)+epsilon);</span>
0302     <span class="comment">%     end</span>
0303     
0304     <span class="comment">%% SALSA</span>
0305     <span class="comment">%     W_new = ones(N,1);</span>
0306     <span class="comment">%     x_salsa = 0;</span>
0307     <span class="comment">%     mu = 1/tau;</span>
0308     <span class="comment">%     invLS = @(x) inv(A'*A+mu*eye(N))*x;</span>
0309     <span class="comment">%</span>
0310     <span class="comment">%     iter_salsa = [];</span>
0311     <span class="comment">%     err_salsa = [];</span>
0312     <span class="comment">%     supp_diff_salsa = [];</span>
0313     <span class="comment">%     for rwt_itr = 1:rwt+1</span>
0314     <span class="comment">%         psi_function = @(x,tau) soft(x,tau*W_new);</span>
0315     <span class="comment">%         phi_function = @(x) sum(abs(W_new.*x));</span>
0316     <span class="comment">%         [x_salsa, numA, numAt, objective, distance,  times, mses] = ...</span>
0317     <span class="comment">%             SALSA_v2(y, A, tau,...</span>
0318     <span class="comment">%             'Mu', 1e-3, ...</span>
0319     <span class="comment">%             'True_x', x, ...</span>
0320     <span class="comment">%             'psi',psi_function,...</span>
0321     <span class="comment">%             'phi',phi_function,...</span>
0322     <span class="comment">%             'INITIALIZATION', x_salsa, ...</span>
0323     <span class="comment">%             'ToleranceA', 1e-6,...</span>
0324     <span class="comment">%             'MAXITERA', maxiter, ...</span>
0325     <span class="comment">%             'VERBOSE', 0);</span>
0326     <span class="comment">%</span>
0327     <span class="comment">%         iter_salsa = [iter_salsa (numA+numAt)/2];</span>
0328     <span class="comment">%         rerr = norm(x-x_salsa)/norm(x)</span>
0329     <span class="comment">%         err_salsa = [err_salsa rerr];</span>
0330     <span class="comment">%         supp_diff_salsa = [supp_diff_salsa length(setxor(gamma_orig,find(x_salsa)))];</span>
0331     <span class="comment">%</span>
0332     <span class="comment">%         [alpha beta epsilon] = weight_param(rwt_mode,rwt_itr,x_salsa,M);</span>
0333     <span class="comment">%         W_new = 1/alpha./(beta*abs(x_salsa)+epsilon);</span>
0334     <span class="comment">%     end</span>
0335     
0336     <span class="comment">%% Save results...</span>
0337     
0338     <span class="comment">% fprintf('sim iter. %d: \n',sim);</span>
0339     <span class="comment">% SIM_stack = [SIM_stack; sim, rwt_itr, iter_adp, iter_rwt_ALL, norm(x-xh_adp), norm(x-xh_rwt),length(setxor(gamma_adp,gamma_rwt)),length(setdiff(gamma_adp,gamma_orig)),length(setdiff(gamma_rwt,gamma_orig))];</span>
0340     SIM_stack{sim} = [sim, tau, norm(x-x_LS)/norm(x), norm(x-xh_orac)/norm(x), iter_orac, <span class="keyword">...</span>
0341         norm(x-xh_adp)/norm(x), sum(iter_adp,2), sum(time_adp,2), <span class="keyword">...</span>
0342         norm(x-xh_rwt)/norm(x), sum(iter_rwt,2), sum(time_rwt,2), <span class="keyword">...</span>
0343         norm(x-x_yall1)/norm(x), sum(iter_yall1,2), sum(time_yall1,2), <span class="keyword">...</span>
0344         norm(x-x_sparsa)/norm(x), sum(iter_sparsa,2), sum(time_sparsa,2), <span class="keyword">...</span>
0345         norm(x-x_spgl1)/norm(x), sum(iter_spgl1,2), sum(time_spgl1,2), <span class="keyword">...</span>
0346         norm(x-x_omp)/norm(x), iter_omp];
0347     <span class="comment">% norm(x-x_fpc)/norm(x), sum(iter_fpc,2), ...</span>
0348     <span class="comment">% sum(iter_nesta,2), norm(x-x_nesta)/norm(x), ...</span>
0349     <span class="comment">% sum(iter_salsa,2), norm(x-x_salsa)/norm(x), ...</span>
0350     
0351     <span class="comment">% adaptive rwt</span>
0352     exp = 1;
0353     SIM_memory{sim}{exp,1} = <span class="string">'adp'</span>;
0354     SIM_memory{sim}{exp,2} = iter_adp;
0355     SIM_memory{sim}{exp,3} = err_adp;
0356     SIM_memory{sim}{exp,4} = supp_diff_adp;
0357     SIM_memory{sim}{exp,5} = time_adp;
0358     <span class="comment">% iterative rwt</span>
0359     exp = exp+1;
0360     SIM_memory{sim}{exp,1} = <span class="string">'rwt'</span>;
0361     SIM_memory{sim}{exp,2} = iter_rwt;
0362     SIM_memory{sim}{exp,3} = err_rwt;
0363     SIM_memory{sim}{exp,4} = supp_diff_rwt;
0364     SIM_memory{sim}{exp,5} = time_rwt;
0365     <span class="comment">% yall1</span>
0366     exp = exp+1;
0367     SIM_memory{sim}{exp,1} = <span class="string">'yall1'</span>;
0368     SIM_memory{sim}{exp,2} = iter_yall1;
0369     SIM_memory{sim}{exp,3} = err_yall1;
0370     SIM_memory{sim}{exp,4} = supp_diff_yall1;
0371     SIM_memory{sim}{exp,5} = time_yall1;
0372     <span class="comment">% sparsa</span>
0373     exp = exp+1;
0374     SIM_memory{sim}{exp,1} = <span class="string">'sparsa'</span>;
0375     SIM_memory{sim}{exp,2} = iter_sparsa;
0376     SIM_memory{sim}{exp,3} = err_sparsa;
0377     SIM_memory{sim}{exp,4} = supp_diff_sparsa;
0378     SIM_memory{sim}{exp,5} = time_sparsa;
0379     <span class="comment">% spgl1</span>
0380     exp = exp+1;
0381     SIM_memory{sim}{exp,1} = <span class="string">'spgl1'</span>;
0382     SIM_memory{sim}{exp,2} = iter_spgl1;
0383     SIM_memory{sim}{exp,3} = err_spgl1;
0384     SIM_memory{sim}{exp,4} = supp_diff_spgl1;
0385     SIM_memory{sim}{exp,5} = time_spgl1;
0386     <span class="comment">%     % fpc</span>
0387     <span class="comment">%     exp = exp+1;</span>
0388     <span class="comment">%     SIM_memory{sim}{exp,1} = 'fpc';</span>
0389     <span class="comment">%     SIM_memory{sim}{exp,2} = iter_fpc;</span>
0390     <span class="comment">%     SIM_memory{sim}{exp,3} = err_fpc;</span>
0391     <span class="comment">%     SIM_memory{sim}{exp,4} = supp_diff_fpc;</span>
0392     <span class="comment">%     % nesta</span>
0393     <span class="comment">%     exp = exp+1;</span>
0394     <span class="comment">%     SIM_memory{sim}{6,1} = 'nesta';</span>
0395     <span class="comment">%     SIM_memory{sim}{6,2} = iter_nesta;</span>
0396     <span class="comment">%     SIM_memory{sim}{6,3} = err_nesta;</span>
0397     <span class="comment">%     SIM_memory{sim}{6,4} = supp_diff_nesta;</span>
0398     <span class="comment">%     % salsa</span>
0399     <span class="comment">%     exp = exp+1;</span>
0400     <span class="comment">%     SIM_memory{sim}{6,1} = 'salsa';</span>
0401     <span class="comment">%     SIM_memory{sim}{6,2} = iter_salsa;</span>
0402     <span class="comment">%     SIM_memory{sim}{6,3} = err_salsa;</span>
0403     <span class="comment">%     SIM_memory{sim}{6,4} = supp_diff_salsa;</span>
0404     
0405     <span class="comment">% mS = mean(cell2mat(SIM_stack),1);</span>
0406     <span class="comment">% fprintf('maxsim %d. oracLS=%3.4g. (err,iter,time): oracWT-%3.4g,%3.4g; adp-%3.4g,%3.4g,%3.4g; rwt-%3.4g,%3.4g,%3.4g; yall1-%3.4g,%3.4g,%3.4g; sparsa-%3.4g,%3.4g,%3.4g; omp-%3.4g,%3.4g; fpc-%3.4g,%3.4g; spgl1-%3.4g,%3.4g. \n', maxsim, mS(2:end));</span>
0407 <span class="keyword">end</span>
0408 
0409 mS = mean(cell2mat(SIM_stack),1);
0410 str1 = <span class="string">'maxsim %d. tau = %3.4g, oracLS=%3.4g. (err,iter,time): oracWT-%3.4g,%3.4g; adp-%3.4g,%3.4g,%3.4g; rwt-%3.4g,%3.4g,%3.4g; yall1-%3.4g,%3.4g,%3.4g; sparsa-%3.4g,%3.4g,%3.4g; spgl1-%3.4g,%3.4g,%3.4g; omp-%3.4g,%3.4g.'</span>;
0411 str2 = sprintf([str1,<span class="string">' \n'</span>], maxsim, mS(2:end));
0412 disp(str2);
0413</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of script_rwtBPDN_adaptive</title>
  <meta name="keywords" content="script_rwtBPDN_adaptive">
  <meta name="description" content="BPDN rwt update (initialize with adaptive_wtBPDN)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html L1_homotopy_v2.0 --><!-- ../menu.html WeightedBPDN --><!-- menu.html src -->
<h1>script_rwtBPDN_adaptive
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>BPDN rwt update (initialize with adaptive_wtBPDN)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function out = script_rwtBPDN_adaptive(in) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> BPDN rwt update (initialize with adaptive_wtBPDN)

 Solve the following basis pursuit denoising (BPDN) problem
 min_x  \Sum \w_i |x_i| + 1/2*||y-Ax||_2^2

 Initialize with adaptive weighted BPDN
 and dynamically update the weights w_i

 Written by: Salman Asif, Georgia Tech
 Email: sasif@ece.gatech.edu
 Created: April 16, 2011</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="weight_param.html" class="code" title="function [alpha beta epsilon] = weight_param(rwt_mode,itr,varargin)">weight_param</a>	Compute alpha,beta, and epsilon to update weights as</li><li><a href="wtBPDN_Update_function_v1.html" class="code" title="function out = wtBPDN_Update_function_v1(A, y, in);">wtBPDN_Update_function_v1</a>	Iterative reweighting updates for BPDN</li><li><a href="wtBPDN_Update_function_v2.html" class="code" title="function out = wtBPDN_Update_function_v2(A, y, in);">wtBPDN_Update_function_v2</a>	BPDN_homotopy_ReWeighted.m</li><li><a href="wtBPDN_adaptive_function.html" class="code" title="function out = wtBPDN_adaptive_function(A, y, in)">wtBPDN_adaptive_function</a>	wtBPDN_adaptive_function</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../L1_homotopy_v2.0/WeightedBPDN/demo_wtBPDN.html" class="code" title="">demo_wtBPDN</a>	demo_wtBPDN</li><li><a href="script_simulation_adpWBPDN.html" class="code" title="">script_simulation_adpWBPDN</a>	partial script for running different solvers for adaptive reweighting</li><li><a href="script_simulation_wtBPDN.html" class="code" title="">script_simulation_wtBPDN</a>	partial script for running different solvers</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% BPDN rwt update (initialize with adaptive_wtBPDN)</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Solve the following basis pursuit denoising (BPDN) problem</span>
0004 <span class="comment">% min_x  \Sum \w_i |x_i| + 1/2*||y-Ax||_2^2</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Initialize with adaptive weighted BPDN</span>
0007 <span class="comment">% and dynamically update the weights w_i</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0010 <span class="comment">% Email: sasif@ece.gatech.edu</span>
0011 <span class="comment">% Created: April 16, 2011</span>
0012 
0013 <a name="_sub0" href="#_subfunctions" class="code">function out = script_rwtBPDN_adaptive(in)</a>
0014 
0015 A = in.A; y = in.y; x = in.x; 
0016 gamma_orig = find(x);
0017 [M N] = size(A);
0018 tau = in.tau; max_rwt = in.max_rwt;
0019 x_init = in.x_init; 
0020 
0021 <span class="comment">%% parameter selection</span>
0022 rwt_mode = in.rwt_mode;
0023 
0024 delx_mode = in.delx_mode;
0025 homotopy_update = <span class="string">'v1'</span>;
0026 debias = in.debias;
0027 verbose = in.verbose;
0028 
0029 maxiter = 2*N;
0030 iter_ALL = [];
0031 err_ALL = [];
0032 time_ALL = [];
0033 supp_diff = [];
0034 
0035 <span class="keyword">if</span> norm(x_init) == 0
0036     <span class="comment">%% Adaptive support + weight selection</span>
0037     <span class="comment">% Fast shrinkage on the active set...???</span>
0038     <span class="comment">%</span>
0039     <span class="comment">% use a large value for Tsteps (~10-100)</span>
0040     <span class="comment">%     ewt = 10; shrinkage_mode = 'Tsteps'; shrinkage_flag = 0;</span>
0041     <span class="comment">%</span>
0042     <span class="comment">% use a large value for Trwt</span>
0043     <span class="comment">%     ewt = 100; shrinkage_mode = 'Trwt'; shrinkage_flag = 0; % Gaussian</span>
0044     <span class="comment">% use shrinkage_flag = 0 for Gaussian signal... (amplitude variations)</span>
0045     <span class="comment">% use shrinkage_flag = 2 for sign/ones signal... (flat)</span>
0046     <span class="comment">%</span>
0047     
0048     <span class="comment">% 'rwt' works better when nonzero components have diverse amplitudes</span>
0049     <span class="comment">% ewt = 2; shrinkage_mode = 'rwt'; shrinkage_flag = 0;</span>
0050     ewt = 1; shrinkage_mode = <span class="string">'Trwt'</span>; shrinkage_flag = 0;
0051     <span class="comment">% ewt = 2; shrinkage_mode = 'Tsteps'; shrinkage_flag = 3;</span>
0052     <span class="comment">% ewt = 1; shrinkage_mode = 'OLS'; shrinkage_flag = 0;</span>
0053     
0054     <span class="keyword">if</span> verbose
0055         fprintf(<span class="string">' ewt = %1.2g, shrinkage_mode: %s, '</span>,ewt, shrinkage_mode);
0056     <span class="keyword">end</span>
0057     
0058     in = [];
0059     in.tau = tau;
0060     in.ewt = ewt; <span class="comment">% Setting ewt = 1 with Tsteps solves unweighted LASSO</span>
0061     in.shrinkage_flag = shrinkage_flag;
0062     in.shrinkage_mode = shrinkage_mode; <span class="comment">% (either fixed or adaptive weighting)</span>
0063     in.maxiter = maxiter;
0064     in.debias = debias;
0065     in.early_terminate = 0;
0066     in.x_orig = x;
0067     in.record = 1;
0068     in.omp = 0;
0069     in.plots = 0;
0070     in.plot_wts = 0;
0071     in.delx_mode = delx_mode;
0072     <span class="comment">% in.Te = T;</span>
0073     tic;
0074     out = <a href="wtBPDN_adaptive_function.html" class="code" title="function out = wtBPDN_adaptive_function(A, y, in)">wtBPDN_adaptive_function</a>(A, y, in);
0075     time_ALL = [time_ALL toc];
0076     <span class="comment">% time_ALL = [time_ALL out.time];</span>
0077     x_init = out.x_out;
0078     gamma_old = out.gamma;
0079     iter_old = out.iter;
0080     tau_vec = out.tau_vec;
0081     iter_ALL = [iter_ALL iter_old];
0082     err_ALL = [err_ALL norm(x-x_init)/norm(x)];
0083     supp_diff = [supp_diff length(setxor(gamma_old,gamma_orig))];
0084     <span class="keyword">if</span> verbose
0085         fprintf(<span class="string">'err = %3.4g, iter = %3.4g, time = %3.4g \n'</span>,err_ALL(end), iter_ALL(end), time_ALL(end));
0086     <span class="keyword">end</span>
0087 <span class="keyword">end</span>
0088 W_new = tau_vec; <span class="comment">% These weights are chosen adaptively by the homotopy solver</span>
0089 
0090 <span class="comment">% THERE SHOULDN'T BE ANY NEED FOR REWEIGHTING HERE</span>
0091 <span class="comment">% But just in case...</span>
0092 
0093 <span class="comment">%% Iterative reweighting</span>
0094 xh_mod = x_init;
0095 gamma_xh = gamma_old;
0096 <span class="keyword">for</span> rwt_itr = 1:max_rwt
0097     gamma_old = gamma_xh;
0098     x_old = xh_mod;
0099     W_old = W_new;
0100     
0101     [alpha beta epsilon] = <a href="weight_param.html" class="code" title="function [alpha beta epsilon] = weight_param(rwt_mode,itr,varargin)">weight_param</a>(rwt_mode,rwt_itr,x_old,M);    
0102     W_new = tau/alpha./(beta*abs(x_old)+epsilon);
0103     
0104     <span class="comment">% W_new = tau/epsilon*ones(N,1);</span>
0105     <span class="comment">% W_new(gamma_old) = min([tau*ones(length(gamma_old),1) tau./(beta*abs(x_old(gamma_old)))],[],2);</span>
0106     
0107     <span class="keyword">switch</span> homotopy_update
0108         <span class="keyword">case</span> <span class="string">'v1'</span>
0109             <span class="comment">% The following Gram matrix and its inverse can be used from the</span>
0110             <span class="comment">% previous homotopy. Too lazy to include that right now...</span>
0111             <span class="comment">% wt BPDN homotopy update</span>
0112             pk_old = A'*(A*x_old-y);
0113             pk_old(gamma_old) = sign(pk_old(gamma_old)).*W_old(gamma_old);
0114             in = [];
0115             in.x_old = x_old;
0116             in.gamma = gamma_old;
0117             in.pk_old = pk_old;
0118             in.W_old = W_old;
0119             in.W_new = W_new;
0120             in.maxiter = maxiter;
0121             dW = W_new-W_old;
0122             in.maxiter = maxiter;
0123             
0124             <span class="comment">% delx = -AtAgx\(-dW(gamma_old).*sign(pk_old(gamma_old)));</span>
0125             <span class="comment">% in.delx = delx;</span>
0126             in.delx_mode = delx_mode;
0127             <span class="keyword">switch</span> in.delx_mode
0128                 <span class="keyword">case</span> <span class="string">'mil'</span>;
0129                     <span class="comment">% in.delx_mode = 'mil';</span>
0130                     AtAgx = A(:,gamma_old)'*A(:,gamma_old);
0131                     iAtAgx = pinv(AtAgx);
0132                     in.AtA = AtAgx;
0133                     in.iAtA = iAtAgx;                    
0134                 <span class="keyword">case</span> <span class="string">'qr'</span>;
0135                     <span class="comment">% in.delx_mode = 'qr';</span>
0136                     [Q R] = qr(A(:,gamma_old),0);
0137                     in.Q = Q; in.R = R;
0138                 <span class="keyword">case</span> <span class="string">'qrM'</span>
0139                     <span class="comment">% in.delx_mode = 'qrM';</span>
0140                     [Q0 R0] = qr(A(:,gamma_old));
0141                     in.Q0 = Q0; in.R0 = R0;
0142             <span class="keyword">end</span>
0143             tic;
0144             out = <a href="wtBPDN_Update_function_v1.html" class="code" title="function out = wtBPDN_Update_function_v1(A, y, in);">wtBPDN_Update_function_v1</a>(A, y, in);
0145             <span class="comment">% time_update = out.time;</span>
0146             time_update = toc;
0147             xh_mod = out.x_out;
0148             gamma_xh = out.gamma;
0149             iter_update = out.iter;
0150         <span class="keyword">case</span> <span class="string">'v2'</span>
0151             
0152             <span class="comment">% Homotopy update v2 (weighting embedded in the matrix A)</span>
0153             AW_old = A*diag(tau./W_old);
0154             u0_hat = x_old.*(W_old/tau);
0155             ds = AW_old'*(AW_old*u0_hat-y);
0156             AW = A*diag(tau./W_new);
0157             yhat = AW*u0_hat;
0158             pk_old = ds; pk_old(gamma_old) = sign(pk_old(gamma_old)).*tau;
0159             in = [];
0160             in.x_old = u0_hat;
0161             in.gamma = gamma_old;
0162             in.pk_old = pk_old;
0163             in.tau = tau;
0164             in.maxiter = maxiter;
0165             in.yhat = yhat;
0166             
0167             <span class="comment">% ds = pk_old; d = AW'*(yhat-y);</span>
0168             <span class="comment">% delx = AtAgx\(ds(gamma_old)-d(gamma_old));</span>
0169             <span class="comment">% in.delx = delx;</span>
0170             in.delx_mode = delx_mode;
0171             <span class="keyword">switch</span> in.delx_mode
0172                 <span class="keyword">case</span> <span class="string">'mil'</span>;
0173                     <span class="comment">% in.delx_mode = 'mil';</span>
0174                     AtAgx = AW(:,gamma_old)'*AW(:,gamma_old);
0175                     iAtAgx = pinv(AtAgx);                    
0176                     in.AtA = AtAgx;
0177                     in.iAtA = iAtAgx;                    
0178                 <span class="keyword">case</span> <span class="string">'qr'</span>;
0179                     <span class="comment">% in.delx_mode = 'qr';</span>
0180                     [Q R] = qr(AW(:,gamma_old),0);
0181                     in.Q = Q; in.R = R;
0182                 <span class="keyword">case</span> <span class="string">'qrM'</span>
0183                     <span class="comment">% in.delx_mode = 'qrM';</span>
0184                     [Q0 R0] = qr(AW(:,gamma_old));
0185                     in.Q0 = Q0; in.R0 = R0;
0186                 <span class="keyword">case</span> <span class="string">'cg'</span>
0187                     <span class="comment">% in.delx_mode = 'cg';</span>
0188                     in.W_new = tau./W_new;
0189             <span class="keyword">end</span>
0190             tic;
0191             out = <a href="wtBPDN_Update_function_v2.html" class="code" title="function out = wtBPDN_Update_function_v2(A, y, in);">wtBPDN_Update_function_v2</a>(AW, y, in);
0192             <span class="comment">% time_update = out.time;</span>
0193             time_update = toc;
0194 
0195             xh_mod = out.x_out.*(tau./W_new);
0196             gamma_xh = out.gamma;
0197             iter_update = out.iter;
0198     <span class="keyword">end</span>
0199     iter_ALL = [iter_ALL iter_update];
0200     err_ALL = [err_ALL norm(x-xh_mod)/norm(x)];
0201     time_ALL = [time_ALL time_update];
0202     supp_diff = [supp_diff length(setxor(gamma_xh,gamma_orig))];
0203 <span class="keyword">end</span>
0204 
0205 out.x_out = xh_mod;
0206 out.x_init = x_init;
0207 out.iter = iter_ALL;
0208 out.gamma = gamma_xh;
0209 out.W_new = W_new;
0210 out.err = err_ALL;
0211 out.time = time_ALL;
0212 out.supp_diff = supp_diff;</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of wtBPDN_homotopy_function</title>
  <meta name="keywords" content="wtBPDN_homotopy_function">
  <meta name="description" content="wtBPDN_homotopy_function">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html L1_homotopy_v2.0 --><!-- ../menu.html WeightedBPDN --><!-- menu.html src -->
<h1>wtBPDN_homotopy_function
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>wtBPDN_homotopy_function</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function out = wtBPDN_homotopy_function(A, y, in) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> wtBPDN_homotopy_function

 Solves the following basis pursuit denoising (BPDN) problem
 min_x  \Sum w_i |x_i| + 1/2*||y-Ax||_2^2

 using homotopy from scratch. 

 (A simpler way to solve weighted BPDN is to modulate columns of A using
 the weights and solve simple BPDN, i.e., min \|x_i\|_1 + 1/2\|AWx-y\|_2^2
 Inputs:
 A - m x n measurement matrix
 y - measurement vector
 in - input structure
   W - final values of regularization parameter
   maxiter - maximum number of homotopy iterations
   Te -
   record - record iteration history
   x_orig - origianl signal for error history

 Outputs:
 out - output structure
   x_out - output for BPDN
   gamma - support of the solution
   iter - number of homotopy iterations taken by the solver
   time - time taken by the solver
   error_table - error table with iteration record

 Written by: Salman Asif, Georgia Tech
 Email: sasif@ece.gatech.edu

-------------------------------------------+
 Copyright (c) 2011.  Muhammad Salman Asif
-------------------------------------------+</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../L1_homotopy_v2.0/utils/compute_delta.html" class="code" title="function out = compute_delta(in)">compute_delta</a>	</li><li><a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>	script to ubpdate delx</li><li><a href="../../../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>	script to update support</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% wtBPDN_homotopy_function</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Solves the following basis pursuit denoising (BPDN) problem</span>
0004 <span class="comment">% min_x  \Sum w_i |x_i| + 1/2*||y-Ax||_2^2</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% using homotopy from scratch.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% (A simpler way to solve weighted BPDN is to modulate columns of A using</span>
0009 <span class="comment">% the weights and solve simple BPDN, i.e., min \|x_i\|_1 + 1/2\|AWx-y\|_2^2</span>
0010 <span class="comment">% Inputs:</span>
0011 <span class="comment">% A - m x n measurement matrix</span>
0012 <span class="comment">% y - measurement vector</span>
0013 <span class="comment">% in - input structure</span>
0014 <span class="comment">%   W - final values of regularization parameter</span>
0015 <span class="comment">%   maxiter - maximum number of homotopy iterations</span>
0016 <span class="comment">%   Te -</span>
0017 <span class="comment">%   record - record iteration history</span>
0018 <span class="comment">%   x_orig - origianl signal for error history</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% Outputs:</span>
0021 <span class="comment">% out - output structure</span>
0022 <span class="comment">%   x_out - output for BPDN</span>
0023 <span class="comment">%   gamma - support of the solution</span>
0024 <span class="comment">%   iter - number of homotopy iterations taken by the solver</span>
0025 <span class="comment">%   time - time taken by the solver</span>
0026 <span class="comment">%   error_table - error table with iteration record</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0029 <span class="comment">% Email: sasif@ece.gatech.edu</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%-------------------------------------------+</span>
0032 <span class="comment">% Copyright (c) 2011.  Muhammad Salman Asif</span>
0033 <span class="comment">%-------------------------------------------+</span>
0034 
0035 <a name="_sub0" href="#_subfunctions" class="code">function out = wtBPDN_homotopy_function(A, y, in)</a>
0036 
0037 N = size(A,2);
0038 M = size(A,1);
0039 
0040 W_vec = in.W;
0041 maxiter = in.maxiter;
0042 Te = inf;
0043 <span class="keyword">if</span> isfield(in,<span class="string">'Te'</span>)
0044     Te = in.Te;
0045 <span class="keyword">end</span>
0046 err_record = 0;
0047 <span class="keyword">if</span> isfield(in,<span class="string">'record'</span>);
0048     err_record = in.record;
0049     <span class="keyword">if</span> err_record
0050         x_orig = in.x_orig;
0051     <span class="keyword">end</span>
0052 <span class="keyword">end</span>
0053 t0 = cputime;
0054 
0055 <span class="comment">% Regularization parameters</span>
0056 unique_eps = sort(unique(W_vec),<span class="string">'descend'</span>);
0057 
0058 <span class="comment">% Initialization of primal sign and support</span>
0059 z_x = zeros(N,1);
0060 gamma_x = [];       <span class="comment">% Primal support</span>
0061 
0062 <span class="comment">% Initial step</span>
0063 pk_old = -A'*y;
0064 constr_mask = abs(pk_old)&gt;W_vec;
0065 [c idelta] = max(abs(pk_old.*constr_mask));
0066 eps_iter = sum(unique_eps&gt;c)+1;
0067 
0068 gamma_xh = idelta;
0069 temp_gamma = zeros(N,1);
0070 temp_gamma(gamma_xh) = gamma_xh;
0071 gamma_xc = find([1:N]' ~= temp_gamma);
0072 
0073 z_x(gamma_xh) = -sign(pk_old(gamma_xh));
0074 epsilon = c;
0075 pk_old(gamma_xh) = sign(pk_old(gamma_xh))*epsilon;
0076 xk_1 = zeros(N,1);
0077 
0078 <span class="comment">% loop parameters</span>
0079 done = 0;
0080 iter = 0;
0081 itr_history = [];
0082 
0083 error_table = [];
0084 <span class="keyword">if</span> err_record
0085     error_table = [epsilon norm(xk_1-x_orig) 1];
0086 <span class="keyword">end</span>
0087 
0088 <span class="comment">% initialize delx</span>
0089 in_delx = [];
0090 delx_mode = in.delx_mode;
0091 indicator_temp = epsilon&gt;W_vec;
0092 rhs = indicator_temp.*z_x;
0093 update_mode = <span class="string">'init0'</span>;
0094 <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0095 flag = 1;
0096 
0097 <span class="keyword">while</span> iter &lt; maxiter
0098     iter = iter+1;
0099     <span class="comment">% warning('off','MATLAB:divideByZero')</span>
0100     
0101     x_k = xk_1;
0102     
0103     <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0104     <span class="comment">%%%% update on x %%%%</span>
0105     <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0106     
0107     <span class="comment">% Update direction</span>
0108     <span class="comment">% update direction</span>
0109     delx_vec = zeros(N,1);
0110     delx_vec(gamma_xh) = delx;
0111     
0112     <span class="keyword">if</span> sign(delx_vec(idelta)) == sign(pk_old(idelta)) &amp;&amp; iter &gt; 1 &amp;&amp; flag == 0
0113         delta = 0; flag = 0;
0114     <span class="keyword">else</span>
0115         pk = pk_old;
0116         <span class="comment">% dk = AtA*del_x_vec;</span>
0117         dk_temp = A*delx_vec;
0118         dk = A'*dk_temp;
0119         
0120         <span class="comment">%%%--- compute step size</span>
0121         in = [];
0122         
0123         <span class="comment">% Setting shrinkage_flag to zero shrinks new active constraint towards the</span>
0124         <span class="comment">% final value instantly if doing so doesn't disturb the active set</span>
0125         
0126         epsilon_temp = epsilon.*(epsilon&gt;W_vec)+W_vec.*(epsilon&lt;=W_vec);
0127         one_temp = epsilon&gt;W_vec;
0128         
0129         in.delta_flag = 2;
0130         in.pk = pk; in.dk = dk;
0131         in.ak = epsilon_temp; in.bk = -one_temp;
0132         in.gamma = gamma_xh; in.gamma_c = gamma_xc;
0133         in.delx_vec = delx_vec; in.x = xk_1;
0134         out = <a href="../../../L1_homotopy_v2.0/utils/compute_delta.html" class="code" title="function out = compute_delta(in)">compute_delta</a>(in);
0135         delta = out.delta; idelta = out.idelta;
0136         flag = out.flag;
0137         
0138         xk_1 = x_k+delta*delx_vec;
0139         pk_old = pk+delta*dk;
0140         epsilon_old = epsilon;
0141         epsilon = epsilon-delta;
0142         
0143         <span class="keyword">if</span> epsilon &lt;= unique_eps(eps_iter)
0144             epsilon = unique_eps(eps_iter);
0145             delta_end = epsilon_old-epsilon;
0146             pk_old = pk+delta_end*dk;
0147             epsilon_temp = epsilon.*(epsilon&gt;W_vec)+W_vec.*(epsilon&lt;=W_vec);
0148             pk_old([gamma_xh]) = sign(pk_old([gamma_xh])).*epsilon_temp([gamma_xh]);
0149             
0150             xk_1 = x_k + delta_end*delx_vec;
0151             eps_iter = eps_iter+1;
0152             <span class="keyword">if</span> eps_iter &gt; length(unique_eps)
0153                 <span class="comment">%disp('done!');</span>
0154                 <span class="keyword">break</span>;
0155             <span class="keyword">else</span>
0156                 <span class="comment">%disp('switch epsilon!');</span>
0157                 flag = 1;
0158                 z_x = -sign(pk_old);
0159                 indicator_temp = epsilon&gt;W_vec;
0160                 rhs = indicator_temp.*z_x;
0161                 update_mode = <span class="string">'recompute'</span>;
0162                 <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0163                 <span class="keyword">continue</span>;
0164             <span class="keyword">end</span>
0165         <span class="keyword">end</span>
0166         <span class="keyword">if</span> epsilon &lt;= min(W_vec); <span class="comment">%sqrt(2*log(N))*sigma; %1e-7 %|| iter &gt; 5*T || (length(gamma_lambda) == K)</span>
0167             delta_end = epsilon_old-thresh;
0168             pk_old = pk+delta_end*dk;
0169             xk_1 = x_k + delta_end*delx_vec;
0170             <span class="comment">% disp('done!');</span>
0171             <span class="keyword">break</span>;
0172         <span class="keyword">end</span>
0173         <span class="keyword">if</span> length(gamma_x)-flag &gt;= Te
0174             total_time = cputime-t0;
0175             <span class="keyword">break</span>;
0176         <span class="keyword">end</span>
0177     <span class="keyword">end</span>
0178     <span class="comment">% disp(sprintf(['iter = %d, delta = %3.4g, idelta = %d, flag = %d'], iter, delta, idelta, flag));</span>
0179     itr_history = [itr_history; idelta delta flag];
0180     
0181     <span class="comment">% update support</span>
0182     <a href="../../../L1_homotopy_v2.0/utils/update_supp.html" class="code" title="">update_supp</a>;
0183     
0184     epsilon_temp = epsilon.*(epsilon&gt;W_vec)+W_vec.*(epsilon&lt;=W_vec);
0185     pk_old([gamma_xh; idelta]) = sign(pk_old([gamma_xh; idelta])).*epsilon_temp([gamma_xh; idelta]);
0186     
0187     <span class="comment">% update delx</span>
0188     z_x = -sign(pk_old);
0189     indicator_temp = epsilon&gt;W_vec;
0190     rhs = indicator_temp.*z_x;
0191     update_mode = <span class="string">'update'</span>;
0192     <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0193         
0194     constr_violation = nnz((abs(pk_old(gamma_xc))-epsilon_temp(gamma_xc))&gt;1e-10);
0195     sign_violation = nnz(abs(sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh)))&gt;1);
0196     <span class="keyword">if</span> constr_violation
0197         chk = gamma_xc((abs(pk_old(gamma_xc))-epsilon_temp(gamma_xc))&gt;1e-10);
0198         stp = 1;
0199         fprintf(<span class="string">'problem... with constraint violation -- %s\n'</span>, mfilename);
0200         fprintf(<span class="string">'Refactorize the matrix... recompute delx \n'</span>);
0201         <span class="comment">% some times it comes here due to bad conditioning of AtAgx.</span>
0202         update_mode = <span class="string">'init0'</span>;
0203         <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0204     <span class="keyword">end</span>
0205     <span class="keyword">if</span> sign_violation&gt;1
0206         chk = gamma_xh(abs(sign(pk_old(gamma_xh))+sign(xk_1(gamma_xh)))&gt;1);
0207         stp = 1;
0208         fprintf(<span class="string">'problem... sign mismatch -- %s\n'</span>,mfilename);
0209         fprintf(<span class="string">'Refactorize the matrix... recompute delx \n'</span>);
0210         update_mode = <span class="string">'init0'</span>;
0211         <a href="../../../L1_homotopy_v2.0/utils/update_delx.html" class="code" title="">update_delx</a>;
0212     <span class="keyword">end</span>
0213     <span class="keyword">if</span> err_record
0214         error_table = [error_table; epsilon norm(xk_1-x_orig) length(gamma_x)];
0215     <span class="keyword">end</span>
0216 <span class="keyword">end</span>
0217 
0218 <span class="keyword">if</span> err_record
0219     error_table = [error_table; epsilon norm(xk_1-x_orig) length(gamma_x)];
0220 <span class="keyword">end</span>
0221 total_iter = iter;
0222 total_time = cputime-t0;
0223 
0224 out = [];
0225 out.x_out = xk_1;
0226 out.gamma = gamma_xh;
0227 out.iter = total_iter;
0228 out.time = total_time;
0229 out.error_table = error_table;</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
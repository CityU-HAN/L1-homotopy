<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of compute_delx</title>
  <meta name="keywords" content="compute_delx">
  <meta name="description" content="This function solves a system of the form A^TA delx = z.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html L1_homotopy_v2.0 --><!-- menu.html utils -->
<h1>compute_delx
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This function solves a system of the form A^TA delx = z.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function out = compute_delx(in,A) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> This function solves a system of the form A^TA delx = z.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="givens.html" class="code" title="function [c s] = givens(a,b)">givens</a>	Givens plane rotation [c s;-s c]. Entries c and s</li><li><a href="mvprod.html" class="code" title="">mvprod</a>	function lhs = mvprod(A,rhs,Gamma,flag)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="test_compute_delx.html" class="code" title="">test_compute_delx</a>	</li><li><a href="update_delx.html" class="code" title="">update_delx</a>	script to ubpdate delx</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function out = compute_delx(in,A)</a>
0002 <span class="comment">% This function solves a system of the form A^TA delx = z.</span>
0003 
0004 <span class="keyword">persistent</span> count_factor count_rec
0005 
0006 <span class="comment">% Recompute delx directly after max_rec iterations (otherwise update delx</span>
0007 <span class="comment">% recursively)</span>
0008 <span class="keyword">if</span> ~isfield(in, <span class="string">'max_rec'</span>), max_rec = 100; <span class="keyword">else</span> max_rec = in.max_rec; <span class="keyword">end</span>
0009 
0010 <span class="comment">% Recompute factorization/inverse directly after max_factor iterations</span>
0011 <span class="keyword">if</span> ~isfield(in,<span class="string">'max_factor'</span>), max_factor = 500; <span class="keyword">else</span> max_factor = in.max_factor; <span class="keyword">end</span>
0012 
0013 <span class="keyword">if</span> isempty(count_factor), count_factor = 0; <span class="keyword">end</span>
0014 <span class="keyword">if</span> isempty(count_rec), count_rec = 0; <span class="keyword">end</span>
0015 count_rec = count_rec+1;
0016 count_factor = count_factor+1;
0017 
0018 Gamma = in.Gamma;   <span class="comment">% Old signal support</span>
0019 <span class="comment">% add: no change</span>
0020 <span class="comment">% remove: outgoing index moved to the end</span>
0021 rhs = in.rhs; <span class="comment">% Full dimensional vector</span>
0022 delx = in.delx;
0023 T = length(Gamma);
0024 M = in.M;
0025 itr = in.itr;
0026 
0027 <span class="keyword">switch</span> in.type
0028     <span class="keyword">case</span> <span class="string">'mil'</span>
0029         <span class="comment">%% Matrix inversion lemma update</span>
0030         iAtA = in.iAtA;
0031         
0032         <span class="keyword">switch</span> in.add_rem
0033             <span class="keyword">case</span> 1
0034                 <span class="comment">% add a column</span>
0035                 new_x = in.new_x;
0036                 
0037                 ai = A(:,new_x);
0038                 <span class="comment">% Ata = A(:,Gamma)'*ai;</span>
0039                 <span class="comment">% Ata = mvprod(A,ai,Gamma,1);</span>
0040                 <span class="keyword">if</span> issparse(A)
0041                     Ata = A(:,Gamma)'*ai;
0042                 <span class="keyword">else</span>
0043                     Ata = <a href="mvprod.html" class="code" title="">mvprod</a>(A,ai,Gamma,1); <span class="comment">% elements of column k in A_Gamma'A_Gamma matrix</span>
0044                 <span class="keyword">end</span>                
0045                 <span class="comment">% Pai = iAtA(1:T,1:T)*Ata;</span>
0046                 Pai = iAtA*Ata;
0047                 
0048                 Si = ai'*ai-Ata'*Pai;
0049                 
0050                 at = [-Pai; 1]/sqrt(Si);
0051                 alpha = at'*rhs([Gamma; new_x]);
0052                 <span class="keyword">if</span> mod(itr, max_rec)
0053                     delx = [delx;0]+ alpha*at;
0054                 <span class="keyword">end</span>
0055                 
0056                 <span class="comment">% iAtA(1:ii,1:ii) = iAtA(1:ii,1:ii)+at*at';</span>
0057                 <span class="comment">% at = sparse([at; zeros(M-T-1,1)]);</span>
0058                 <span class="comment">% iAtA = iAtA + at*at';</span>
0059                 
0060                 iAtA(T+1,T+1) = 0;
0061                 iAtA = iAtA+at*at';
0062                 
0063                 <span class="comment">% iAtA = [iAtA zeros(T,1); zeros(1,T+1)] + at*at';</span>
0064                 
0065                 Gamma = [Gamma; new_x]; T = T+1;                                
0066                 
0067             <span class="keyword">case</span> 0
0068                 <span class="comment">% Remove a column</span>
0069                 new_order = in.new_order; <span class="comment">% New order for indices after putting outgoing index at the end</span>
0070                 out_i = in.out_i;
0071                 
0072                 <span class="comment">% With full matrix (any order)</span>
0073                 iAtA(1:T,1:T) = iAtA(new_order,new_order);
0074                 
0075                 <span class="comment">%         % With sparse matrix (two rows/columns swapped)</span>
0076                 <span class="comment">%         tmp = iAtA(:,out_i);</span>
0077                 <span class="comment">%         iAtA(:,out_i) = iAtA(:,T);</span>
0078                 <span class="comment">%         iAtA(:,T) = tmp;</span>
0079                 <span class="comment">%         tmp = iAtA(out_i,:);</span>
0080                 <span class="comment">%         iAtA(out_i,:) = iAtA(T,:);</span>
0081                 <span class="comment">%         iAtA(T,:) = tmp;</span>
0082                 
0083                 
0084                 Si = 1/iAtA(T,T);
0085                 at = [iAtA(1:T-1,T)*sqrt(Si); 1/sqrt(Si)];
0086                 ab = at(1:T-1);
0087                 alpha = at'*rhs(Gamma);
0088                 <span class="keyword">if</span> mod(itr, max_rec)
0089                     delx = delx(new_order);
0090                     delx = delx(1:T-1)-alpha*ab;
0091                 <span class="keyword">end</span>
0092                 
0093                 <span class="comment">%         iAtA(1:T-1,1:T-1) = iAtA(1:T-1,1:T-1)-ab*ab';</span>
0094                 <span class="comment">%         iAtA(T:end,:) = 0;</span>
0095                 <span class="comment">%         iAtA(:,T:end) = 0;</span>
0096                 <span class="comment">% at = sparse([at; zeros(M-T,1)]);</span>
0097                 iAtA = iAtA - at*at';
0098                 
0099                 iAtA(:,T) = []; iAtA(T,:) = [];
0100                 
0101                 Gamma = Gamma(1:end-1); T = T-1;                
0102                 
0103             <span class="keyword">case</span> 2
0104                 <span class="comment">% swap a column (standard rank-1 update)</span>
0105                 
0106                 <span class="comment">% First remove outgoing column then add incoming column</span>
0107                 new_order = in.new_order; <span class="comment">% New order for indices after putting outgoing index at the end</span>
0108                 out_i = in.out_i;
0109                 new_x = in.new_x;
0110                 Gamma_new = Gamma;
0111                 Gamma_new(end) = new_x;
0112                 
0113                 <span class="comment">% With full matrix (any order)</span>
0114                 iAtA(1:T,1:T) = iAtA(new_order,new_order);
0115                 
0116                 <span class="comment">% remove a column</span>
0117                 Si = 1/iAtA(T,T);
0118                 at = [iAtA(1:T-1,T)*sqrt(Si); 1/sqrt(Si)];
0119                 alpha = at'*rhs(Gamma);
0120                 <span class="comment">% delx = delx(new_order);</span>
0121                 <span class="comment">% delx  = delx-alpha*at;</span>
0122                 <span class="comment">% delx(end) = 0;</span>
0123                 
0124                 <span class="comment">% at = sparse([at; zeros(M-T,1)]);</span>
0125                 iAtA = iAtA - at*at';
0126                 iAtA(T,:) = []; iAtA(:,T) = [];
0127                 
0128                 Gamma = Gamma(1:end-1);
0129                 T = T-1;
0130                 
0131                 <span class="comment">% add column</span>
0132                 ai = A(:,new_x);
0133                 <span class="comment">% Ata = A(:,Gamma)'*ai;</span>
0134                 <span class="comment">% Ata = mvprod(A,ai,Gamma,1);</span>
0135                 <span class="keyword">if</span> issparse(A)
0136                     Ata = A(:,Gamma)'*ai;
0137                 <span class="keyword">else</span>
0138                     Ata = <a href="mvprod.html" class="code" title="">mvprod</a>(A,ai,Gamma,1); <span class="comment">% elements of column k in A_Gamma'A_Gamma matrix</span>
0139                 <span class="keyword">end</span>                
0140                 
0141                 Pai = iAtA*Ata;
0142                 Si = ai'*ai-Ata'*Pai;
0143                 at = [-Pai; 1]/sqrt(Si);
0144                 alpha = at'*rhs([Gamma; new_x]);
0145                 <span class="comment">% delx = delx+ alpha*at;</span>
0146                 
0147                 <span class="comment">% at = sparse([at; zeros(M-T-1,1)]);</span>
0148                 <span class="comment">% iAtA = iAtA + at*at';</span>
0149                 iAtA = [iAtA zeros(T,1); zeros(1,T+1)] + at*at';
0150                 
0151                 Gamma = [Gamma; new_x]; T = T+1;
0152                 delx = iAtA*rhs(Gamma);
0153         <span class="keyword">end</span>
0154         <span class="keyword">if</span> mod(itr, max_factor) == 0
0155             iAtA = pinv(A(:,Gamma)'*A(:,Gamma));
0156         <span class="keyword">end</span>
0157         <span class="keyword">if</span> mod(itr, max_rec) == 0;
0158             delx = iAtA(1:T,1:T)*rhs(Gamma);
0159         <span class="keyword">end</span>
0160         <span class="keyword">if</span> abs(Si) &lt; 1e-12
0161             disp(<span class="string">'Gram matrix severely ill-conditioned. Computing pseudo inverse!'</span>);
0162             iAtA = pinv(A(:,Gamma)'*A(:,Gamma));
0163             delx = iAtA(1:T,1:T)*rhs(Gamma);
0164         <span class="keyword">end</span>
0165         out.iAtA = iAtA;
0166         out.delx = delx;
0167         
0168     <span class="keyword">case</span> <span class="string">'qr'</span>
0169         <span class="comment">%% qr update (my code)</span>
0170         <span class="comment">% for when we are sensitive to the numerical sensitivity (I mean stability :p)</span>
0171         <span class="comment">% max_rec controls tradeoff between speed and accuracy</span>
0172         <span class="comment">% Set max_rec = 1, for the best accuracy</span>
0173         <span class="comment">% Set max_rec = inf, for the best speed</span>
0174         
0175         Q = in.Q;
0176         R = in.R;
0177         M = size(Q,1);
0178         
0179         <span class="keyword">switch</span> in.add_rem
0180             <span class="keyword">case</span> 1
0181                 <span class="comment">% add a column using modified Gram-Schmidt process</span>
0182                 new_x = in.new_x;
0183                 <span class="keyword">if</span> isfield(in,<span class="string">'nre'</span>)
0184                     <span class="comment">% Number of reorthogonalization steps</span>
0185                     NRE = in.nre;
0186                 <span class="keyword">else</span>
0187                     NRE = 1;
0188                 <span class="keyword">end</span>
0189                 
0190                 <span class="comment">% Q = [Q zeros(size(Q,1),1)];</span>
0191                 R = [R zeros(T,1); zeros(1,T) 0];
0192                 ai = A(:,new_x);
0193                 v = ai;
0194                 
0195                 <span class="comment">% See reorth comments in Stephen Becker's SVT code for</span>
0196                 <span class="comment">% reorthogonalization of Gram-Schmidt.</span>
0197                 alpha = 0.5; normr = norm(v); normr_old = 0; nre = 0;
0198                 <span class="keyword">while</span> normr &lt; alpha*normr_old || nre == 0
0199                     <span class="keyword">if</span> nre == 0
0200                         <span class="keyword">for</span> i=1:T
0201                             R(i,T+1) = Q(:,i)'*v; <span class="comment">% change ai to v for MGS...</span>
0202                             v = v - R(i,T+1)*Q(:,i); <span class="comment">% subtract the projection (q_j'a_j)q_j = (q_j'v)q_j!</span>
0203                         <span class="keyword">end</span>
0204                         R(T+1,T+1) = norm(v);
0205                     <span class="keyword">else</span>
0206                         <span class="keyword">for</span> i=1:T
0207                             t = Q(:,i)'*v; <span class="comment">% change ai to v for MGS...</span>
0208                             v = v - t*Q(:,i); <span class="comment">% subtract the projection (q_j'a_j)q_j = (q_j'v)q_j!</span>
0209                         <span class="keyword">end</span>
0210                     <span class="keyword">end</span>
0211                     normr_old = normr;
0212                     normr = norm(v);
0213                     nre = nre + 1;
0214                     <span class="keyword">if</span> nre &gt;= NRE
0215                         <span class="keyword">break</span>;
0216                     <span class="keyword">end</span>
0217                 <span class="keyword">end</span>
0218                 
0219                 <span class="comment">% pj = (Q(:,1:ii-1)'*ai);</span>
0220                 <span class="comment">% R(1:ii-1,ii) = pj;</span>
0221                 <span class="comment">% w = ai-Q(:,1:ii-1)*pj;</span>
0222                 
0223                 v = v/norm(v);
0224                 Q(:,T+1) = v;
0225                 <span class="comment">% Rc = R(1:ii,1:ii);</span>
0226                 <span class="comment">% Rct = Rc';</span>
0227                 <span class="comment">% delx_qr = Rc\(Rct\z(1:ii));</span>
0228                 <span class="keyword">if</span> mod(itr, max_rec)
0229                     ri = R\[zeros(T,1); 1];
0230                     delx = [delx; 0]+(ri'*rhs([Gamma; new_x]))*ri;
0231                 <span class="keyword">end</span>
0232                 Gamma = [Gamma; new_x];
0233             <span class="keyword">case</span> 0
0234                 <span class="comment">% Remove a column using Givens rotations (slower than MGS, but</span>
0235                 <span class="comment">% there is no other way... or is it? please tell me if you know one)</span>
0236                 
0237                 new_order = in.new_order; <span class="comment">% New order for indices after putting outgoing index at the end</span>
0238                 out_i = in.out_i;
0239                 
0240                 R = R(:,new_order);
0241                 
0242                 <span class="keyword">for</span> j = out_i:T-1
0243                     i = j+1;
0244                     [c, s] = <a href="givens.html" class="code" title="function [c s] = givens(a,b)">givens</a>(R(j,j), R(i,j));
0245                     <span class="comment">% R([j i],j:end) = [c s; -s c]'*R([j i],j:end);</span>
0246                     <span class="comment">% Qt([j i],:) = [c s; -s c]'*Qt([j i],:);</span>
0247                     R([j i],j:end) = [c -s; s c]*R([j i],j:end);
0248                     <span class="comment">% Qt([j i],:) = [c -s; s c]*Qt([j i],:);</span>
0249                     Q(:,[j i]) = Q(:,[j i])*[c s; -s c];
0250                 <span class="keyword">end</span>
0251                 R = triu(R);
0252                 
0253                 <span class="keyword">if</span> mod(itr, max_rec)
0254                     ri = R\[zeros(T-1,1); 1];
0255                     delx = delx(new_order);
0256                     delx = delx-(ri'*rhs(Gamma))*ri;
0257                     delx = delx(1:T-1);
0258                 <span class="keyword">end</span>
0259                 
0260                 R(:,T) = [];
0261                 R(T,:) = [];
0262                 <span class="comment">% R = R(1:T-1,1:T-1);</span>
0263                 <span class="comment">% Q = Q(:,1:T-1);</span>
0264                 Q(:,T) = [];
0265                 
0266                 Gamma = Gamma(1:end-1);
0267                 
0268             <span class="keyword">case</span> 2
0269                 <span class="comment">% swap two columns (standard rank-1 update)</span>
0270                 new_order = in.new_order; <span class="comment">% New order for indices after putting outgoing index at the end</span>
0271                 new_x = in.new_x;
0272                 out_i = in.out_i;
0273                 
0274                 R = R(:,new_order);
0275                 <span class="keyword">for</span> j = out_i:T-1
0276                     i = j+1;
0277                     [c, s] = <a href="givens.html" class="code" title="function [c s] = givens(a,b)">givens</a>(R(j,j), R(i,j));
0278                     <span class="comment">% R([j i],j:end) = [c s; -s c]'*R([j i],j:end);</span>
0279                     <span class="comment">% Qt([j i],:) = [c s; -s c]'*Qt([j i],:);</span>
0280                     R([j i],j:end) = [c -s; s c]*R([j i],j:end);
0281                     <span class="comment">% Qt([j i],:) = [c -s; s c]*Qt([j i],:);</span>
0282                     Q(:,[j i]) = Q(:,[j i])*[c s; -s c];
0283                 <span class="keyword">end</span>
0284                 
0285                 R = triu(R);
0286                 
0287                 <span class="comment">%             if mod(itr, max_rec)</span>
0288                 <span class="comment">%                 ri = R\[zeros(T-1,1); 1];</span>
0289                 <span class="comment">%                 delx = delx(new_order);</span>
0290                 <span class="comment">%                 delx_rec = delx-(ri'*rhs(Gamma))*ri;</span>
0291                 <span class="comment">%             end</span>
0292                 
0293                 <span class="comment">% ONLY APPLICABLE IF A_GAMMA IS A SQUARE MATRIX</span>
0294                 <span class="comment">% ri_old = ri; R_old = R;</span>
0295                 R(:,end) = Q'*A(:,new_x);
0296                 Gamma(end) = new_x;
0297                 <span class="comment">%             if mod(itr, max_rec)</span>
0298                 <span class="comment">%                 ri = R\[zeros(T-1,1); 1];</span>
0299                 <span class="comment">%                 delx = delx_rec+(ri'*rhs(Gamma))*ri;</span>
0300                 <span class="comment">%             end</span>
0301                 
0302                 <span class="comment">% figure(1); plot(delx_orig-delx); shg;</span>
0303                 
0304                 Rt = R';
0305                 delx = R\(Rt\rhs(Gamma));
0306         <span class="keyword">end</span>
0307         <span class="keyword">if</span> mod(itr, max_factor) == 0
0308             [Q R] = qr(A(:,Gamma),0);
0309         <span class="keyword">end</span>
0310         <span class="keyword">if</span> mod(itr, max_rec) == 0
0311             Rt = R';
0312             delx = R\(Rt\rhs(Gamma));
0313         <span class="keyword">end</span>
0314         out.Q = Q;
0315         out.R = R;
0316         out.delx = delx;
0317         
0318     <span class="keyword">case</span> <span class="string">'qrM'</span>
0319         <span class="comment">%% qr update (MATLAB)</span>
0320         Q0 = in.Q0;
0321         R0 = in.R0;
0322         
0323         <span class="keyword">switch</span> in.add_rem
0324             <span class="keyword">case</span> 1
0325                 <span class="comment">% add a column</span>
0326                 new_x = in.new_x;
0327                 ai = A(:,new_x);
0328                 [Q0, R0] = qrinsert(Q0,R0, T+1, ai,<span class="string">'col'</span>);
0329                 R0t = R0';
0330                 Gamma = [Gamma; new_x];
0331             <span class="keyword">case</span> 0
0332                 <span class="comment">% Remove a column</span>
0333                 out_i = in.out_i;
0334                 
0335                 [Q0, R0] = qrdelete(Q0,R0, out_i, <span class="string">'col'</span>);
0336                 R0t = R0';
0337                 Gamma = Gamma(1:end-1);
0338             <span class="keyword">case</span> 2
0339                 <span class="comment">% swap two columns (rank-1 update)</span>
0340                 out_i = in.out_i;
0341                 [Q0, R0] = qrdelete(Q0,R0, out_i, <span class="string">'col'</span>);
0342                 
0343                 new_x = in.new_x;
0344                 ai = A(:,new_x);
0345                 [Q0, R0] = qrinsert(Q0,R0, T, ai,<span class="string">'col'</span>);
0346                 R0t = R0';
0347                 
0348                 Gamma(end) = new_x;
0349         <span class="keyword">end</span>
0350         delx = R0\(R0t\rhs(Gamma));
0351         out.Q0 = Q0;
0352         out.R0 = R0;
0353         out.delx = delx;
0354         
0355     <span class="keyword">case</span> <span class="string">'chol'</span>
0356         <span class="comment">%% Cholesky update</span>
0357        
0358         <span class="comment">% Fast Cholesky insert and remove functions</span>
0359         <span class="comment">% Adopted from the PMTK toolbox</span>
0360         <span class="comment">% https://code.google.com/p/pmtksupport/source/browse/trunk/lars/lars.m</span>
0361         <span class="comment">%</span>
0362         <span class="comment">% PMTKauthor Karl Skoglund</span>
0363         <span class="comment">% PMTKurl http://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3897</span>
0364         <span class="comment">% IMM, DTU, kas@imm.dtu.dk</span>
0365 
0366         R = in.R;
0367         <span class="comment">% Updates R in a Cholesky factorization R'R = X'X of a data matrix X. R is</span>
0368         <span class="comment">% the current R matrix to be updated. x is a column vector representing the</span>
0369         <span class="comment">% variable to be added and X is the data matrix containing the currently</span>
0370         <span class="comment">% active variables (not including x).</span>
0371         <span class="comment">%</span>
0372         <span class="comment">% Suppose we have Cholesky factorization for A'A = R'R;</span>
0373         <span class="comment">% Now we want to update R factors for [A a]'[A a] = [A'A A'a; a'A a'a]</span>
0374         <span class="comment">% To do this write [A a]'[A a] = [R r]'[R r]</span>
0375         <span class="comment">% Now observe that ([R r]')^{-1}[A'a; a'a] = r;</span>
0376         <span class="comment">% Since [R r]' and R' are lower-triangular matrices, their inverses</span>
0377         <span class="comment">% are also lower-triangular. Moreover, the top part of r can be</span>
0378         <span class="comment">% computed by using inverse of R' alone, as (R')^{-1}A'a. Last</span>
0379         <span class="comment">% element in r can be computed by looking at norm(r) because</span>
0380         <span class="comment">% r'r = a'a.</span>
0381         
0382         <span class="keyword">switch</span>  in.add_rem
0383             <span class="keyword">case</span> 1
0384                 new_x = in.new_x;
0385                 ai = A(:,new_x);
0386                 diag_k = ai'*ai; <span class="comment">% diagonal element k in A'A matrix</span>
0387                 <span class="keyword">if</span> isempty(R)
0388                     R = sqrt(diag_k);
0389                 <span class="keyword">else</span>
0390                     <span class="keyword">if</span> issparse(A)
0391                         Ata = A(:,Gamma)'*ai;
0392                     <span class="keyword">else</span>
0393                         Ata = <a href="mvprod.html" class="code" title="">mvprod</a>(A,ai,Gamma,1); <span class="comment">% elements of column k in A_Gamma'A_Gamma matrix</span>
0394                     <span class="keyword">end</span>
0395                     
0396                     R_k = R'\Ata; <span class="comment">% R'R_k = (A'A)_k, solve for R_k</span>
0397                     R_kk = sqrt(diag_k - R_k'*R_k); <span class="comment">% norm(x'x) = norm(R'*R), find last element by exclusion</span>
0398                     R = [R R_k; [zeros(1,T) R_kk]]; <span class="comment">% update R</span>
0399                 <span class="keyword">end</span>
0400                 
0401                 <span class="keyword">if</span> mod(itr, max_rec)
0402                     ri = R\[zeros(T,1); 1];
0403                     delx = [delx; 0]+(ri'*rhs([Gamma; new_x]))*ri;
0404                 <span class="keyword">end</span>
0405                 Gamma = [Gamma; new_x];
0406                 
0407             <span class="keyword">case</span> 0
0408                 <span class="comment">% Deletes a variable from the X'X matrix in a Cholesky factorisation R'R =</span>
0409                 <span class="comment">% X'X. Returns the downdated R. This function is just a stripped version of</span>
0410                 <span class="comment">% Matlab's qrdelete.</span>
0411                 <span class="comment">% function R = choldelete(R,j)</span>
0412                 
0413                 j = in.out_i;                
0414                 R(:,j) = []; <span class="comment">% remove column j</span>
0415                 n = size(R,2);
0416                 <span class="keyword">for</span> k = j:n
0417                     p = k:k+1;
0418                     [G,R(p,k)] = planerot(R(p,k)); <span class="comment">% remove extra element in column</span>
0419                     <span class="keyword">if</span> k &lt; n
0420                         R(p,k+1:n) = G*R(p,k+1:n); <span class="comment">% adjust rest of row</span>
0421                     <span class="keyword">end</span>
0422                 <span class="keyword">end</span>
0423                 R(<span class="keyword">end</span>,:) = []; <span class="comment">% remove zero'ed out row</span>
0424                 Gamma = Gamma(1:end-1);
0425                 
0426                 Rt = R';
0427                 delx = R\(Rt\rhs(Gamma));
0428                 
0429             <span class="keyword">case</span> 2
0430                 disp(<span class="string">'Not implemented yet'</span>);
0431         <span class="keyword">end</span>
0432         <span class="keyword">if</span> mod(itr, max_factor) == 0
0433             [Q R] = qr(A(:,Gamma),0);
0434         <span class="keyword">end</span>
0435         <span class="keyword">if</span> mod(itr, max_rec) == 0
0436             Rt = R';
0437             delx = R\(Rt\rhs(Gamma));
0438         <span class="keyword">end</span>
0439         out.R = R;
0440         out.delx = delx;   
0441         
0442     <span class="keyword">case</span> <span class="string">'cg'</span>
0443         <span class="comment">%% conjugate gradient iterative update</span>
0444         W = diag(in.W);
0445         A_f = @(z) A(:,Gamma)*z;
0446         At_f = @(z)  A(:,Gamma)'*z;
0447         AtA_f = @(z) At_f(A_f(z));
0448         
0449         b = rhs(Gamma);<span class="comment">%-AtA_f([delx;0]); b(1:end-1) = 0;</span>
0450         x0 = in.x0(Gamma);
0451         cg_tol = 1e-12; cg_maxit = 500;
0452         [y,flag,relres,iter,resvec] = pcg(AtA_f,b,cg_tol,cg_maxit,W,[],x0);
0453         
0454         out.delx = y;
0455     <span class="keyword">otherwise</span>
0456         disp(<span class="string">'NOA'</span>);
0457 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>
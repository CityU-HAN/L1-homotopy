<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of demo_streamingLOT</title>
  <meta name="keywords" content="demo_streamingLOT">
  <meta name="description" content="demo_streamingLOT">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html L1_homotopy_v2.0 -->
<h1>demo_streamingLOT
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>demo_streamingLOT</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> demo_streamingLOT

 Solves the following streaming problem
 min_x  \|x\|_1 + 1/2*||A  x - y||_2^2

 by adding and removing one set of measurements at every time instant

 Applications:
           streaming signal recovery using lapped orthogonal transform (LOT)

 We can also add any other regularization operator in the reconstruction

 Written by: Salman Asif, Georgia Tech
 Email: sasif@gatech.edu
 Created: August 2012</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="l1homotopy.html" class="code" title="function out = l1homotopy(A, y, opts)">l1homotopy</a>	l1homotopy.m</li><li><a href="../L1_homotopy_v2.0/solvers/SpaRSA_adpW.html" class="code" title="function [x,x_debias,objective,times,debias_start,mses,taus, numA, numAt]=SpaRSA_adpW(y,A,tau,varargin)">SpaRSA_adpW</a>	SpaRSA version 2.0, December 31, 2007</li><li><a href="../L1_homotopy_v2.0/solvers/soft.html" class="code" title="function y = soft(x,T)">soft</a>	</li><li><a href="../L1_homotopy_v2.0/solvers/yall1.html" class="code" title="function [x, Out] = yall1(A, b, opts)">yall1</a>	</li><li><a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>	</li><li><a href="../L1_homotopy_v2.0/utils/genAmat.html" class="code" title="function A = genAmat(M,N,in);">genAmat</a>	</li><li><a href="../L1_homotopy_v2.0/utils/genSignal.html" class="code" title="function [x varargout] = genSignal(N,in)">genSignal</a>	Inputs</li><li><a href="../L1_homotopy_v2.0/utils/utils_LOT/apply_LOT.html" class="code" title="function alpha = apply_LOT(x,varargin)">apply_LOT</a>	Input</li><li><a href="../L1_homotopy_v2.0/utils/utils_LOT/create_LOT.html" class="code" title="function Psi = create_LOT(in)">create_LOT</a>	Creates the LOT representation matrix</li><li><a href="../L1_homotopy_v2.0/utils/utils_LOT/create_PHI.html" class="code" title="function PHI = create_PHI(in);">create_PHI</a>	Inputs</li><li><a href="../L1_homotopy_v2.0/utils/utils_LOT/create_PSI.html" class="code" title="function PSI = create_PSI(in)">create_PSI</a>	Arrange LOT syntheis matrices over P overlapping windows (edges ignored)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="readme.html" class="code" title="">readme</a>	----------L1 Homotopy Package-------------+</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% demo_streamingLOT</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Solves the following streaming problem</span>
0004 <span class="comment">% min_x  \|x\|_1 + 1/2*||A  x - y||_2^2</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% by adding and removing one set of measurements at every time instant</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Applications:</span>
0009 <span class="comment">%           streaming signal recovery using lapped orthogonal transform (LOT)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% We can also add any other regularization operator in the reconstruction</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% Written by: Salman Asif, Georgia Tech</span>
0014 <span class="comment">% Email: sasif@gatech.edu</span>
0015 <span class="comment">% Created: August 2012</span>
0016 
0017 clear
0018 close all force
0019 
0020 <span class="comment">% Limit the number of computational threads (for profiling)</span>
0021 <span class="comment">% maxNumCompThreads(1);</span>
0022 
0023 <span class="comment">%% Setup path</span>
0024 mname = mfilename;
0025 mpath = mfilename(<span class="string">'fullpath'</span>);
0026 mdir = mpath(1:end-length(mname));
0027 cd(mdir);
0028 
0029 addpath utils/
0030 addpath utils/utils_Wavelet
0031 addpath utils/utils_LOT
0032 addpath solvers/
0033 
0034 fprintf([<span class="string">'----------'</span>,datestr(now),<span class="string">'-------%s------------------\n'</span>],mname)
0035 
0036 <span class="comment">% load RandomStates</span>
0037 <span class="comment">%</span>
0038 rseed = 2013;
0039 rand(<span class="string">'state'</span>,rseed);
0040 randn(<span class="string">'state'</span>,rseed);
0041 
0042 <span class="comment">% simulation parameters</span>
0043 mType = <span class="string">'sign'</span>; <span class="comment">% {'randn','orth','rdct','streaming','subsample'};</span>
0044 sType = <span class="string">'LinChirp'</span>; <span class="comment">% % menu('Choose function:', 'LinChirp', 'TwoChirp', 'QuadChirp', 'MishMash','HypChirps','LinChirps', 'Chirps');</span>
0045 SNR = 35;       <span class="comment">% additive Gaussian noise</span>
0046 
0047 N = 256;   <span class="comment">% signal length</span>
0048 R = 8;      <span class="comment">% compression rate</span>
0049 M = round(N/R);    <span class="comment">% no. of measurements</span>
0050 
0051 <span class="comment">% signal length</span>
0052 sig_length = 2^15; <span class="comment">% 128*128;</span>
0053 
0054 <span class="comment">% streaming window</span>
0055 P = 5; <span class="comment">% size of the working window is P*N</span>
0056 
0057 <span class="comment">% signal extension for prediction of new coefficients.</span>
0058 eType = <span class="string">'sym'</span>;
0059 
0060 <span class="comment">% add snapshots of the signal in streaming window and average them before comitting to the output.</span>
0061 avg_output = 0;
0062 
0063 <span class="comment">% rank-1 update mode</span>
0064 delx_mode = <span class="string">'mil'</span>; <span class="comment">% mil or qr</span>
0065 
0066 verbose = 0;
0067 
0068 <span class="comment">%% LOT setup</span>
0069 <span class="comment">% Length of each window is L = N. (extend to adaptive/dyadic windows later?)</span>
0070 eta = 1/2*N; <span class="comment">% overlapping factor on the left edge (2*eta samples are shared by adjacent windows)</span>
0071 eta1 = eta; <span class="comment">% overlapping factor on the right edge</span>
0072 lp = N; <span class="comment">% length of the first interval</span>
0073 
0074 in_Psi = []; in_Psi.L = lp; in_Psi.eta = eta; in_Psi.eta1 = eta1;
0075 Psi = <a href="../L1_homotopy_v2.0/utils/utils_LOT/create_LOT.html" class="code" title="function Psi = create_LOT(in)">create_LOT</a>(in_Psi); <span class="comment">% LOT synthesis matrix over a window</span>
0076 <span class="comment">% Psi_right = create_LOT_right(N,eta);</span>
0077 in_Psi.eta1 = 0;
0078 Psi_right = <a href="../L1_homotopy_v2.0/utils/utils_LOT/create_LOT.html" class="code" title="function Psi = create_LOT(in)">create_LOT</a>(in_Psi);
0079 
0080 ETA = [eta; eta1];
0081 Lp = [lp];
0082 <span class="comment">% Need to control them in a better way</span>
0083 <span class="comment">% Right now I divide signal into equal intervals and assign them same</span>
0084 <span class="comment">% transition parameters.</span>
0085 
0086 <span class="comment">%% SM: Sampling modes</span>
0087 <span class="comment">% 'universal' sampling scheme</span>
0088 <span class="comment">% (align before the overlapping regions of ?2 LOT windows that are measured)</span>
0089 <span class="comment">%</span>
0090 SM = 3; <span class="comment">% Other sampling modes removed from this release...</span>
0091 SM3_overlap = 0; <span class="comment">% overlapping or block diagonal system for measurements!</span>
0092 <span class="keyword">if</span> SM3_overlap == 0
0093     <span class="comment">% disjoint measurement windows</span>
0094     LM = N;
0095     LeftEdge_trunc = 0;
0096 <span class="keyword">else</span>
0097     <span class="comment">% LM: length of measurement window (e.g., LM = 2*N-2*eta)</span>
0098     <span class="comment">% overlapping measurement windows</span>
0099     LM = 2*N;
0100     LeftEdge_trunc = 0;
0101 <span class="keyword">end</span>
0102 LeftProj_cancel = 1;
0103 
0104 fprintf(<span class="string">'Streaming signal measureed and reconstructed with overlapping windows using LOT ... \n'</span>);
0105 <span class="comment">% str0 = sprintf('mType-%s, sType-%s, SNR = %d, (N,M,R) = %d, %d, %d, SM = %d, P = %d, eta_frac = %4.3g, LM = %d, signal length = %d.', mType, sType, SNR, N, M, R, SM, P,eta/N, LM, sig_length);</span>
0106 str0 = sprintf(<span class="string">'mType-%s, sType-%s, SNR = %d, (N,M,R) = %d, %d, %d, P = %d, SM = %d, LM = %d, \n eta_frac = %4.3g, eType = %s; specified signal-length = %d.'</span>, mType, sType, SNR, N, round(N/R), R, P, SM, LM, eta/N, eType, sig_length);
0107 disp(str0);
0108 
0109 <span class="comment">%% Read signal</span>
0110 in = []; in.type = sType; in.take_fwt = 0; in.Np = 4*N;
0111 <span class="comment">% [sigW sig wave_struct] = genSignal(sig_length,in);</span>
0112 sig = <a href="../L1_homotopy_v2.0/utils/genSignal.html" class="code" title="function [x varargout] = genSignal(N,in)">genSignal</a>(sig_length,in);
0113 sig = [zeros(2*eta+1,1); sig];
0114 sig_length = length(sig);
0115 
0116 <span class="comment">% view LOT coefficients...</span>
0117 alpha_vec = <a href="../L1_homotopy_v2.0/utils/utils_LOT/apply_LOT.html" class="code" title="function alpha = apply_LOT(x,varargin)">apply_LOT</a>(sig,N,eta);
0118 figure(123); imagesc(reshape(alpha_vec,N,length(alpha_vec)/N));
0119 axis xy;
0120 <span class="comment">% view spectrogram...</span>
0121 <span class="comment">% N = 256; figure(N); spectrogram(sig,N*1,0,N,length(sig),'yaxis');</span>
0122 
0123 <span class="comment">%% Save results..</span>
0124 streaming_iter = ceil(length(sig)/N);
0125 SIM_stack = cell(streaming_iter,1);
0126 SIM_memory = cell(streaming_iter,1);
0127 
0128 x_vec = zeros(N*streaming_iter,1);
0129 xh_vec = zeros(N*streaming_iter,3);
0130 sig_vec = zeros(length(sig),1);
0131 sigh_vec = zeros(length(sig),3);
0132 
0133 <span class="comment">%% Create analysis/synthesis matrix explicitly</span>
0134 in = [];
0135 in.P = P; in.Psi = Psi;
0136 ETA = eta*ones(P+1,1);
0137 Lp = N*ones(P,1);
0138 eta = ETA(1);
0139 eta1 = ETA(end);
0140 <span class="keyword">if</span> length(ETA)~=P+1
0141     error(<span class="string">'number of LOT parameters not correct'</span>);
0142 <span class="keyword">end</span>
0143 in.ETA = ETA; in.Lp = Lp;
0144 PSI = <a href="../L1_homotopy_v2.0/utils/utils_LOT/create_PSI.html" class="code" title="function PSI = create_PSI(in)">create_PSI</a>(in);
0145 
0146 <span class="comment">%% Setup sensing matrices</span>
0147 in = []; in.type = mType; in.parts = 4;
0148 genAmat_h = @(M,N) <a href="../L1_homotopy_v2.0/utils/genAmat.html" class="code" title="function A = genAmat(M,N,in);">genAmat</a>(M,N,in);
0149 in.P = P+1-floor(LM/N);
0150 in.LM = LM; in.M = M; in.N = N;
0151 PHI = <a href="../L1_homotopy_v2.0/utils/utils_LOT/create_PHI.html" class="code" title="function PHI = create_PHI(in);">create_PHI</a>(in);
0152 
0153 <span class="comment">%% Overall streaming system matrix</span>
0154 T_length = 2*eta+P*N;
0155 t_ind = 1:T_length;
0156 
0157 sigt = sig(t_ind); <span class="comment">% Signal under the LOT window at time t</span>
0158 x = PSI'*sigt; <span class="comment">% Sparse LOT coefficients</span>
0159 
0160 <span class="keyword">if</span> SM3_overlap == 0
0161     PSI_M = PSI(1:end-2*eta1,:);
0162 <span class="keyword">else</span>
0163     PSI_M = PSI(1:end-2*eta1,:);
0164 <span class="keyword">end</span>
0165 A = PHI*PSI_M;
0166 <span class="keyword">if</span> SM3_overlap == 0
0167     y = PHI*sigt(1:end-2*eta1);
0168 <span class="keyword">else</span>
0169     y = PHI*sigt(1:end-2*eta1);
0170 <span class="keyword">end</span>
0171 
0172 leny = length(y);
0173 sigma = sqrt(norm(y)^2/10^(SNR/10)/leny);
0174 e = randn(leny,1)*sigma;
0175 y = y+e;
0176 
0177 <span class="comment">% parameter selection</span>
0178 <span class="comment">% tau = sigma*sqrt(log(N));</span>
0179 tau = max(1e-2*max(abs(A'*y)),sigma*sqrt(log(P*N)));
0180 
0181 maxiter = 2*P*N;
0182 err_fun = @(z) (norm(x-z)/norm(x))^2;
0183 
0184 <span class="comment">%% Initialize by solving a rwt L1 problem</span>
0185 in = [];
0186 in.tau = tau; W = tau;
0187 in.W = W;
0188 in.delx_mode = delx_mode;
0189 in.debias = 0;
0190 in.verbose = 0;
0191 in.plots = 0;
0192 in.record = 1;
0193 in.err_fun = err_fun;
0194 tic
0195 <span class="keyword">for</span> wt_itr = 1:5
0196     
0197     out = <a href="l1homotopy.html" class="code" title="function out = l1homotopy(A, y, opts)">l1homotopy</a>(A,y,in);
0198     xh = out.x_out;
0199     iter_bpdn = out.iter;
0200     time_bpdn = toc;
0201     gamma_bpdn = out.gamma;
0202     
0203     <span class="comment">% Update weights</span>
0204     xh_old = xh;
0205     
0206     alpha = 1; epsilon = 1;
0207     beta = M*(norm(xh,2)/norm(xh,1))^2;
0208     W = tau/alpha./(beta*abs(xh)+epsilon);
0209     
0210     W_old = W;
0211     yh = A*xh;
0212     Atr = A'*(A*xh-y);
0213     u =  -W.*sign(xh)-Atr;
0214     pk_old = Atr+u;
0215     
0216     in = out;
0217     in.xh_old = xh;
0218     in.pk_old = pk_old;
0219     in.u = u;
0220     in.W_old = W_old;
0221     in.W = W;
0222 <span class="keyword">end</span>
0223 W = W_old;
0224 
0225 sim = 1;
0226 x_vec((sim-1)*N+1:sim*N,1) = x(1:N);
0227 xh_vec((sim-1)*N+1:sim*N,1:3) = [xh(1:N) xh(1:N) xh(1:N)];
0228 
0229 s_ind = 1:N+2*eta1;
0230 sig_temp = Psi*xh(1:N);
0231 s_offset = 0;
0232 
0233 sig_vec(s_ind) = sigt(s_ind);
0234 sigh_vec(s_ind,1:3) = sigh_vec(s_ind,1:3)+[sig_temp sig_temp sig_temp];
0235 
0236 <span class="comment">% average instantaneous estimates before committing to output...</span>
0237 estimate_buffer = repmat(xh(1:(P-1)*N,1),1,P-1)/(P-1);
0238 
0239 xh_streamingRWT = xh;
0240 x_sparsa = xh;
0241 x_yall1 = xh;
0242 
0243 done = 0;
0244 <span class="keyword">while</span> ~done
0245     
0246     
0247     <span class="comment">%% Update the solution after updating the measurement matrix and/or the</span>
0248     <span class="comment">% sparse signal</span>
0249     y_old = y; x_old = x;
0250     
0251     sigt_old = sigt; t_ind_old = t_ind;
0252     PHI_old = PHI;
0253     PSI_old = PSI;
0254     
0255     <span class="comment">% change the LOT parameters for the incoming window?</span>
0256     <span class="comment">% eta or lp ??</span>
0257     Psi_out = PSI(1:N+ETA(1)+ETA(2),1:N);
0258     ETA_old = ETA;
0259     ETA = [ETA(2:end); eta];
0260     Lp_old = Lp;
0261     Lp = [Lp(2:end); N];
0262     eta = ETA(1); eta1 = ETA(end);
0263     in.ETA = ETA; in.Lp = Lp;
0264     <span class="comment">% PSI = create_PSI(in);</span>
0265     
0266     <span class="comment">% Shift the sampling window</span>
0267     t_ind = t_ind+N;
0268     <span class="keyword">if</span> t_ind(end) &gt; length(sig)
0269         <span class="keyword">break</span>;
0270     <span class="keyword">end</span>
0271     sigt = sig(t_ind);
0272     
0273     <span class="comment">% System matrix setup...</span>
0274     <span class="comment">% Shift up and left</span>
0275     PHI(1:end-M,1:end-N) = PHI(M+1:<span class="keyword">end</span>,N+1:end);
0276     <span class="comment">% new measurement matrix</span>
0277     Phi = genAmat_h(M,LM);
0278     PHI(end-M+1:<span class="keyword">end</span>,end-LM+1:end) = Phi;
0279     
0280     A = PHI*PSI_M;
0281     <span class="keyword">if</span> SM3_overlap == 0
0282         y = PHI*sigt(1:end-2*eta);
0283     <span class="keyword">else</span>
0284         y = PHI*sigt(1:end-2*eta1);
0285     <span class="keyword">end</span>
0286     <span class="comment">% y(1:M) = y(1:M)-PHI(1:M,1:2*eta)*(Psi(end-2*eta+1:end,:)*xh(1:N));</span>
0287     
0288     
0289     <span class="comment">% Sparse LOT coeffs. irrespective of SM</span>
0290     x = PSI'*sigt;
0291     
0292     <span class="comment">% shift old measurements and add one new set of measurementts</span>
0293     e(1:end-M) = e(M+1:end);
0294     e(end-M+1:end) = randn(M,1)*sigma;
0295     y= y+e;
0296     
0297     A0 = A; x0 = x; y0 = y;
0298     <span class="keyword">for</span> solver = {<span class="string">'l1homotopy'</span>,<span class="string">'sparsa'</span>,<span class="string">'yall1'</span>}
0299         solver = char(solver);
0300         <span class="keyword">switch</span> solver
0301             <span class="keyword">case</span> <span class="string">'l1homotopy'</span>
0302                 xh = xh_streamingRWT;
0303             <span class="keyword">case</span> <span class="string">'sparsa'</span>
0304                 xh = x_sparsa;
0305             <span class="keyword">case</span> <span class="string">'yall1'</span>
0306                 xh = x_yall1;
0307         <span class="keyword">end</span>
0308         y = y0; A = A0; x = x0;
0309         xh_old = xh;
0310         
0311         <span class="comment">% REMOVE the part of outgoing LOT projection in the overlapping region</span>
0312         <span class="comment">% on left side of streaming window...</span>
0313         <span class="comment">% LOT projection of sigt = \Psi_p[O_p] \alpha_p + \Psi_{p-1}[O_p] \alpha_{p-1}</span>
0314         <span class="comment">% where latter is the unwanted part in sigt</span>
0315         <span class="comment">% sigt_proj0 = Psi(end-2*eta+1:end,:)*xh_old(1:N);</span>
0316         <span class="comment">% sigt_proj = sigt;</span>
0317         <span class="comment">% sigt_proj(1:2*eta) = sigt(1:2*eta)-sigt_proj0;</span>
0318         <span class="comment">% ys = y-PHI(:,1:2*eta)*sigt_proj0;</span>
0319         <span class="keyword">if</span> LeftProj_cancel
0320             y(1:M) = y(1:M)-PHI(1:M,1:2*eta)*(Psi_out(end-2*eta+1:<span class="keyword">end</span>,:)*xh_old(1:N));
0321         <span class="keyword">end</span>
0322         
0323         <span class="comment">%% Update the signal estimate (for warm start)</span>
0324         xh(1:end-N) = xh(N+1:end);
0325         <span class="comment">% truncate small values in xh</span>
0326         <span class="comment">% xh(abs(xh)&lt;tau/sqrt(log(P*N))) = 0;</span>
0327         
0328         <span class="comment">%--------------------------------------------%</span>
0329         <span class="comment">% Linear prediction for the incoming samples %</span>
0330         <span class="comment">%--------------------------------------------%</span>
0331         
0332         xh1 = xh(end-N+1:end);
0333         
0334         <span class="keyword">if</span> strcmpi(eType,<span class="string">'per'</span>)
0335             <span class="comment">% periodic extension</span>
0336             xh1 = xh(end-N+1:end);
0337         <span class="keyword">else</span>
0338             sig_temp = PSI_M(1:end-N,1:(P-1)*N)*xh(1:end-N);
0339             sig_temp(1:2*eta) = sig_temp(1:2*eta)+Psi(end-2*eta+1:<span class="keyword">end</span>,:)*xh_old(1:N);
0340             <span class="comment">% if sim == 1</span>
0341             <span class="comment">%     fprintf('Extension type: %s \n',eType);</span>
0342             <span class="comment">% end</span>
0343             <span class="keyword">switch</span> eType
0344                 <span class="keyword">case</span> <span class="string">'asym'</span>
0345                     <span class="comment">% anti-symmetric extension</span>
0346                     sig_temp2 = [sig_temp; -sig_temp(end:-1:1); sig_temp];
0347                 <span class="keyword">case</span> <span class="string">'sym'</span>
0348                     <span class="comment">% symmetrci extension</span>
0349                     sig_temp2 = [sig_temp; sig_temp(end:-1:1); sig_temp];
0350                 <span class="keyword">otherwise</span>
0351                     disp(<span class="string">'cant do it sire'</span>);
0352             <span class="keyword">end</span>
0353             sig_temp2 = sig_temp2(1:P*N+2*eta);
0354             xh_temp = PSI'*sig_temp2;
0355             xh1 = xh_temp(end-N+1:end);
0356         <span class="keyword">end</span>
0357         
0358         gamma1 = find(abs(xh1)&gt;tau);
0359         [val ind] = sort(abs(xh1),<span class="string">'descend'</span>);
0360         gamma1 = ind(1:min(length(gamma1),ceil(M/log2(N))));
0361         
0362         yt = y(end-M+1:end)-A(end-M+1:<span class="keyword">end</span>,1:end-N)*xh(1:end-N);
0363         At = A(end-M+1:<span class="keyword">end</span>,end-N+1:end);
0364         gamma3 = gamma1;
0365         <span class="comment">%</span>
0366         <span class="comment">% NOTE TODO: Need to replace prediction with rank-update...</span>
0367         <span class="comment">%</span>
0368         <span class="comment">% gamma_all = [find(xh(1:end-N)); gamma3+(P-1)*N];</span>
0369         <span class="comment">% xh_all = 0*xh;</span>
0370         <span class="comment">% xh_all(gamma_all) = A(:,gamma_all)\y; % inv(A(:,gamma_all)'*A(:,gamma_all))*(A(:,gamma_all)'*y-W(gamma_all).*sign(xh(gamma_all)));</span>
0371         
0372         xh_t1 = 0*xh(end-N+1:end);
0373         xh_t1(gamma3) = pinv(At(:,gamma3)'*At(:,gamma3)+2*tau*eye(length(gamma3)))*(At(:,gamma3)'*yt);
0374         xh_t1(abs(xh_t1)&lt;tau/sqrt(log(N))) = 0;
0375         xh(end-N+1:end) = xh_t1;
0376         
0377         <span class="comment">% Filter previous instances?</span>
0378         <span class="comment">%</span>
0379         <span class="comment">% [a b] = lpc(sigh);</span>
0380         <span class="comment">% est_sig = filter([0 -a(2:end)],1,sigh);</span>
0381         <span class="comment">%</span>
0382         <span class="comment">% [val ind] = sort(abs(xh(end-N+1:end)),'descend');</span>
0383         <span class="comment">% xh_t(ind(M+1:end)) = 0;</span>
0384         <span class="comment">%</span>
0385         <span class="comment">%     if P&gt;1</span>
0386         <span class="comment">%         % Learn the variations in the support ???</span>
0387         <span class="comment">%         xh2 = xh(end-2*N+1:end-N);</span>
0388         <span class="comment">%         gamma2 = find(abs(xh2)&gt;0*tau);</span>
0389         <span class="comment">%         [val ind] = sort(abs(xh2),'descend');</span>
0390         <span class="comment">%         gamma2 = ind(1:min(length(gamma2),length(gamma1)));</span>
0391         <span class="comment">%     end</span>
0392         
0393         <span class="comment">% Truncate small coefficients... ?</span>
0394         <span class="comment">% xh(abs(xh)&lt;tau/sqrt(log(P*N))) = 0;</span>
0395         <a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(111);
0396         plot([x xh]);
0397         
0398         <span class="comment">% Remove the top-left edge of the system matrix</span>
0399         <span class="keyword">if</span> LeftEdge_trunc
0400             <span class="comment">% fprintf('Consider oldest set of LOT coefficients to be fully known, and remove their contribution from the measurements... \n');</span>
0401             alpha0h = xh(1:N);
0402             xh = xh(N+1:end);
0403             y = y-A(:,1:N)*alpha0h;
0404             
0405             A = A(:,N+1:end);
0406             alpha0 = x(1:N);
0407             x = x(N+1:end);
0408         <span class="keyword">end</span>
0409         
0410         <span class="comment">% Update weights</span>
0411         epsilon = 1;
0412         beta = max(epsilon,M*(norm(xh,2)/norm(xh,1))^1);
0413         W = tau/alpha./(beta*abs(xh)+epsilon);
0414         
0415         W_old = W;
0416         
0417         
0418         <span class="keyword">if</span> strcmpi(solver,<span class="string">'l1homotopy'</span>)
0419             
0420             homotopy_mode = <span class="string">'dummy'</span>;
0421             <span class="keyword">switch</span> homotopy_mode
0422                 <span class="keyword">case</span> <span class="string">'dummy'</span>
0423                     <span class="comment">% create a dummy variable...</span>
0424                     <span class="comment">% use homotopy on the measurements...</span>
0425                     <span class="comment">% in principle, we can start with any xh with this formulation</span>
0426                     <span class="comment">% and any starting value of tau or W...</span>
0427                     gamma = find(xh);
0428                     M_trunc = size(A,1); <span class="comment">% P*(M-1);</span>
0429                     <span class="comment">% M_trunc = round(P*(N-1)/5);</span>
0430                     <span class="keyword">if</span> length(gamma) &gt;= M_trunc
0431                         disp(<span class="string">'length of gamma exceeded number of rows'</span>);
0432                         [xh_sort ind_sort] = sort(abs(xh),<span class="string">'descend'</span>);
0433                         xh(ind_sort(M_trunc+1:end)) = 0;
0434                         gamma = ind_sort(1:M_trunc);
0435                     <span class="keyword">end</span>
0436                     Atr = A'*(A*xh-y);
0437                     u =  -W.*sign(xh)-Atr;
0438                     pk_old = Atr+u;
0439                 <span class="keyword">otherwise</span>
0440                     didp(<span class="string">'Go back ... no escape'</span>);
0441             <span class="keyword">end</span>
0442             
0443             
0444             in = out;
0445             gamma_old = gamma;
0446             in.gamma = gamma_old;
0447             <span class="keyword">switch</span> delx_mode
0448                 <span class="keyword">case</span> <span class="string">'mil'</span>;
0449                     <span class="comment">% in.delx_mode = 'mil';</span>
0450                     <span class="comment">% The following gram matrix and its inverse can be used from the</span>
0451                     <span class="comment">% previous homotopy. Too lazy to include that right now...</span>
0452                     <span class="comment">% wt BPDN homotopy update</span>
0453                     AtAgx = A(:,gamma_old)'*A(:,gamma_old);
0454                     iAtAgx = pinv(AtAgx);
0455                     in.iAtA = iAtAgx;
0456                 <span class="keyword">case</span> {<span class="string">'qr'</span>,<span class="string">'chol'</span>};
0457                     <span class="comment">% in.delx_mode = 'qr';</span>
0458                     [Q R] = qr(A(:,gamma_old),0);
0459                     in.Q = Q; in.R = R;
0460                 <span class="keyword">case</span> <span class="string">'qrM'</span>
0461                     <span class="comment">% in.delx_mode = 'qrM';</span>
0462                     [Q0 R0] = qr(A(:,gamma_old));
0463                     in.Q0 = Q0; in.R0 = R0;
0464             <span class="keyword">end</span>
0465             
0466             in.xh_old = xh;
0467             in.pk_old = pk_old;
0468             in.u = u;
0469             in.W = W;
0470             in.delx_mode = delx_mode;
0471             in.debias = 0;
0472             in.verbose = 0;
0473             in.plots = 0;
0474             in.record = 1;
0475             in.err_fun = @(z) (norm(x-z)/norm(x))^2;
0476             tic
0477             out = <a href="l1homotopy.html" class="code" title="function out = l1homotopy(A, y, opts)">l1homotopy</a>(A,y,in);
0478             time_streamingRWT = toc;
0479             xh_streamingRWT = out.x_out;
0480             gamma_streamingRWT = out.gamma;
0481             iter_streamingRWT = out.iter;
0482             
0483             <span class="comment">%     fig(333); clf; plot([xh_streamingRWT])</span>
0484             <span class="comment">%     hold on;</span>
0485             <span class="comment">%     plot(xh_old,':k')</span>
0486             <span class="comment">%     plot(setxor(gamma_old,gamma_streamingRWT),0,'r.')</span>
0487             <span class="comment">%     plot(x,'--m')</span>
0488             
0489             <span class="comment">% Check the solution using BPDN directly with l1homotopy</span>
0490             <span class="comment">%     in = []; x_old = x;</span>
0491             <span class="comment">%     in.W = W;</span>
0492             <span class="comment">%     in.delx_mode = delx_mode;</span>
0493             <span class="comment">%     in.debias = 0;</span>
0494             <span class="comment">%     in.verbose = 0;</span>
0495             <span class="comment">%     in.maxiter = maxiter;</span>
0496             <span class="comment">%     in.plots = 0;</span>
0497             <span class="comment">%     in.record = 1;</span>
0498             <span class="comment">%     in.err_fun = err_fun;</span>
0499             <span class="comment">%     tic</span>
0500             <span class="comment">%     out = l1homotopy(A,y,in);</span>
0501             <span class="comment">%     xh = out.x_out;</span>
0502             <span class="comment">%     iter_bpdn = out.iter;</span>
0503             <span class="comment">%     time_bpdn = toc;</span>
0504             <span class="comment">%     gamma_bpdn = out.gamma;</span>
0505             <span class="comment">%     err_bpdn = out.error_table;</span>
0506             <span class="keyword">if</span> LeftEdge_trunc
0507                 xh_streamingRWT = [alpha0h; xh_streamingRWT];
0508                 x = [alpha0; x];
0509             <span class="keyword">end</span>
0510         <span class="keyword">elseif</span>  strcmpi(solver,<span class="string">'sparsa'</span>)
0511             <span class="comment">%% SpaRSA</span>
0512             x_sparsa = xh; W_sparsa = W/tau; iter_sparsa = 0; time_sparsa = 0;
0513             <span class="keyword">if</span> norm(y) &gt; 1e-3
0514                 psi_function = @(x,tau) <a href="../L1_homotopy_v2.0/solvers/soft.html" class="code" title="function y = soft(x,T)">soft</a>(x,tau*W_sparsa);
0515                 phi_function = @(x) sum(abs(W_sparsa.*x));
0516                 tic;
0517                 [x_sparsa,x_debias_SpaRSA_m,obj_SpaRSA_m_cont,<span class="keyword">...</span>
0518                     times_SpaRSA_m_cont,debias_start_SpaRSA_m,mse_SpaRSA_m,taus_SpaRSA_m, numA, numAt]= <span class="keyword">...</span>
0519                     <a href="../L1_homotopy_v2.0/solvers/SpaRSA_adpW.html" class="code" title="function [x,x_debias,objective,times,debias_start,mses,taus, numA, numAt]=SpaRSA_adpW(y,A,tau,varargin)">SpaRSA_adpW</a>(y,A,tau,<span class="keyword">...</span>
0520                     <span class="string">'Monotone'</span>,0,<span class="keyword">...</span>
0521                     <span class="string">'adp_wt'</span>,0,<span class="keyword">...</span>
0522                     <span class="string">'W_new'</span>,W_sparsa,<span class="keyword">...</span>
0523                     <span class="string">'Debias'</span>,0,<span class="keyword">...</span>
0524                     <span class="string">'Initialization'</span>,x_sparsa,<span class="keyword">...</span>
0525                     <span class="string">'StopCriterion'</span>,2,<span class="keyword">...</span>
0526                     <span class="string">'ToleranceA'</span>,1e-4,<span class="keyword">...</span>
0527                     <span class="string">'psi'</span>,psi_function,<span class="keyword">...</span>
0528                     <span class="string">'phi'</span>,phi_function,<span class="keyword">...</span>
0529                     <span class="string">'Safeguard'</span>,1,<span class="keyword">...</span>
0530                     <span class="string">'MaxiterA'</span>,maxiter,<span class="keyword">...</span>
0531                     <span class="string">'Verbose'</span>,0,<span class="keyword">...</span>
0532                     <span class="string">'True_x'</span>,x,<span class="keyword">...</span>
0533                     <span class="string">'Continuation'</span>,1,<span class="keyword">...</span>
0534                     <span class="string">'Continuationsteps'</span>,-1);
0535                 
0536                 time_sparsa = toc;
0537                 iter_sparsa = (numA+numAt)/2;
0538                 error_sparsa = norm(x-x_sparsa)/norm(x);
0539             <span class="keyword">end</span>
0540             <span class="keyword">if</span> LeftEdge_trunc
0541                 x_sparsa = [alpha0h; x_sparsa];
0542                 x = [alpha0; x];
0543             <span class="keyword">end</span>
0544         <span class="keyword">elseif</span> strcmpi(solver,<span class="string">'yall1'</span>)
0545             <span class="comment">%% YALL1</span>
0546             <span class="comment">% set options</span>
0547             digit = 4; <span class="keyword">if</span> sigma &gt; 0; digit = 4; <span class="keyword">end</span>
0548             opts = [];
0549             opts.tol = 10^(-digit);
0550             opts.weights = W/tau;
0551             opts.print = 0;
0552             opts.maxit = maxiter;
0553             opts.x0 = xh;
0554             opts.nu = 0; opts.rho = tau;
0555             tic;
0556             [x_yall1,Out_yall1] = <a href="../L1_homotopy_v2.0/solvers/yall1.html" class="code" title="function [x, Out] = yall1(A, b, opts)">yall1</a>(A,y,opts);
0557             <span class="comment">% time_yall1 = [time_yall1 Out.cputime];</span>
0558             time_yall1 = toc;
0559             iter_yall1 = (Out_yall1.cntA+Out_yall1.cntAt)/2;
0560             err_yall1 = norm(x-x_yall1)/norm(x);
0561             <span class="keyword">if</span> LeftEdge_trunc
0562                 x_yall1 = [alpha0h; x_yall1];
0563                 x = [alpha0; x];
0564             <span class="keyword">end</span>
0565         <span class="keyword">end</span>
0566     <span class="keyword">end</span>
0567     <span class="comment">%% Record results</span>
0568     sim = sim+1;
0569     SIM_stack{sim} = [sim, tau, <span class="keyword">...</span>
0570         norm(x-xh_streamingRWT)^2/norm(x)^2, sum(iter_streamingRWT,2), sum(time_streamingRWT,2), <span class="keyword">...</span>
0571         norm(x-x_sparsa)^2/norm(x)^2, sum(iter_sparsa,2), sum(time_sparsa,2), <span class="keyword">...</span>
0572         norm(x-x_yall1)^2/norm(x)^2, sum(iter_yall1,2), sum(time_yall1,2)];
0573     
0574     <span class="comment">% print and plot</span>
0575     <span class="keyword">if</span> mod(sim-1,verbose) == 0 &amp;&amp; verbose
0576         fprintf(<span class="string">'streaming iter. %d. tau = %3.4g, (err,iter,time): streamingRWT homotopy-%3.4g,%3.4g,%3.4g, SpaRSA-%3.4g,%3.4g,%3.4g, YALL1-%3.4g,%3.4g,%3.4g. \n'</span>, <span class="keyword">...</span>
0577             SIM_stack{sim});
0578     <span class="keyword">end</span>
0579     
0580     <span class="comment">%% Plot LOT coeffs. on the window</span>
0581     <a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(1); subplot(211);
0582     plot([x xh_streamingRWT x_sparsa x_yall1]);
0583     title(<span class="string">'Comparison betweeen the original and reconstructed signal'</span>)
0584     
0585     <span class="comment">%% Reconstructed signal</span>
0586     xh = xh_streamingRWT;
0587     x_vec((sim-1)*N+1:sim*N,1) = x(1:N);
0588     
0589     <span class="comment">% remove the oldest estimate, shift the remaining up and left, and add the new estimate</span>
0590     estimate_buffer = [[estimate_buffer(N+1:<span class="keyword">end</span>,2:end); zeros(N,P-2)] xh(1:end-N)/(P-1)];
0591     <span class="keyword">if</span> avg_output
0592         xh_est = xh(1:N);
0593         xh(1:N) = sum(estimate_buffer(1:N,:),2);
0594         <span class="comment">% fig(123); plot([xh_est xh(1:N) x(1:N)])</span>
0595         <span class="keyword">if</span> sim == 2
0596             disp(<span class="string">'output is averaged'</span>);
0597         <span class="keyword">end</span>
0598     <span class="keyword">end</span>
0599     xh_vec((sim-1)*N+1:sim*N,1) = xh(1:N);
0600     xh_vec((sim-1)*N+1:sim*N,2) = x_sparsa(1:N);
0601     xh_vec((sim-1)*N+1:sim*N,3) = x_yall1(1:N);
0602     
0603     <span class="keyword">if</span> SM == 0
0604         <span class="comment">% obsolete</span>
0605         s_ind = t_ind(1:N+2*eta)-2*eta;
0606         sig_vec(t_ind(1:N)) = sigt(1:N);
0607         sigh_vec(s_ind,1) = sigh_vec(s_ind,1)+Psi*xh(1:N);
0608     <span class="keyword">else</span>
0609         s_ind = t_ind(1:N+2*eta);
0610         sig_vec(s_ind) = sigt(1:N+2*eta);
0611         sigh_vec(s_ind,1) = sigh_vec(s_ind,1)+Psi*xh(1:N);
0612         sigh_vec(s_ind,2) = sigh_vec(s_ind,2)+Psi*x_sparsa(1:N);
0613         sigh_vec(s_ind,3) = sigh_vec(s_ind,3)+Psi*x_yall1(1:N);
0614     <span class="keyword">end</span>
0615     
0616     
0617     <span class="comment">%% plot recovered signals</span>
0618     <a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(1); subplot(212)
0619     <span class="keyword">if</span> sim &lt; P*N+eta*P
0620         plot([sig_vec(1:s_ind(end)) sigh_vec(1:s_ind(end),1)]);
0621     <span class="keyword">else</span>
0622         plot([sig_vec(s_ind(end)-P*N-2*eta+1:s_ind(end)) sigh_vec(s_ind(end)-P*N-2*eta+1:s_ind(end),1)]);
0623     <span class="keyword">end</span>
0624     
0625     <span class="comment">%% spectrogram</span>
0626     <span class="keyword">if</span> mod(sim,25) == -1
0627         <a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(3);
0628         subplot(211); spectrogram(sig_vec(1:s_ind(end)),N,0,N,length(sig),<span class="string">'yaxis'</span>);
0629         subplot(212); spectrogram(sigh_vec(1:s_ind(end),1),N,N-1,N,length(sig),<span class="string">'yaxis'</span>); shg
0630     <span class="keyword">end</span>
0631     drawnow;
0632 <span class="keyword">end</span>
0633 
0634 mS =  sum(cell2mat(SIM_stack),1);
0635 fprintf(<span class="string">'Summed results: streaming_iter %d. tau = %3.4g, \n solver-(err,iter,time): \n streamingRWT homotopy-%3.4g,%3.4g,%3.4g; \n SpaRSA-%3.4g,%3.4g,%3.4g; \n YALL1-%3.4g,%3.4g,%3.4g. \n'</span>, streaming_iter, mS(2:end));
0636 mS =  mean(cell2mat(SIM_stack),1);
0637 fprintf(<span class="string">'Average results: streaming_iter %d. tau = %3.4g, \n solver-(err,iter,time): \n streamingRWT homotopy-%3.4g,%3.4g,%3.4g; \n SpaRSA-%3.4g,%3.4g,%3.4g; \n YALL1-%3.4g,%3.4g,%3.4g. \n'</span>, streaming_iter, mS(2:end));
0638 
0639 <span class="comment">% l1homotopy-%3.4g,%3.4g,%3.4g;</span>
0640 err_l1homotopy = norm(sig_vec(2*eta+1:N*sim)-sigh_vec(2*eta+1:N*sim,1))^2/norm(sig_vec(2*eta+1:N*sim))^2;
0641 err_sparsa = norm(sig_vec(2*eta+1:N*sim)-sigh_vec(2*eta+1:N*sim,2))^2/norm(sig_vec(2*eta+1:N*sim))^2;
0642 err_yall1 = norm(sig_vec(2*eta+1:N*sim)-sigh_vec(2*eta+1:N*sim,3))^2/norm(sig_vec(2*eta+1:N*sim))^2;
0643 fprintf(<span class="string">'Signal MSE: l1homotopy-%3.4g, sparsa-%3.4g, yall1-%3.4g.\n'</span>,([err_l1homotopy,err_sparsa,err_yall1]));
0644 fprintf(<span class="string">'Signal SER (in dB): l1homotopy-%3.4g, sparsa-%3.4g, yall1-%3.4g.\n'</span>,-10*log10([err_l1homotopy,err_sparsa,err_yall1]));
0645 
0646 
0647 <span class="comment">%% plot signal and reconstruction error</span>
0648 x_len = min(length(x_vec),length(xh_vec))-(P-1)*N;
0649 sig_len = min(length(sig_vec),length(sigh_vec))-(P-1)*N-2*eta;
0650 x_vec1 = x_vec(1:x_len);
0651 xh_vec1 = xh_vec(1:x_len,1);
0652 sig_vec1 = sig_vec(1:sig_len);
0653 sigh_vec1 = sigh_vec(1:sig_len,1);
0654 
0655 <a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(123);
0656 subplot(221);
0657 plot((1:sig_len)/N,sig_vec1, <span class="string">'LineWidth'</span>,1);
0658 axis tight;
0659 title(<span class="string">'original signal'</span>)
0660 subplot(2,2,2)
0661 plot((1:sig_len)/N,sigh_vec1-sig_vec1, <span class="string">'LineWidth'</span>,1);
0662 axis tight
0663 title(<span class="string">'reconstruction error'</span>)
0664 subplot(2,2,3);
0665 imagesc(reshape(x_vec1,N,x_len/N)); axis xy;
0666 axis tight;
0667 title(<span class="string">'LOT coefficients'</span>);
0668 colorbar
0669 subplot(2,2,4);
0670 imagesc(reshape(x_vec1-xh_vec1,N,x_len/N),[0 max(abs(x_vec1))/20]); axis xy
0671 axis tight
0672 title(<span class="string">'reconstruction error (LOT)'</span>);
0673 colorbar
0674 
0675 
0676 <a href="../L1_homotopy_v2.0/utils/fig.html" class="code" title="function h = fig(varargin)">fig</a>(3);
0677 subplot(211); spectrogram(sig_vec(1:s_ind(end)),N,N-1,N,length(sig),<span class="string">'yaxis'</span>);
0678 subplot(212); spectrogram(sigh_vec(1:s_ind(end),1),N,N-1,N,length(sig),<span class="string">'yaxis'</span>); shg</pre></div>
<hr><address>Generated on Sun 09-Jun-2013 02:08:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>